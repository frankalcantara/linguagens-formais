# Conjuntos FIRST e FOLLOW

Não dá nem para começar a pensar em criar um *parser* $LL(1)$ se não entender os conjuntos $FIRST$ e $FOLLOW$. [Também não dá para entender estes conjuntos se não souber o que é um *parser* $LL(1)$](https://frankalcantara.com/parsers-ll(1)/) Imagine que você está aprendendo um novo idioma. Para formar frases corretas, você precisará entender quais palavras podem vir antes ou depois de outras. Ou corre o risco de falar como o Yoda. Se quiser evitar ser confundido com um velho alienígena, precisa aprender, no mínimo, a ordem das palavras, muito antes de entender a classe gramatical destas mesmas palavras. Como uma criança aprendendo a falar.

Eu forcei um pouco a barra na metáfora, mas na análise sintática de linguagens livres de contexto, os conjuntos $FIRST$ e $FOLLOW$ desempenham um papel importante que quase valida minha metáfora. Estes conjuntos ajudam a decifrar a gramática da linguagem de forma determinística determinando as regras de produção que serão aplicadas aos símbolos da *string* de entrada para garantir que ele faça parte da linguagem.

O conjunto $FIRST$ de um símbolo não-terminal será composto dos símbolos terminais que podem aparecer como **primeiro símbolo** de qualquer sequência de símbolos que seja derivada desse não-terminal. Em outras palavras, o conjunto $FIRST$ indica quais terminais podem iniciar uma declaração válida (frase) dentro da estrutura gramática definida por um não-terminal. Por exemplo, considere uma gramática para definir expressões aritméticas. O não-terminal *EXPR* pode derivar diversas sequências de símbolos, como *2 + 3*, *(4 * 5)*, *x - y*. O conjunto $FIRST$ do não-terminal *EXPR* seria, neste caso específico, ${número, '+', '-', '('}$, porque esses são os símbolos que podem iniciar qualquer expressão aritmética válida nesta gramática até onde podemos saber com as informações passadas neste parágrafo. Uma gramática para todas as expressões aritméticas possíveis teria um conjunto $FIRST$ maior.

O conjunto $FOLLOW$, por sua vez, determina o conjunto de símbolos terminais que podem aparecer **imediatamente após** um não-terminal em alguma derivação da gramática. Ou colocando de outra forma, o conjunto $FOLLOW$ indica quais terminais podem seguir (*follow*) um não-terminal em uma declaração válida da linguagem.

Diferentemente do $FIRST$, que se concentra no início de uma derivação, o $FOLLOW$ analisa a situação em que um não-terminal aparece, considerando as produções diretas do não-terminal e também as produções de outros não terminais que, por ventura, contenham o não-terminal em análise. Por exemplo, considere uma gramática que define declarações de variáveis. O não-terminal *DECLARACAO_VAR* pode ser seguido por diferentes símbolos, dependendo do contexto. Em uma linguagem como o $C$, uma declaração de variável pode terminar com um ponto e vírgula, ser seguida por um operador de atribuição e uma expressão, ou até mesmo ser parte de uma estrutura maior. Neste cenário, o conjunto $FOLLOW$ do não-terminal *DECLARACAO_VAR* incluiria, portanto, o ponto e vírgula ';', o sinal de igual '=', e todos os outros símbolos que podem iniciar uma expressão ou um comando que a linguagem permita ocorrer na mesma linha da declaração da variável.

Os conjuntos $FIRST$ e $FOLLOW$ serão utilizados para construir a Tabela de Derivação $LL(1)$. A forma tecnicamente mais correta seria dizer que estes conjuntos formam a Tabela De Análise $LL(1)$. Entretanto, pobre de mim, prefiro chamar de Tabela de Derivação.

As Tabelas de Derivação são tabelas que guiam o processo de análise sintática descendente preditiva no *parser* $LL(1)$ deterministicamente. Cada célula dessas tabelas corresponde a relação que existe em um par não-terminal, terminal. De forma que o valor da célula apontada por este par indica qual regra de produção deve ser aplicada quando o analisador encontrar este par específico durante a análise preditiva $LL(1)$.

## O Conjunto FIRST

O conjunto $FIRST$ de um símbolo não-terminal é o conjunto de todos os terminais que podem aparecer no início de qualquer *string* derivada desse símbolo, incluindo o símbolo vazio ($\varepsilon$) se o não-terminal puder derivar a *string* vazia. Para os símbolos terminais, o elemento do conjunto $FIRST$ será o próprio símbolo terminal.

### Regras de Criação do Conjunto FIRST

Para definir o conjunto $FIRST(X)$ para todos os símbolos não-terminais $X$ de uma gramática que esteja definida por um conjunto de regras de produção, podemos seguir os seguintes passos:

1. **Para símbolos terminais**: o conjunto $FIRST$ é o próprio símbolo terminal. Ou seja, se $a$ é um terminal, então $FIRST(a) = {a}$.

2. **Para um símbolo não-terminal $X$**: olhe para cada regra de produção $X \rightarrow \alpha$ e siga as seguintes regras:

    - Se $\alpha$ é um terminal, adicione $\alpha$ ao conjunto $FIRST(X)$.
    - Se $\alpha$ começa com um símbolo não-terminal $Y$, adicione $FIRST(Y)$ ao $FIRST(X)$, exceto pelo símbolo de vazio $(\varepsilon$) se ele estiver presente.
    - Se $\alpha$ consiste apenas em não-terminais e todos eles podem derivar em vazio (diretamente ou indiretamente), adicione $\varepsilon$ ao conjunto $FIRST(X)$.
    
**O símbolo vazio $\varepsilon$ pertence ao conjunto FIRST(X) se, e somente se, $X$ pode derivar a string vazia (diretamente ou indiretamente).**

Repita esses passos até que os conjuntos $FIRST$ de todos os símbolos não-terminais não possam ser alterado.

### Exemplo 1: Criação de Conjuntos FIRST

Considere a gramática definida pelo seguinte conjunto de regras de produção:

$$
\begin{array}{cc}
1. &S \rightarrow aB \vert  bA \\
2. &A \rightarrow c \vert  d \\
3. &B \rightarrow e \vert  f \\
\end{array}
$$

Este conjunto de regras de produção permite criar:

| Símbolo | FIRST | Explicação |
|---------|--------|-------------|
| S | {a, b} | S pode ser derivado em "aB" ou "bA" |
| A | {c, d} | A pode ser derivado em "c" ou "d" |
| B | {e, f} | B pode ser derivado em "e" ou "f" |

Logo: $FIRST =\{(S,\{a, b\}),(A,\{c, d\}),(B,\{e, f\})\}$, um conjunto de tuplas.

Agora que entendemos o algoritmo, podemos tentar criar um pseudocódigo para encontrar os elementos do conjunto $First$.

### Algoritmo para calcular o conjunto FIRST

```pseudo
## Algoritmo para calcular o conjunto FIRST para símbolos não-terminais

# Entrada: Um conjunto de regras de produção P
# Saída: Um dicionário FIRST, onde FIRST[X] é o conjunto FIRST do símbolo não-terminal X

função calcular_FIRST(gramática):
    FIRST = {}  # Inicializa o dicionário FIRST

    # Passo 1: Inicialização para não-terminais
    para cada símbolo não-terminal X na gramática:
        FIRST[X] <- {}

    # Passo 2: Iteração para não-terminais
    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        para cada regra de produção X \rightarrow Y1 Y2 ... Yn na gramática:
            k = 0
            adicionou_epsilon = verdadeiro
            enquanto k < n e adicionou_epsilon:
                adicionou_epsilon = falso
                Yk = Y[k]

                # Se Yk é terminal, adicionar Yk ao FIRST[X]
                se Yk é terminal:
                    se Yk não está em FIRST[X]:
                        adicionar Yk a FIRST[X]
                        mudou = verdadeiro
                # Se Yk é não-terminal, adicionar FIRST[Yk] ao FIRST[X], exceto \varepsilon
                senão:
                    para cada símbolo t em FIRST[Yk]:
                        se t != "\varepsilon":
                            se t não está em FIRST[X]:
                                adicionar t a FIRST[X]
                                mudou = verdadeiro
                        senão:
                            adicionou_epsilon = verdadeiro
                k = k + 1

            # Se todos os Y1, Y2, ..., Yn podem derivar \varepsilon, adicionar \varepsilon ao FIRST[X]
            se k == n e adicionou_epsilon:
                se "\varepsilon" não está em FIRST[X]:
                    adicionar "\varepsilon" a FIRST[X]
                    mudou = verdadeiro

    retornar FIRST
```

Este pseudocódigo, poderia ser criado em python com um código parecido com este:

```python
def calcular_FIRST(producoes):
    FIRST = {}

    # Passo 1: Inicialização para não-terminais
    # Identificamos todos os símbolos não-terminais presentes nas produções
    nao_terminais = {regra.split('\rightarrow')[0].strip() for regra in producoes}

    # Inicializamos o conjunto FIRST de cada não-terminal como um conjunto vazio
    for nao_terminal in nao_terminais:
        FIRST[nao_terminal] = set()

    mudou = True
    # O loop continua até que não haja mais mudanças nos conjuntos FIRST
    while mudou:
        mudou = False
        # Iteramos por todas as produções da gramática
        for producao in producoes:
            partes = producao.split('\rightarrow')
            X = partes[0].strip()  # Não-terminal do lado esquerdo da produção
            Y = partes[1].strip().split()  # Lista de símbolos do lado direito da produção

            k = 0
            adicionou_epsilon = True  # Flag para controlar a adição de \varepsilon
            # Iteramos sobre os símbolos do lado direito da produção
            while k < len(Y) and adicionou_epsilon:
                adicionou_epsilon = False
                Yk = Y[k]

                # Se Yk é um não-terminal, adicionamos seus FIRST ao FIRST de X
                if Yk in nao_terminais:
                    for simbolo in FIRST[Yk]:
                        if simbolo != "\varepsilon":
                            if simbolo not in FIRST[X]:
                                FIRST[X].add(simbolo)
                                mudou = True
                        else:
                            adicionou_epsilon = True
                else:
                    # Se Yk é um terminal, adicionamos Yk ao FIRST de X
                    if Yk not in FIRST[X]:
                        FIRST[X].add(Yk)
                        mudou = True
                    adicionou_epsilon = False  # Paramos de adicionar se encontramos um terminal
                k += 1

            # Se todos os símbolos Y1, Y2, ..., Yn podem derivar \varepsilon, adicionamos \varepsilon ao FIRST de X
            if k == len(Y) and adicionou_epsilon:
                if "\varepsilon" not in FIRST[X]:
                    FIRST[X].add("\varepsilon")
                    mudou = True

    return FIRST

# Exemplo de uso
producoes = [
    "S \rightarrow a B",
    "S \rightarrow b A",
    "A \rightarrow c",
    "A \rightarrow d",
    "B \rightarrow e",
    "B \rightarrow f"
]

FIRST = calcular_FIRST(producoes)
for nao_terminal in FIRST:
    print(f"FIRST({nao_terminal}) = {FIRST[nao_terminal]}")
```

## O Conjunto FOLLOW

O conjunto $FOLLOW$ de um símbolo não-terminal é o conjunto de terminais que podem aparecer imediatamente à direita (após, *follow*) desse não-terminal em alguma forma sentencial derivada, **ou o símbolo de fim de entrada ($) se o não-terminal puder aparecer no final de uma forma sentencial**.

Para definir o conjunto $FOLLOW(A)$ para cada não-terminal $A$, siga estes passos:

1. Coloque o símbolo de fim de entrada $(\$)$ no $FOLLOW$ do símbolo inicial da gramática. Ao colocar o símbolo de fim de entrada (\$) no $FOLLOW$ do símbolo inicial da gramática, garantimos que o analisador sintático reconheça a última derivação da gramática como válida. Isso significa que o analisador estará preparado para encontrar o símbolo ($\$$) ao final da string de entrada, indicando que a análise foi concluída com sucesso. Em outras palavras, o símbolo ($\$$) no $FOLLOW$ do símbolo inicial representa a expectativa de que a string de entrada seja completamente processada e que não existam símbolos após a última derivada.

2. Para cada produção da forma $A \rightarrow \alpha B \beta$, onde $B$ é um não-terminal:
  
  - Se $\beta$ não deriva $\varepsilon$ (a string vazia), adicione $FIRST(\beta)$ (sem $\varepsilon$) a $FOLLOW(B)$.
  - Se $\beta$ deriva $\varepsilon$ (a string vazia) **ou $\beta$ é a string vazia**, adicione $FOLLOW(A)$ a $FOLLOW(B)$.

Repita esses passos até que os conjuntos $FOLLOW$ de todos os símbolos não-terminais não mudem mais.

**Exemplo**: Considere a gramática definida por:

$$
\begin{array}{cc}
1. & S \rightarrow aB \vert  bA \\
2. & A \rightarrow c \vert  d \\
3. & B \rightarrow e \vert  f \\
\end{array}
$$

**Conjunto FIRST**:

*   $FIRST(S) = \{a, b\}$  (S pode derivar em $aB$ ou $bA$)
*   $FIRST(A) = \{c, d\}$  (A pode derivar em $c$ ou $d$)
*   $FIRST(B) = \{e, f\}$  (B pode derivar em $e$ ou $f$)

**Conjunto FOLLOW**:

Para calcular o conjunto FOLLOW, seguimos as regras aplicadas à gramática do exemplo:

1.  [cite_start]$FOLLOW(S) = \{\$\}$ 
    * [cite_start]$S$ é o símbolo inicial, então adicionamos o marcador de fim de entrada ($\$$) ao seu conjunto FOLLOW. 

2.  $FOLLOW(A) = \{\$\}$
    * Analisamos as regras para encontrar onde $A$ aparece no lado direito. [cite_start]Encontramos $A$ na produção $S \to bA$.
    * [cite_start]Como não há nenhum símbolo após $A$ nesta produção, adicionamos todos os elementos de $FOLLOW(S)$ ao conjunto $FOLLOW(A)$.
    * Portanto, $FOLLOW(A)$ recebe $\{\$\}$.

3.  $FOLLOW(B) = \{\$\}$
    * Analisamos as regras para encontrar onde $B$ aparece no lado direito. [cite_start]Encontramos $B$ na produção $S \rightarrow aB$.
    * [cite_start]Como também não há nenhum símbolo após $B$ nesta produção, adicionamos todos os elementos de $FOLLOW(S)$ ao conjunto $FOLLOW(B)$.
    * Portanto, $FOLLOW(B)$ também recebe $\{\$\}$.

[cite_start]Criamos o conjunto $FIRST$ porque este é necessário para a criação do conjunto $FOLLOW$. Mas, neste momento nos interessa apenas o conjunto $FOLLOW$. O conjunto resultante será:

| Símbolo | FOLLOW | Explicação |
|:---|:---|:---|
| $S$ | $\{ \$ \}$ | [cite_start]$S$ é o símbolo inicial, então $\$$ é adicionado ao seu conjunto FOLLOW. |
| $A$ | $\{ \$ \}$ | $A$ aparece na produção $S \to bA$. [cite_start]Como $A$ está no final, $FOLLOW(A)$ herda o conteúdo de $FOLLOW(S)$. |
| $B$ | $\{ \$ \}$ | $B$ aparece na produção $S \to aB$. [cite_start]Como $B$ está no final, $FOLLOW(B)$ herda o conteúdo de $FOLLOW(S)$. |


## Algoritmo para calcular o conjunto FOLLOW

Assim como fizemos com o $FIRST$ podemos criar um algoritmo para criar o conjunto $FOLLOW$:

```shell
# Algoritmo para calcular o conjunto FIRST para símbolos não-terminais
# Entrada: Um conjunto de regras de produção P
# Saída: Um dicionário FIRST, onde FIRST[X] é o conjunto FIRST do símbolo não-terminal X

função calcular_FIRST(producoes):
    FIRST = {}  # Inicializa o dicionário FIRST
    
    # Identifica todos os não-terminais e terminais
    nao_terminais = conjunto vazio
    para cada producao nas producoes:
        X = lado esquerdo da producao (antes de "->")
        adicionar X aos nao_terminais
    
    # Passo 1: Inicialização - cria conjuntos vazios para cada não-terminal
    para cada X em nao_terminais:
        FIRST[X] = conjunto vazio
    
    # Passo 2: Iteração até convergência
    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        para cada producao nas producoes:
            X = lado esquerdo da producao
            simbolos = lado direito da producao (lista de símbolos)
            
            # Caso especial: produção vazia (X -> epsilon)
            se simbolos == ["epsilon"]:
                se "epsilon" não está em FIRST[X]:
                    adicionar "epsilon" a FIRST[X]
                    mudou = verdadeiro
                continuar para próxima produção
            
            # Percorre os símbolos do lado direito
            k = 0
            continuar = verdadeiro
            enquanto k < tamanho(simbolos) e continuar:
                Yk = simbolos[k]
                continuar = falso
                
                # Se Yk é terminal
                se Yk não está em nao_terminais e Yk != "epsilon":
                    se Yk não está em FIRST[X]:
                        adicionar Yk a FIRST[X]
                        mudou = verdadeiro
                # Se Yk é não-terminal
                senão se Yk está em nao_terminais:
                    # Adiciona FIRST[Yk] - {epsilon} a FIRST[X]
                    para cada simbolo em FIRST[Yk]:
                        se simbolo != "epsilon":
                            se simbolo não está em FIRST[X]:
                                adicionar simbolo a FIRST[X]
                                mudou = verdadeiro
                    # Se epsilon está em FIRST[Yk], continua para próximo símbolo
                    se "epsilon" está em FIRST[Yk]:
                        continuar = verdadeiro
                k = k + 1
            
            # Se todos os símbolos podem derivar epsilon
            se continuar == verdadeiro:
                se "epsilon" não está em FIRST[X]:
                    adicionar "epsilon" a FIRST[X]
                    mudou = verdadeiro
    
    retornar FIRST
```

Agora que temos um pseudo código, podemos partir para o código em Python. Neste ponto, a atenta leitora precisa lembrar que vamos precisar do conjunto $FIRST$ para encontrar o conjunto $FOLLOW$. Logo começando pelo $FIRST$, teremos:

```python
def calcular_FIRST(producoes):
    """
    Calcula o conjunto FIRST para todos os não-terminais de uma gramática.
    
    Args:
        producoes: Lista de strings representando as produções (ex: "S -> a B")
    
    Returns:
        Dicionário onde as chaves são não-terminais e valores são conjuntos FIRST
    """
    FIRST = {}
    
    # Identifica todos os não-terminais (símbolos do lado esquerdo)
    nao_terminais = set()
    for producao in producoes:
        X = producao.split('->')[0].strip()
        nao_terminais.add(X)
    
    # Passo 1: Inicialização - cria conjuntos vazios para cada não-terminal
    for nao_terminal in nao_terminais:
        FIRST[nao_terminal] = set()
    
    # Passo 2: Iteração até convergência
    mudou = True
    while mudou:
        mudou = False
        for producao in producoes:
            partes = producao.split('->')
            X = partes[0].strip()
            simbolos = partes[1].strip().split()
            
            # Caso especial: produção vazia (X -> epsilon)
            if simbolos == ['epsilon']:
                if 'epsilon' not in FIRST[X]:
                    FIRST[X].add('epsilon')
                    mudou = True
                continue
            
            # Percorre os símbolos do lado direito
            k = 0
            continuar = True
            while k < len(simbolos) and continuar:
                Yk = simbolos[k]
                continuar = False
                
                # Se Yk é terminal
                if Yk not in nao_terminais and Yk != 'epsilon':
                    if Yk not in FIRST[X]:
                        FIRST[X].add(Yk)
                        mudou = True
                # Se Yk é não-terminal
                elif Yk in nao_terminais:
                    # Adiciona FIRST[Yk] - {epsilon} a FIRST[X]
                    for simbolo in FIRST[Yk]:
                        if simbolo != 'epsilon':
                            if simbolo not in FIRST[X]:
                                FIRST[X].add(simbolo)
                                mudou = True
                    # Se epsilon está em FIRST[Yk], continua para próximo símbolo
                    if 'epsilon' in FIRST[Yk]:
                        continuar = True
                k += 1
            
            # Se todos os símbolos podem derivar epsilon
            if continuar:
                if 'epsilon' not in FIRST[X]:
                    FIRST[X].add('epsilon')
                    mudou = True
    
    return FIRST
```

Finalmente podemos ver o pseudocódigo e o código em Python para encontrar o conjunto $FOLLOW$:

```shell
# Algoritmo para calcular o conjunto FOLLOW para símbolos não-terminais
# Entrada: Um conjunto de regras de produção P e o símbolo inicial S
# Saída: Um dicionário FOLLOW, onde FOLLOW[X] é o conjunto FOLLOW do símbolo não-terminal X

função calcular_FOLLOW(producoes, simbolo_inicial):
    # Primeiro calcula o conjunto FIRST que será necessário
    FIRST = calcular_FIRST(producoes)
    FOLLOW = {}  # Inicializa o dicionário FOLLOW
    
    # Identifica todos os não-terminais
    nao_terminais = conjunto vazio
    para cada producao nas producoes:
        X = lado esquerdo da producao (antes de "->")
        adicionar X aos nao_terminais
    
    # Passo 1: Inicialização - cria conjuntos vazios para cada não-terminal
    para cada X em nao_terminais:
        FOLLOW[X] = conjunto vazio
    
    # Passo 2: Adiciona $ ao FOLLOW do símbolo inicial
    FOLLOW[simbolo_inicial] = {"$"}
    
    # Passo 3: Iteração até convergência
    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        para cada producao nas producoes:
            A = lado esquerdo da producao
            alfa = lado direito da producao (lista de símbolos)
            
            # Para cada símbolo na produção
            para i de 0 até tamanho(alfa) - 1:
                B = alfa[i]
                
                # Se B é um não-terminal
                se B está em nao_terminais:
                    beta = alfa[i+1:fim]  # símbolos após B
                    
                    # Se existe sequência beta após B
                    se beta não é vazia:
                        # Calcula FIRST(beta)
                        first_beta = calcular_first_da_sequencia(beta, FIRST, nao_terminais)
                        
                        # Adiciona FIRST(beta) - {epsilon} em FOLLOW(B)
                        para cada simbolo em first_beta:
                            se simbolo != "epsilon":
                                se simbolo não está em FOLLOW[B]:
                                    adicionar simbolo a FOLLOW[B]
                                    mudou = verdadeiro
                        
                        # Se epsilon está em FIRST(beta), adiciona FOLLOW(A) em FOLLOW(B)
                        se "epsilon" está em first_beta:
                            para cada simbolo em FOLLOW[A]:
                                se simbolo não está em FOLLOW[B]:
                                    adicionar simbolo a FOLLOW[B]
                                    mudou = verdadeiro
                    
                    # Se não há nada após B (B está no final)
                    senão:
                        # Adiciona FOLLOW(A) em FOLLOW(B)
                        para cada simbolo em FOLLOW[A]:
                            se simbolo não está em FOLLOW[B]:
                                adicionar simbolo a FOLLOW[B]
                                mudou = verdadeiro
    
    retornar FOLLOW

# Função auxiliar para calcular FIRST de uma sequência de símbolos
função calcular_first_da_sequencia(sequencia, FIRST, nao_terminais):
    first_sequencia = conjunto vazio
    
    para cada simbolo na sequencia:
        # Se é terminal, adiciona e para
        se simbolo não está em nao_terminais:
            adicionar simbolo a first_sequencia
            parar o loop
        # Se é não-terminal
        senão:
            # Adiciona FIRST[simbolo] - {epsilon}
            para cada s em FIRST[simbolo]:
                se s != "epsilon":
                    adicionar s a first_sequencia
            # Se epsilon não está em FIRST[simbolo], para
            se "epsilon" não está em FIRST[simbolo]:
                parar o loop
    
    # Se percorreu toda a sequência (todos derivam epsilon)
    se percorreu toda a sequencia:
        adicionar "epsilon" a first_sequencia
    
    retornar first_sequencia
```

Finalmente o código em Python será:

```python
def calcular_first_da_sequencia(sequencia, FIRST, nao_terminais):
    """
    Calcula o FIRST de uma sequência de símbolos.
    
    Args:
        sequencia: Lista de símbolos
        FIRST: Dicionário com conjuntos FIRST já calculados
        nao_terminais: Conjunto de não-terminais da gramática
    
    Returns:
        Conjunto FIRST da sequência
    """
    first_sequencia = set()
    
    for simbolo in sequencia:
        # Se é terminal, adiciona e para
        if simbolo not in nao_terminais:
            first_sequencia.add(simbolo)
            break
        # Se é não-terminal
        else:
            # Adiciona FIRST[simbolo] - {epsilon}
            for s in FIRST[simbolo]:
                if s != 'epsilon':
                    first_sequencia.add(s)
            # Se epsilon não está em FIRST[simbolo], para
            if 'epsilon' not in FIRST[simbolo]:
                break
    else:
        # Se percorreu toda a sequência (todos derivam epsilon)
        first_sequencia.add('epsilon')
    
    return first_sequencia

def calcular_FOLLOW(producoes, simbolo_inicial):
    """
    Calcula o conjunto FOLLOW para todos os não-terminais de uma gramática.
    
    Args:
        producoes: Lista de strings representando as produções
        simbolo_inicial: Símbolo inicial da gramática
    
    Returns:
        Dicionário onde as chaves são não-terminais e valores são conjuntos FOLLOW
    """
    # Primeiro calcula o conjunto FIRST que será necessário
    FIRST = calcular_FIRST(producoes)
    FOLLOW = {}
    
    # Identifica todos os não-terminais
    nao_terminais = set()
    for producao in producoes:
        X = producao.split('->')[0].strip()
        nao_terminais.add(X)
    
    # Passo 1: Inicialização - cria conjuntos vazios para cada não-terminal
    for nao_terminal in nao_terminais:
        FOLLOW[nao_terminal] = set()
    
    # Passo 2: Adiciona $ ao FOLLOW do símbolo inicial
    FOLLOW[simbolo_inicial].add('$')
    
    # Passo 3: Iteração até convergência
    mudou = True
    while mudou:
        mudou = False
        for producao in producoes:
            partes = producao.split('->')
            A = partes[0].strip()
            alfa = partes[1].strip().split()
            
            # Para cada símbolo na produção
            for i in range(len(alfa)):
                B = alfa[i]
                
                # Se B é um não-terminal
                if B in nao_terminais:
                    beta = alfa[i+1:]  # símbolos após B
                    
                    # Se existe sequência beta após B
                    if beta:
                        # Calcula FIRST(beta)
                        first_beta = calcular_first_da_sequencia(beta, FIRST, nao_terminais)
                        
                        # Adiciona FIRST(beta) - {epsilon} em FOLLOW(B)
                        for simbolo in first_beta:
                            if simbolo != 'epsilon':
                                if simbolo not in FOLLOW[B]:
                                    FOLLOW[B].add(simbolo)
                                    mudou = True
                        
                        # Se epsilon está em FIRST(beta), adiciona FOLLOW(A) em FOLLOW(B)
                        if 'epsilon' in first_beta:
                            for simbolo in FOLLOW[A]:
                                if simbolo not in FOLLOW[B]:
                                    FOLLOW[B].add(simbolo)
                                    mudou = True
                    
                    # Se não há nada após B (B está no final)
                    else:
                        # Adiciona FOLLOW(A) em FOLLOW(B)
                        for simbolo in FOLLOW[A]:
                            if simbolo not in FOLLOW[B]:
                                FOLLOW[B].add(simbolo)
                                mudou = True
    
    return FOLLOW

# Exemplo de uso completo
if __name__ == "__main__":
    # Definindo a gramática
    producoes = [
        "S -> a B",
        "S -> b A",
        "A -> c",
        "A -> d",
        "B -> e",
        "B -> f"
    ]
    simbolo_inicial = "S"
    
    # Calculando FIRST
    print("Conjuntos FIRST:")
    FIRST = calcular_FIRST(producoes)
    for nao_terminal in sorted(FIRST.keys()):
        print(f"  FIRST({nao_terminal}) = {{{', '.join(sorted(FIRST[nao_terminal]))}}}")
    
    # Calculando FOLLOW
    print("\nConjuntos FOLLOW:")
    FOLLOW = calcular_FOLLOW(producoes, simbolo_inicial)
    for nao_terminal in sorted(FOLLOW.keys()):
        print(f"  FOLLOW({nao_terminal}) = {{{', '.join(sorted(FOLLOW[nao_terminal]))}}}")
```
