# Parsers LL(1): Começando a Análise Sintática

::: {.content-hidden when-format="pdf"}
:::{.callout-tip}
Está sem tempo? Leia o [Expresso](.\ex\05-expresso.html).
:::
:::

**Elementar meu caro Watson!** Mesmo que Sherlock nunca tenha dito esta frase nos livros de [Sir Arthur Conan Doyle](https://www.ebiografia.com/arthur_conan_doyle/), a lembrança do grande detetive ocupa meu imaginário sempre que falo de *parsers*. Assim como o grande detetive, o trabalho do *parser* será verificar todos os detalhes de uma cena e validar cada um dos seus itens em relação a um contexto. No nosso caso, a cena será formada por um *string* e o contexto do crime, será determinado por uma Tabela de Derivação. Infelizmente nosso detetive, o *parser* $LL(1)$, nem de perto terá a mesma capacidade de Sherlock Holmes. Ainda que seja eficiente, um *parser* $LL(1)$ é linear e determinístico e, pensando bem, esta foi uma metáfora ruim. Mas, eu sempre quis começar um texto falado: elementar meu caro Watson!.

Em geral, ainda que muitos lenços de papel tenham sido gastos durantes as avaliações de final de período, *parsers* $LL(1)$ são algoritmos simples.

Um *parser* $LL(1)$ é um tipo de analisador sintático descendente que utiliza a análise preditiva, e uma tabela que chamarei de Tabela de Derivação, para determinar qual será a regra de produção que deverá ser aplicada em cada etapa da análise expandindo um símbolo não-terminal de acordo com uma de suas regras de produção, criando uma árvore sintática e permitindo a identificação de um *string* como parte de uma determinada linguagem. Esta ideia começou com o trabalho [*On the Translation of Languages from Left to Right*](https://www.sciencedirect.com/science/article/pii/S0019995865904262) de [Donald Knuth](https://pt.wikipedia.org/wiki/Donald_Knuth) mas foi sendo aprimorada ao longo do tempo por pesquisadores como [Alfred Aho](https://en.wikipedia.org/wiki/Alfred_Aho) e [Jeffrey Ullman](https://en.wikipedia.org/wiki/Jeffrey_Ullman), nas décadas de 1970 e 1980

A análise preditiva é um tipo de análise descendente que usa uma pilha para armazenar os símbolos esperados e os conjuntos $FIRST$ e $FOLLOW$ para prever qual regra de produção aplicar em cada etapa do processo de análise. Essa previsão permite que o analisador tome decisões sem precisar retroceder, tornando a análise mais eficiente computacionalmente. Esta análise preditiva será a ação que um parser $LL(1)$ irá utilizar para validar os *strings* de uma determinada linguagem, símbolo por símbolo.

Para atingir meu objetivo, com este texto, as linguagens que usaremos como exemplo serão representadas apenas pelo conjunto de regras de produção da sua gramática. Vou manter a álgebra o mais longe possível e se o conjunto de regras de produção estiver perfeitamente construído todos os elementos da gramática poderão ser identificados. Isso permitirá que aqueles sem arrepios algébricos tenham um ponto de partida para uma análise formal da linguagem.

Outro ponto importante, neste texto, símbolos não-terminais serão representados em caracteres latinos maiúsculos seguidos ou não de um apóstrofo ('), e os símbolos terminais em caracteres latinos minúsculos. A única exceção será $\varepsilon$ para representar uma produção vazia.

## Definição e Características dos Parsers LL(1)

Os *parsers* preditivos são analisadores sintáticos descendentes (*top-down*) que utilizam um único símbolo de *lookahead* (antecipação) para determinar a regra de produção correta a ser aplicada em cada etapa da análise. Eles *predizem* qual regra usar com base no próximo símbolo da entrada e no não-terminal atualmente sendo analisado. O termo $LL(1)$ significa:

- **L**: Left-to-right scan (varredura da esquerda para a direita) da entrada.
- **L**: Leftmost derivation (derivação mais à esquerda) da gramática.
- **1**: Um símbolo de *lookahead* (antecipação) para tomada de decisão.

Um *parser* $LL(1)$, requer uma gramática $LL(1)$. Nesta gramática não pode existir qualquer ambiguidade na escolha da regra de produção que será aplicada a cada símbolo de *lookahead*. Além disso, a gramática não pode ter recursão à esquerda, seja esta recursão direta ou indireta. A recursão à esquerda é um desafio considerável. Existem duas formas de recursão à esquerda:

- **Recursão à Esquerda Direta**: ocorre quando um símbolo não-terminal pode ser derivado em uma sequência que começa com ele mesmo. Por exemplo, na regra $A \rightarrow Aa \mid b$, o símbolo $A$ pode ser substituído no processo de derivação em $Aa$, no qual $A$ aparece novamente no início da regra. E aqui está o laço infinito.

- **Recursão à Esquerda Indireta**: acontece quando um símbolo não-terminal pode ser derivado em uma sequência que começa com outro símbolo não-terminal, que por sua vez pode ser derivado de volta ao símbolo original. Ilustrando, nas regras $A \rightarrow Ba$ e $B \rightarrow Ab$, $A$ deriva para $Ba$, $B$ deriva para $Ab$ e $Ab$ pode derivar novamente para $A$, criando outro laço infinito.

Além do perigo do laço de repetição infinito que faz o pobre Turing se revolver no túmulo, a recursão à esquerda impede o desenvolvimento de uma Tabela de Derivação, graças a criação de regras em conflito. Duas ou mais regras, para a mesma combinação de símbolo terminal e símbolo não-terminal em um determinado momento do processo de *parser*.

## Eliminação da Recursão à Esquerda

Felizmente, existem técnicas para eliminar a recursão à esquerda em gramáticas livres de contexto. Uma técnica comum e eficaz envolve a introdução de novos símbolos não terminais e a substituição de regras recursivas por regras equivalentes que não apresentem recursão. Em alguns casos, a substituição direta dos símbolos não terminais recursivos por suas respectivas regras pode ser suficiente para eliminar a recursão à esquerda direta. Outra técnica, a fatoração à esquerda, pode ser utilizada para eliminar ambiguidades na gramática, mas não resolve diretamente o problema da recursão.

**Exemplo 1**: eliminando a Recursão à Esquerda Direta, considere a regra $A \rightarrow Aa \mid b$. Esta regra pode ser reescrita como:

1. $A \rightarrow bA'$
2. $A' \rightarrow aA' \mid \varepsilon$

Agora, a gramática não contém mais recursão à esquerda direta. Este é um exemplo simples, adequado a este texto cujo objetivo é o parser em si. A nova regra inclui o não-terminal $A'$, que permite zero ou mais repetições do símbolo $a$. O uso de $\varepsilon$ (a produção vazia) permite terminar a derivação de $A'$. Será?

Para verificar a recursão à esquerda indireta, você precisa observar se é possível derivar uma recursão por meio de uma cadeia de substituições:

1. Substituindo $A$:
    - $A \rightarrow bA'$
2. Substituindo $A'$:
    - $A' \rightarrow aA'$
    - $A' \rightarrow \varepsilon$

Observe que substituindo $A$ por $bA'$ e depois $A'$ por $aA'$ ou $\varepsilon$ não leva de volta a $A$. E parece não haver recursão. Contudo, é necessário verificar se foi criada alguma recursão à esquerda indireta, focando em $A'$:

- **Primeira substituição**:
    - $A \rightarrow bA'$
- **Substituindo** $A'$ por $aA'$:
    - $bA' \rightarrow b(aA')$
    - $bA' \rightarrow baA'$
- **Substituindo novamente** $A'$ por $aA'$:
    - $baA' \rightarrow baaA'$
- E assim por diante... Aqui, $A'$ substitui a si próprio com um prefixo $a$, mas isto não cria recursão indireta ao $A'$ inicial de forma a levar a uma cadeia circular que retorne ao símbolo inicial $A$. A gramática transformada não apresenta recursão à esquerda indireta para $A'$.
- $A$: Não tem recursão à esquerda direta nem indireta, porque $A \rightarrow bA'$ começa com um terminal.
- $A'$: A regra $A' \rightarrow aA' \mid \varepsilon$ apenas permite que $A'$ produza cadeias de $a$ seguidos possivelmente por $\varepsilon$, sem retornar a um estado anterior que causaria recursão indireta.

Portanto, a transformação feita elimina a recursão à esquerda direta sem introduzir recursão à esquerda indireta. A recursão à esquerda indireta é mais complexa e requer um texto específico para o assunto. Mas, em linhas gerais você terá que refazer a gramática em face dos objetivos originais para eliminar este tipo de recursão.

## Elementos Fundamentais do Parser LL(1)

Como a classe de gramáticas para um *parser* $LL(1)$ é limitada (nem todas as gramáticas livres de contexto são $LL(1)$, é muito comum que seja necessário modificar a sua ideia original de gramática para eliminar ambiguidades e recursões à esquerda. Um *parser* $LL(1)$, para funcionar, precisa dos seguintes elementos:

1. **Tabela de Derivação**: o *parser* $LL(1)$ utiliza uma Tabela de Derivação, ou Tabela de Análise (*parsing*), que mapeia cada combinação de não-terminal e terminal (ou símbolo de fim de entrada) para a regra de produção que deve ser aplicada. Essa tabela é construída a partir da gramática e dos conjuntos $FIRST$ e $FOLLOW$ e será o mapa que guiará todo o processo de análise sintática.

2. **Pilha e Buffer**: O parser mantém uma pilha e lê a entrada da esquerda para a direita, carácter por carácter. A pilha inicialmente contém o símbolo inicial da gramática e o símbolo de fim de entrada, um cifrão: \$. A entrada frequentemente é mantida em uma estrutura de dados com funcionalidades de *buffer*, que pode ser a própria *string* que está sendo analisada.

3. **Análise**: Em cada passo:

    - O parser consulta a Tabela de Derivação usando como índices o não-terminal no topo da pilha e o próximo símbolo da entrada.
    - A tabela indica a produção a ser aplicada.
    - O não-terminal no topo da pilha é substituído pelos símbolos da produção (empilhados em ordem inversa).
    - Se o topo da pilha for um terminal que coincide com o próximo símbolo da entrada, ambos são removidos da pilha e da entrada.

4. **Sucesso ou Erro**: A análise termina com sucesso quando a pilha e a entrada estão vazias. Caso contrário, ocorre um erro sintático. Erros poderão ocorrer durante o processo sempre que a combinação de símbolos na pilha e no *buffer* apontarem para uma célula vazia da Tabela de Derivação.

## Conjuntos NULLABLE, FIRST e FOLLOW

Não dá nem para começar a pensar em criar um *parser* $LL(1)$ se não entender os conjuntos $NULLABLE$, $FIRST$ e $FOLLOW$. Imagine que você está aprendendo um novo idioma. Para formar frases corretas, você precisará entender quais palavras podem vir antes ou depois de outras. Ou corre o risco de falar como o Yoda. Se quiser evitar ser confundido com um velho alienígena, precisa aprender, no mínimo, a ordem das palavras, muito antes de entender a classe gramatical destas mesmas palavras. Como uma criança aprendendo a falar.

Eu forcei um pouco a barra na metáfora, mas na análise sintática de linguagens livres de contexto, os conjuntos $NULLABLE$, $FIRST$ e $FOLLOW$ desempenham um papel importante que quase valida minha metáfora. Estes conjuntos ajudam a decifrar a gramática da linguagem de forma determinística, determinando as regras de produção que serão aplicadas aos símbolos da *string* de entrada para garantir que ela faça parte da linguagem.

Antes de detalharmos o $FIRST$ e o $FOLLOW$, precisamos de um conceito fundamental: o conjunto de símbolos **NULLABLE**. Um símbolo não-terminal é considerado *NULLABLE* se ele pode derivar a cadeia vazia ($\varepsilon$), ou seja, se ele pode efetivamente "desaparecer" em uma derivação. Saber se um símbolo pode ou não desaparecer é essencial para os cálculos seguintes.

O conjunto $FIRST$ de um símbolo não-terminal será composto dos símbolos terminais que podem aparecer como **primeiro símbolo** de qualquer sequência de símbolos que seja derivada desse não-terminal, incluindo $\varepsilon$ se o símbolo for *NULLABLE*. Em outras palavras, o conjunto $FIRST$ indica quais terminais podem iniciar uma declaração válida (frase) dentro da estrutura gramática definida por um não-terminal. Por exemplo, considere uma gramática para definir expressões aritméticas. O não-terminal *EXPR* pode derivar diversas sequências de símbolos, como *2 + 3*, *(4* 5)*,* x - y*. O conjunto* $FIRST$ do não-terminal EXPR\* seria, neste caso específico, ${número, '+', '-', '('}$, porque esses são os símbolos que podem iniciar qualquer expressão aritmética válida nesta gramática até onde podemos saber com as informações passadas neste parágrafo.

O conjunto $FOLLOW$, por sua vez, determina o conjunto de símbolos terminais que podem aparecer **imediatamente após** um não-terminal em alguma derivação da gramática. Ou colocando de outra forma, o conjunto $FOLLOW$ indica quais terminais podem seguir (*follow*) um não-terminal em uma declaração válida da linguagem.

Diferentemente do $FIRST$, que se concentra no início de uma derivação, o $FOLLOW$ analisa o contexto no qual um não-terminal aparece. Seu cálculo depende criticamente de saber quais símbolos são *NULLABLE*, pois se um símbolo $y$ que segue um não-terminal $X$ pode desaparecer, então tudo o que pode seguir a regra na qual $X$ e $y$ aparecem também pode seguir $X$. Por exemplo, considere uma gramática que define declarações de variáveis. O não-terminal *DECLARACAO_VAR* pode ser seguido por diferentes símbolos, dependendo do contexto. Em uma linguagem como a linguagem C, por exemplo, uma declaração de variável pode terminar com um ponto e vírgula, ser seguida por um operador de atribuição e uma expressão, ou até mesmo ser parte de uma estrutura maior. Neste cenário, o conjunto $FOLLOW$ do não-terminal *DECLARACAO_VAR* incluiria o ponto e vírgula ';', o sinal de igual '=', e todos os outros símbolos que podem iniciar uma expressão ou um comando que a linguagem permita ocorrer na mesma linha da declaração da variável.

Os conjuntos $NULLABLE$, $FIRST$ e $FOLLOW$ serão utilizados para construir a Tabela de Derivação $LL(1)$. A forma tecnicamente mais correta seria dizer que estes conjuntos formam a Tabela De Análise $LL(1)$. Entretanto, pobre de mim, prefiro chamar de Tabela de Derivação.

As Tabelas de Derivação são tabelas que guiam o processo de análise sintática descendente preditiva no *parser* $LL(1)$ deterministicamente. Cada célula dessas tabelas corresponde a relação que existe em um par não-terminal, terminal. De forma que o valor da célula apontada por este par indica qual regra de produção deve ser aplicada quando o analisador encontrar este par específico durante a análise preditiva $LL(1)$.

### O Conjunto NULLABLE

Antes de nos aprofundarmos nos conjuntos $FIRST$ e $FOLLOW$, é essencial entender um conceito preliminar: o conjunto dos símbolos $NULLABLE$. Um símbolo não-terminal é considerado $NULLABLE$ se ele pode derivar a cadeia vazia ($\varepsilon$) através de qualquer sequência de derivações possível.

**Importante:** Um símbolo pode ser $NULLABLE$ de três formas distintas:

1. **Nullable Direto**: Quando existe uma produção explícita $A \rightarrow \varepsilon$;
2. **Nullable Indireto Simples**: Quando $A \rightarrow B$ e $B$ é $NULLABLE$;
3. **Nullable Indireto Múltiplo**: Quando $A \rightarrow B_1 B_2 ... B_n$ e **todos** os símbolos $B_1, B_2, ..., B_n$ são $NULLABLE$ (seja direta ou indiretamente).

Por exemplo, considere as produções listadas a seguir:

- $A \rightarrow B C$;
- $B \rightarrow D E$;
- $C \rightarrow \varepsilon$;
- $D \rightarrow \varepsilon$;
- $E \rightarrow \varepsilon$.

Neste caso, teremos:

- $C$, $D$ e $E$ são $NULLABLE$ diretos (regra 1);
- $B$ é $NULLABLE$ porque $B \rightarrow D E$ e tanto $D$ quanto $E$ são $NULLABLE$ (regra 3);
- $A$ é $NULLABLE$ porque $A \rightarrow B C$ e tanto $B$ quanto $C$ são $NULLABLE$ (regra 3).

Note que $A$ só se torna $NULLABLE$ após várias iterações: primeiro identificamos $C$, $D$ e $E$, depois $B$, e finalmente $A$. Esta propagação em cascata é fundamental para o algoritmo.

Identificar quais símbolos são $NULLABLE$ é um passo preparatório fundamental. Essa informação é usada para determinar:

a.  Quando incluir $\varepsilon$ no conjunto $FIRST$ de um não-terminal;
b.  Quando o analisador deve "olhar através" de um símbolo em uma produção para calcular o $FIRST$ do que vem a seguir;
c.  Quando o conjunto $FOLLOW$ de um não-terminal deve herdar símbolos do $FOLLOW$ de outro, porque o símbolo que o sucede pode "desaparecer" (derivar em $\varepsilon$).

#### Regras de Criação do Conjunto NULLABLE

Para construir o conjunto de todos os símbolos não-terminais *NULLABLE* de uma gramática, aplicamos as seguintes regras de forma iterativa até que o conjunto não mude mais:

1. **Regra Base (Nulidade Direta):** Se existe uma produção da forma $A \rightarrow ε$, então $A$ é adicionado ao conjunto *NULLABLE*.
2. **Regra de Indução (Nulidade Indireta):** Se existe uma produção da forma $A \rightarrow Y₁Y₂...Yₙ$, e **todos** os símbolos $Y₁$, $Y₂$, ..., $Yₙ$ já foram identificados como *NULLABLE*, então $A$ também é adicionado ao conjunto.

#### Exemplo de Criação do Conjunto NULLABLE

Considere a seguinte gramática:

$$
\begin{array}{c}
S \rightarrow A B C \\
&A \rightarrow a | ε \\
&B \rightarrow C D \\
&C \rightarrow c | ε \\
&D \rightarrow A
\end{array}
$$

O processo de construção do conjunto *NULLABLE* seria:

1. **Iteração 1:** Analisando as regras diretas, encontramos `A \rightarrow ε` e `C \rightarrow ε`. *Conjunto Nullable = { A, C }*
2. **Iteração 2:** Agora, verificamos as outras regras com base no que já sabemos.
    - Na regra `D \rightarrow A`, como `A` está no conjunto, `D` também se torna *NULLABLE*.
    - Na regra `B \rightarrow C D`, agora sabemos que tanto `C` quanto `D` são *NULLABLE*. Portanto, `B` também se torna *NULLABLE*. *Conjunto Nullable = { A, C, D, B }*
3. **Iteração 3:** Revisitamos as regras com o conjunto atualizado.
    - Na regra `S \rightarrow A B C`, agora sabemos que `A`, `B` e `C` são todos *NULLABLE*. Portanto, `S` também se torna *NULLABLE*. *Conjunto Nullable = { A, C, D, B, S }*
4. **Iteração 4:** Nenhuma nova adição é feita ao conjunto. O algoritmo termina.

O conjunto final de símbolos *NULLABLE* para esta gramática é `{ S, A, B, C, D }`.

#### Algoritmo para Criação do Conjunto NULLABLE

O algoritmo abaixo assume que a gramática é representada por um dicionário, no qual cada chave é um não-terminal e o valor é uma lista de produções, sendo cada produção uma lista de símbolos.

``` pseudo
função calcular_NULLABLE(gramatica):
    // gramatica é um dicionário: { 'A': [['Y1', 'Y2'], ['ε']], ... }
    NULLABLE = conjunto vazio
    
    // 1. Regra Base: Adiciona não-terminais que derivam ε diretamente.
    para cada não-terminal A em gramatica:
        para cada produção P nas alternativas de A:
            se P é ['EPSILON']:
                adicionar A em NULLABLE

    // 2. Regra de Indução: Itera até que nenhuma nova adição seja feita.
    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        para cada não-terminal A em gramatica:
            se A não está em NULLABLE:
                para cada produção P = [Y1, Y2, ..., Yn] nas alternativas de A:
                    
                    // Verifica se todos os símbolos na produção P já são NULLABLE.
                    todos_simbolos_sao_nullable = verdadeiro
                    para cada simbolo Yk em P:
                        se Yk não está em NULLABLE:
                            todos_simbolos_sao_nullable = falso
                            quebrar // Interrompe a verificação desta produção
                    
                    // Se todos eram NULLABLE, então A também é.
                    se todos_simbolos_sao_nullable:
                        adicionar A em NULLABLE
                        mudou = verdadeiro
                        quebrar // Já sabemos que A é NULLABLE, podemos passar para o próximo não-terminal.
    
    retornar NULLABLE
```

Sobre este pseudocódigo podemos construir um código em Python. Porém, antes da esforçada leitora continuar de observar que ao transpor os conceitos teóricos para os algoritmos em Python, a representação muda de $\varepsilon$ para a string 'EPSILON'. É importante esclarecer que essa não é uma contradição, mas sim uma adaptação necessária para a implementação. O símbolo $\varepsilon$ é universalmente aceito na teoria de linguagens formais e compiladores para representar a cadeia vazia.

Na prática, em um programa de computador que manipula regras de produção como texto, é necessário ter um marcador explícito para a produção vazia. Usar uma string vazia de fato ('') poderia levar a ambiguidades no processamento do código. Portanto, vamos adotar a string 'EPSILON', para representar de forma inequívoca o conceito teórico de $\varepsilon$.

``` python
# Código 1: Cálculo do conjunto NULLABLE

def calcular_NULLABLE(gramatica: dict[str, list[list[str]]]) -> set[str]:
    """
    Calcula o conjunto de não-terminais que podem derivar a cadeia vazia (ε).

    Args:
        gramatica: Um dicionário representando a gramática.
                   Ex: {'S': [['A', 'B']], 'A': [['a'], ['EPSILON']]}

    Returns:
        Um conjunto contendo os não-terminais que são NULLABLE.
    """
    NULLABLE = set()
    
    # 1. Regra Base: Adiciona não-terminais com produções diretas para 'EPSILON'.
    for nao_terminal, producoes in gramatica.items():
        for producao in producoes:
            if producao == ['EPSILON']:
                NULLABLE.add(nao_terminal)

    # 2. Regra de Indução: Itera até não haver mais mudanças.
    mudou = True
    while mudou:
        mudou = False
        for nao_terminal, producoes in gramatica.items():
            if nao_terminal not in NULLABLE:
                for producao in producoes:
                    # Se a produção for vazia ou EPSILON, já foi tratada.
                    if not producao or producao == ['EPSILON']:
                        continue

                    # Verifica se todos os símbolos da produção são NULLABLE.
                    todos_sao_nullable = all(simbolo in NULLABLE for simbolo in producao)
                    
                    if todos_sao_nullable:
                        NULLABLE.add(nao_terminal)
                        mudou = True
                        # Otimização: Se A se tornou NULLABLE por uma de suas produções,
                        # podemos parar de verificar as outras produções de A nesta iteração.
                        break 
    
    return NULLABLE

# Exemplo de uso com a estrutura de dados robusta
gramatica_exemplo = {
    'S': [['A', 'B', 'C']],
    'A': [['a'], ['EPSILON']],
    'B': [['C', 'D']],
    'C': [['c'], ['EPSILON']],
    'D': [['A']]
}

nullable_set = calcular_NULLABLE(gramatica_exemplo)
print(f"Conjunto NULLABLE: {sorted(list(nullable_set))}")
# Saída esperada: Conjunto NULLABLE: ['A', 'B', 'C', 'D', 'S']
```

### O Conjunto FIRST

O conjunto $FIRST$ de um símbolo não-terminal é o conjunto de todos os terminais que podem aparecer no início de qualquer *string* derivada desse símbolo, incluindo o símbolo vazio ($\varepsilon$) se o não-terminal for *NULLABLE*. Para os símbolos terminais, o elemento do conjunto $FIRST$ será o próprio símbolo terminal.

#### Regras de Criação do Conjunto FIRST

Para definir o conjunto $FIRST(X)$ para todos os símbolos $X$ de uma gramática, assumindo que o conjunto $NULLABLE$ já foi previamente calculado, podemos seguir os seguintes passos de forma iterativa:

1. **Para símbolos terminais**: o conjunto $FIRST$ é o próprio símbolo terminal. Ou seja, se $a$ é um terminal, então $FIRST(a) = \{a\}$.

2. **Para um símbolo não-terminal** $X$: olhe para cada regra de produção $X \rightarrow Y_1 Y_2 ... Y_n$ e siga as seguintes regras:

    - Adicione a $FIRST(X)$ todos os símbolos de $FIRST(Y_1)$, exceto $\varepsilon$.
    - Se $Y_1$ é *NULLABLE*, adicione a $FIRST(X)$ todos os símbolos de $FIRST(Y_2)$, exceto $\varepsilon$.
    - Continue este processo: se todos os símbolos de $Y_1$ até $Y_{k-1}$ são *NULLABLE*, adicione a $FIRST(X)$ todos os símbolos de $FIRST(Y_k)$, exceto $\varepsilon$. O processo para no primeiro símbolo $Y_k$ que não for *NULLABLE*.

**O símbolo vazio** $\varepsilon$ pertence ao conjunto $FIRST(X)$ se, e somente se, $X$ pertence ao conjunto $NULLABLE$.

Repita esses passos até que os conjuntos $FIRST$ de todos os símbolos não-terminais não possam ser alterados.

#### Exemplo 1: Criação de Conjuntos FIRST

Para ilustrar a aplicação destas regras e a importância do conjunto $NULLABLE$, considere a gramática definida pelo seguinte conjunto de regras de produção:

$$
\begin{array}{ll}
1. & S \rightarrow A B \\
2. & A \rightarrow a \mid \varepsilon \\
3. & B \rightarrow b \\
\end{array}
$$

Primeiro, identificamos o conjunto $NULLABLE$ para esta gramática. Pela regra $A \rightarrow \varepsilon$, concluímos que $NULLABLE = \{A\}$.

Com base nisso, o conjunto de regras de produção permite criar a seguinte tabela:

| Símbolo | FIRST                | Explicação                                                                                                                                                                                                                                                                                                   |
|:-----------------------|:-----------------------|:-----------------------|
| **A**   | $\{a, \varepsilon\}$ | Da produção $A \rightarrow a$, adicionamos 'a'. Como $A$ é *NULLABLE*, adicionamos $\varepsilon$.                                                                                                                                                                                                            |
| **B**   | $\{b\}$              | Da produção $B \rightarrow b$, o único terminal que pode iniciar a derivação é 'b'.                                                                                                                                                                                                                          |
| **S**   | $\{a, b\}$           | Para a produção $S \rightarrow A B$: <br> 1. Analisamos $A$ e adicionamos $FIRST(A) - \{\varepsilon\}$, que resulta em $\{a\}$. <br> 2. Como $A$ é *NULLABLE*, continuamos a análise para o próximo símbolo, $B$. <br> 3. Adicionamos $FIRST(B)$, que é $\{b\}$. Como $B$ não é *NULLABLE*, o processo para. |

Logo: $FIRST =\{(S,\{a, b\}),(A,\{a, \varepsilon\}),(B,\{b\})\}}$, um conjunto de tuplas.

Agora que entendemos o algoritmo e sua dependência do conjunto $NULLABLE$, podemos formalizá-lo.

#### Algoritmo para calcular o conjunto FIRST

``` pseudo
#### Algoritmo para calcular o conjunto FIRST (Revisado)

função calcular_FIRST(gramatica, NULLABLE):
    // gramatica é um dicionário, NULLABLE é um conjunto
    FIRST = {}
    para cada não-terminal N em gramatica:
        FIRST[N] = conjunto vazio
    
    // Adiciona ε ao FIRST de todos os não-terminais que são NULLABLE.
    para cada N em NULLABLE:
        adicionar 'EPSILON' em FIRST[N]

    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        para cada não-terminal A em gramatica:
            para cada produção P = [Y1, Y2, ..., Yn] nas alternativas de A:
                para cada simbolo Yk em P:
                    // Se Yk é um terminal
                    se Yk não é um não-terminal:
                        se Yk não está em FIRST[A]:
                            adicionar Yk em FIRST[A]
                            mudou = verdadeiro
                        quebrar // Para a análise desta produção
                    
                    // Se Yk é um não-terminal
                    else:
                        // Adiciona FIRST[Yk] - {ε} ao FIRST[A]
                        tamanho_anterior = tamanho(FIRST[A])
                        FIRST[A] = união(FIRST[A], FIRST[Yk] - {'EPSILON'})
                        se tamanho(FIRST[A]) > tamanho_anterior:
                            mudou = verdadeiro
                        
                        // Se Yk não é NULLABLE, para a análise desta produção
                        se Yk não está em NULLABLE:
                            quebrar
    retornar FIRST
```

Código em Python para $FIRST$

``` python
# Código 2: Cálculo do conjunto FIRST   
def calcular_FIRST(gramatica: dict, nao_terminais: set, NULLABLE: set) -> dict:
    """
    Calcula o conjunto FIRST para todos os não-terminais, usando a estrutura de dicionário.
    """
    FIRST = {nt: set() for nt in nao_terminais}
    
    for nt in NULLABLE:
        FIRST[nt].add('EPSILON')
    
    mudou = True
    while mudou:
        mudou = False
        for nt_head, producoes in gramatica.items():
            for producao in producoes:
                for simbolo in producao:
                    if simbolo == 'EPSILON':
                        continue

                    # Se o símbolo é um terminal
                    if simbolo not in nao_terminais:
                        if simbolo not in FIRST[nt_head]:
                            FIRST[nt_head].add(simbolo)
                            mudou = True
                        break  # interrompe a análise aqui
                    
                    # Se o símbolo é um não-terminal
                    else:
                        tamanho_anterior = len(FIRST[nt_head])
                        FIRST[nt_head].update(FIRST[simbolo] - {'EPSILON'})
                        if len(FIRST[nt_head]) > tamanho_anterior:
                            mudou = True
                        
                        if simbolo not in NULLABLE:
                            break  # interrompe a análise aqui
    return FIRST
```

### O Conjunto FOLLOW

O conjunto $FOLLOW$ de um símbolo não-terminal é o conjunto de terminais que podem aparecer imediatamente à direita (após, *follow*) desse não-terminal em alguma forma sentencial derivada, **ou o símbolo de fim de entrada (\$) se o não-terminal puder aparecer no final de uma forma sentencial**.

Para definir o conjunto $FOLLOW(A)$ para cada não-terminal $A$, assumindo que os conjuntos $NULLABLE$ e $FIRST$ já foram calculados, aplicamos as seguintes regras de forma iterativa até que os conjuntos $FOLLOW$ não mudem mais:

1. **Regra do Símbolo Inicial**: Coloque o símbolo de fim de entrada (\$\$\$) no conjunto $FOLLOW$ do símbolo inicial da gramática.

2. **Regra das Produções**: Para cada produção da forma $A \rightarrow \alpha B \beta$ na gramática, na qual $B$ é um não-terminal e $\alpha$ e $\beta$ são sequências de símbolos quaisquer:

    a.  Adicione todos os símbolos do conjunto $FIRST(\beta)$ ao conjunto $FOLLOW(B)$, exceto por $\varepsilon$.
    b.  Se a sequência $\beta$ for *NULLABLE* (ou seja, todos os símbolos em $\beta$ pertencem ao conjunto $NULLABLE$) ou se $\beta$ for vazia, então adicione todos os símbolos do conjunto $FOLLOW(A)$ ao conjunto $FOLLOW(B)$.

A longa explicação para a primeira regra é que, ao colocar o símbolo de fim de entrada (\$) no $FOLLOW$ do símbolo inicial da gramática, garantimos que o analisador sintático reconheça a última derivação da gramática como válida. Isso significa que o analisador estará preparado para encontrar o símbolo ($) ao final da string de entrada, indicando que a análise foi concluída com sucesso. Em outras palavras, o símbolo ($) no $FOLLOW$ do símbolo inicial representa a expectativa de que a string de entrada seja completamente processada e que não existam símbolos após a última derivada.

**Exemplo**: Para ilustrar todas as regras, incluindo a interação com os conjuntos $FIRST$ e $NULLABLE$, vamos usar uma nova gramática:

$$
\begin{array}{ll}
1. & S \rightarrow A B C \\
2. & A \rightarrow a \\
3. & B \rightarrow b \mid \varepsilon \\
4. & C \rightarrow c
\end{array}
$$

**Conjuntos Prévios**:

- $NULLABLE$: Apenas $B$ é *NULLABLE* devido à produção $B \rightarrow \varepsilon$. Logo, $NULLABLE = \{B\}$.
- $FIRST$:
    - $FIRST(A) = \{a\}$
    - $FIRST(B) = \{b, \varepsilon\}$
    - $FIRST(C) = \{c\}$
    - $FIRST(S) = \{a\}$ (Pois $FIRST(A)$ é $\{a\}$ e $A$ não é *NULLABLE*)

**Cálculo do Conjunto FOLLOW**:

Vamos aplicar as regras passo a passo:

1. **Inicialização**: Pela Regra 1, adicionamos \$\$\$ ao $FOLLOW$ do símbolo inicial, $S$.

    - $FOLLOW(S) = \{$}\$

2. **Análise da Produção** $S \rightarrow A B C$:

    a.  **Para** $FOLLOW(A)$: O não-terminal $A$ é seguido pela sequência $\beta = BC$.

    - Adicionamos $FIRST(BC)$ a $FOLLOW(A)$. Para encontrar $FIRST(BC)$, olhamos $FIRST(B)$, que é $\{b, \varepsilon\}$. Adicionamos 'b'. Como $B$ é *NULLABLE*, olhamos para o próximo símbolo, $C$, e adicionamos $FIRST(C)$, que é $\{c\}$.
    - Portanto, $FIRST(BC) = \{b, c\}$. Adicionamos isso a $FOLLOW(A)$.
    - $FOLLOW(A) = \{b, c\}$

    b.  **Para** $FOLLOW(B)$: O não-terminal $B$ é seguido pela sequência $\beta = C$.

    - Adicionamos $FIRST(C)$ a $FOLLOW(B)$. $FIRST(C)$ é $\{c\}$.
    - A sequência $C$ não é *NULLABLE*, então não aplicamos a segunda parte da regra.
    - $FOLLOW(B) = \{c\}$

    c.  **Para** $FOLLOW(C)$: O não-terminal $C$ está no final da produção, então a sequência $\beta$ é vazia.

    - Como $\beta$ é vazia, adicionamos $FOLLOW(S)$ a $FOLLOW(C)$.
    - $FOLLOW(C) = \{$}\$

O conjunto resultante será:

| Símbolo | FOLLOW       | Explicação                                                                       |
|:-----------------------|:-----------------------|:-----------------------|
| **S**   | \${ \$ }\$   | É o símbolo inicial (Regra 1).                                                   |
| **A**   | $\{ b, c \}$ | É seguido por $BC$ na regra $S \rightarrow ABC$. $FOLLOW(A)$ recebe $FIRST(BC)$. |
| **B**   | $\{ c \}$    | É seguido por $C$ na regra $S \rightarrow ABC$. $FOLLOW(B)$ recebe $FIRST(C)$.   |
| **C**   | \${ \$ }\$   | Está no final da regra $S \rightarrow ABC$. $FOLLOW(C)$ herda $FOLLOW(S)$.       |

### Algoritmo para calcular o conjunto FOLLOW (Versão Revisada)

Com os conjuntos `NULLABLE` e `FIRST` em mãos, podemos finalmente calcular o conjunto `FOLLOW`. A seguir estão os pseudocódigos e a implementação final em Python, ambos utilizando a estrutura de dados de dicionário para manter a consistência.

#### Pseudocódigo da Função Auxiliar: `calcular_first_da_sequencia`

Para calcular `FOLLOW`, precisamos de uma função auxiliar que calcule o conjunto `FIRST` de uma sequência arbitrária de símbolos (ex: `FIRST(B C D)`), o que é um pouco diferente de calcular o `FIRST` de um único símbolo.

``` pseudo
### Algoritmo para calcular o conjunto FOLLOW (Versão Revisada)

Com os conjuntos `NULLABLE` e `FIRST` em mãos, podemos finalmente calcular o conjunto `FOLLOW`. A seguir estão os pseudocódigos e a implementação final em Python, ambos utilizando a estrutura de dados de dicionário para manter a consistência.

#### Pseudocódigo da Função Auxiliar: `calcular_first_da_sequencia`

Para calcular `FOLLOW`, precisamos de uma função auxiliar que calcule o conjunto `FIRST` de uma sequência arbitrária de símbolos (ex: `FIRST(B C D)`), o que é um pouco diferente de calcular o `FIRST` de um único símbolo.

```pseudo
função calcular_first_da_sequencia(sequencia, FIRST, NULLABLE, nao_terminais):
    // sequencia é uma lista de símbolos, ex: ['B', 'C']
    first_da_sequencia = conjunto vazio

    para cada simbolo S na sequencia:
        // Se S é um terminal, adiciona-o e para.
        se S não está em nao_terminais:
            adicionar S em first_da_sequencia
            retornar first_da_sequencia // Fim da análise para esta sequência

        // Se S é um não-terminal, adiciona seu FIRST (sem EPSILON)
        adicionar (FIRST[S] - {'EPSILON'}) em first_da_sequencia

        // Se S não pode ser vazio, a análise da sequência para aqui.
        se S não está em NULLABLE:
            retornar first_da_sequencia

    // Se o loop terminou, é porque todos os símbolos da sequência são NULLABLE.
    // Portanto, a própria sequência pode ser vazia.
    adicionar 'EPSILON' em first_da_sequencia
    retornar first_da_sequencia

função calcular_FOLLOW(gramatica, simbolo_inicial, nao_terminais, FIRST, NULLABLE):
    FOLLOW = {}
    para cada N em nao_terminais:
        FOLLOW[N] = conjunto vazio
    
    // Regra 1: Adiciona $ ao FOLLOW do símbolo inicial.
    adicionar '$' em FOLLOW[simbolo_inicial]

    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        // Itera sobre cada produção da gramática
        para cada não-terminal A e suas produções em gramatica:
            para cada produção P = [Y1, Y2, ..., Yn]:
                // Itera sobre cada símbolo da produção
                para i de 0 até tamanho(P) - 1:
                    B = P[i]
                    se B é um não-terminal:
                        beta = o restante da produção após B, ou seja, P[i+1:]
                        
                        // Regra 2.a: Adicionar FIRST(beta) a FOLLOW(B)
                        se beta não é vazio:
                            first_beta = calcular_first_da_sequencia(beta, ...)
                            
                            tamanho_anterior = tamanho(FOLLOW[B])
                            adicionar (first_beta - {'EPSILON'}) em FOLLOW[B]
                            se tamanho(FOLLOW[B]) > tamanho_anterior:
                                mudou = verdadeiro

                            // Regra 2.b: Se beta pode ser vazio, adicionar FOLLOW(A) a FOLLOW(B)
                            se 'EPSILON' está em first_beta:
                                tamanho_anterior = tamanho(FOLLOW[B])
                                adicionar FOLLOW[A] em FOLLOW[B]
                                se tamanho(FOLLOW[B]) > tamanho_anterior:
                                    mudou = verdadeiro
                        
                        // Regra 2.b (caso alternativo): Se não há nada após B
                        senão:
                            tamanho_anterior = tamanho(FOLLOW[B])
                            adicionar FOLLOW[A] em FOLLOW[B]
                            se tamanho(FOLLOW[B]) > tamanho_anterior:
                                mudou = verdadeiro
    
    retornar FOLLOW
```

Em Python, teremos:

``` python
# Código 3: Cálculo do conjunto FOLLOW 

def calcular_first_da_sequencia(
    sequencia: list[str],
    FIRST: dict[str, set],
    NULLABLE: set[str],
    nao_terminais: set[str]
) -> set[str]:
    """
    Calcula o conjunto FIRST de uma sequência de símbolos.
    """
    first_seq = set()
    
    for simbolo in sequencia:
        if simbolo not in nao_terminais:  # É terminal
            first_seq.add(simbolo)
            return first_seq
        else:  # É não-terminal
            first_seq.update(FIRST[simbolo] - {'EPSILON'})
            if simbolo not in NULLABLE:
                return first_seq
    
    # Se o loop terminou, todos os símbolos da sequência são NULLABLE.
    first_seq.add('EPSILON')
    return first_seq


def calcular_FOLLOW(
    gramatica: dict[str, list[list[str]]],
    simbolo_inicial: str,
    nao_terminais: set[str],
    FIRST: dict[str, set],
    NULLABLE: set[str]
) -> dict[str, set]:
    """
    Calcula o conjunto FOLLOW para todos os não-terminais, usando a estrutura de dicionário.
    """
    FOLLOW = {nt: set() for nt in nao_terminais}
    FOLLOW[simbolo_inicial].add('$')
    
    mudou = True
    while mudou:
        mudou = False
        for nt_head, producoes in gramatica.items():
            for producao in producoes:
                for i, simbolo in enumerate(producao):
                    if simbolo in nao_terminais:
                        beta = producao[i+1:]
                        
                        # Regra 2.a: Adicionar FIRST(beta) a FOLLOW(simbolo)
                        if beta:
                            first_beta = calcular_first_da_sequencia(beta, FIRST, NULLABLE, nao_terminais)
                            
                            tamanho_anterior = len(FOLLOW[simbolo])
                            FOLLOW[simbolo].update(first_beta - {'EPSILON'})
                            if len(FOLLOW[simbolo]) > tamanho_anterior:
                                mudou = True
                            
                            # Regra 2.b: Se beta é NULLABLE, adicionar FOLLOW(head) a FOLLOW(simbolo)
                            if 'EPSILON' in first_beta:
                                tamanho_anterior = len(FOLLOW[simbolo])
                                FOLLOW[simbolo].update(FOLLOW[nt_head])
                                if len(FOLLOW[simbolo]) > tamanho_anterior:
                                    mudou = True
                        
                        # Regra 2.b (caso beta seja vazio): Adicionar FOLLOW(head) a FOLLOW(simbolo)
                        else:
                            tamanho_anterior = len(FOLLOW[simbolo])
                            FOLLOW[simbolo].update(FOLLOW[nt_head])
                            if len(FOLLOW[simbolo]) > tamanho_anterior:
                                mudou = True
    return FOLLOW
```

### Aplicando as Regras: Um Primeiro Exemplo

Para solidificar o entendimento, vamos aplicar as regras de construção em uma gramática simples e ideal, antes de partirmos para casos mais complexos.

**Exemplo 1**: Considere a gramática definida pelo seguinte conjunto de regras de produção:

$$
\begin{array}{cc}
1. & S \rightarrow aB \mid bA \\
2. & A \rightarrow c \mid d \\
3. & B \rightarrow e \mid f \\
\end{array}
$$

A partir deste conjunto de regras, como não há produções vazias, o cálculo dos conjuntos é direto.

**1. Conjunto** $FIRST$:

- $FIRST(S) = \{a, b\}$
- $FIRST(A) = \{c, d\}$
- $FIRST(B) = \{e, f\}$

**2. Conjunto** $FOLLOW$:

- $FOLLOW(S) = \{\$\}$ (Símbolo inicial)
- $FOLLOW(A) = \{\$\}$ (Pois em $S \rightarrow bA$, A herda o $FOLLOW(S)$)
- $FOLLOW(B) = \{\$\}$ (Pois em $S \rightarrow aB$, B herda o $FOLLOW(S)$)

**3. Construindo a Tabela**: Como nenhuma produção deriva em $\varepsilon$, apenas a **Regra 1 (Regra do `FIRST`)** será utilizada:

- Para $S \rightarrow aB$: Como $a$ está em $FIRST(aB)$, adicionamos $S \rightarrow aB$ em `Tabela[S, a]`.
- Para $S \rightarrow bA$: Como $b$ está em $FIRST(bA)$, adicionamos $S \rightarrow bA$ em `Tabela[S, b]`.
- Para $A \rightarrow c$: Como $c$ está em $FIRST(c)$, adicionamos $A \rightarrow c$ em `Tabela[A, c]`.
- Para $A \rightarrow d$: Como $d$ está em $FIRST(d)$, adicionamos $A \rightarrow d$ em `Tabela[A, d]`.
- Para $B \rightarrow e$: Como $e$ está em $FIRST(e)$, adicionamos $B \rightarrow e$ em `Tabela[B, e]`.
- Para $B \rightarrow f$: Como $f$ está em $FIRST(f)$, adicionamos $B \rightarrow f$ em `Tabela[B, f]`.

A Tabela de Derivação resultante é:

| Não-Terminal | **a**      | **b**      | **c**     | **d**     | **e**     | **f**     | **\$** |
|:-------------|:-----------|:-----------|:----------|:----------|:----------|:----------|:-------|
| **S**        | $S \rightarrow aB$ | $S \rightarrow bA$ |           |           |           |           |        |
| **A**        |            |            | $A \rightarrow c$ | $A \rightarrow d$ |           |           |        |
| **B**        |            |            |           |           | $B \rightarrow e$ | $B \rightarrow f$ |        |

Este exemplo é perfeito: para cada par (não-terminal, terminal) existe no máximo uma regra de produção. Infelizmente, quando estamos construindo linguagens livres de contexto para problemas reais, este não é o cenário mais comum, como veremos a seguir.

## O Exemplo Mais Comum de Todos

O exemplo a seguir está em todos os sites, livros e aulas que eu já vi disponíveis na internet. É tão comum que não me dei ao trabalho de procurar sua origem. Meu instinto me diz que deve ser do [livro do Aho](https://amzn.to/4celnGt), mas não fui conferir. É um exemplo tão bom que deve ser do Aho. Enfim, vamos ao trabalho:

### Gramática Original

Considere a gramática representada pelo conjunto de regras de produção a seguir:

$$
\begin{array}{ll}
1. & S \rightarrow E \\
2. & E \rightarrow E + T \mid T \\
3. & T \rightarrow T * F \mid F \\
4. & F \rightarrow (E) \mid id
\end{array}
$$

Antes de prosseguir, é fundamental que a atenta leitora note que existe um problema grave com a gramática acima: ela possui **recursão à esquerda direta** nas regras para os não-terminais $E$ e $T$. Como vimos anteriormente, um *parser* $LL(1)$ não consegue lidar com esse tipo de regra, pois entraria em um laço infinito.

Para que possamos construir uma Tabela de Derivação $LL(1)$, precisamos primeiro eliminar essa recursão. Faremos isso aplicando a técnica padrão de transformação.

**1. Eliminando a recursão em** $E \rightarrow E + T \mid T$:

- A regra está no formato $A \rightarrow A\alpha \mid \beta$, na qual $A=E$, $\alpha = +T$ e $\beta = T$.
- A transformamos em $A \rightarrow \beta A'$ e $A' \rightarrow \alpha A' \mid \varepsilon$.
- As novas regras são:
    - $E \rightarrow T E'$
    - $E' \rightarrow + T E' \mid \varepsilon$

**2. Eliminando a recursão em** $T \rightarrow T * F \mid F$:

- A regra está no formato $A \rightarrow A\alpha \mid \beta$, na qual $A=T$, $\alpha = *F$ e $\beta = F$.
- A transformamos em $A \rightarrow \beta A'$ e $A' \rightarrow \alpha A' \mid \varepsilon$.
- As novas regras são:
    - $T \rightarrow F T'$
    - $T' \rightarrow * F T' \mid \varepsilon$

Após as transformações, a gramática equivalente e adequada para a análise $LL(1)$ é:

$$
\begin{array}{ll}
1. & S \rightarrow E \\
2. & E \rightarrow T E' \\
3. & E' \rightarrow + T E' \mid \varepsilon \\
4. & T \rightarrow F T' \\
5. & T' \rightarrow * F T' \mid \varepsilon \\
6. & F \rightarrow (E) \mid id
\end{array}
$$

Com esta gramática correta, podemos agora calcular os conjuntos necessários.

### $NULLABLE$

Analisando a nova gramática, identificamos quais não-terminais podem derivar a cadeia vazia ($\varepsilon$).

- $E' \rightarrow \varepsilon$, portanto $E'$ é *NULLABLE*.
- $T' \rightarrow \varepsilon$, portanto $T'$ é *NULLABLE*.
- $S, E, T, F$ não podem derivar $\varepsilon$ diretamente e suas produções sempre contêm símbolos que não são *NULLABLE*, então eles não são *NULLABLE*.

### $FIRST$

Vamos calcular o conjunto $FIRST$ para cada não-terminal da gramática corrigida.

- $FIRST(F)$: A partir de $F \rightarrow (E) \mid id$, os primeiros terminais possíveis são `(` e `id`.
  - $FIRST(F) = \{ '(', id \}$
- $FIRST(T')$: A partir de $T' \rightarrow * F T' \mid \varepsilon$, os primeiros símbolos são `*` ou a cadeia vazia.
  - $FIRST(T') = \{ '*', \varepsilon \}$
- $FIRST(T)$: A regra é $T \rightarrow F T'$. O $FIRST(T)$ é igual ao $FIRST(F)$.
  - $FIRST(T) = FIRST(F) = \{ '(', id \}$
- $FIRST(E')$: A partir de $E' \rightarrow + T E' \mid \varepsilon$, os primeiros símbolos são `+` ou a cadeia vazia.
  - $FIRST(E') = \{ '+', \varepsilon \}$
- $FIRST(E)$: A regra é $E \rightarrow T E'$. O $FIRST(E)$ é igual ao $FIRST(T)$.
  - $FIRST(E) = FIRST(T) = \{ '(', id \}$
- $FIRST(S)$: A regra é $S \rightarrow E$. O $FIRST(S)$ é igual ao $FIRST(E)$.
  - $FIRST(S) = FIRST(E) = \{ '(', id \}$

### $FOLLOW$

Agora, calculamos o conjunto $FOLLOW$ para cada não-terminal.

- $FOLLOW(S)$: $S$ é o símbolo inicial, então iniciamos com o marcador de fim de entrada.
  - \$FOLLOW(S) = { \$ }\$
- $FOLLOW(E)$:
  - Da regra $S \rightarrow E$, $E$ está no final, então $FOLLOW(E)$ herda $FOLLOW(S)$. \$FOLLOW(E) = { \$ }\$.
  - Da regra $F \rightarrow (E)$, o símbolo `)` segue $E$. Adicionamos `)` ao $FOLLOW(E)$.
  - \$FOLLOW(E) = { $, ')' \}$
- $FOLLOW(E')$: Da regra $E \rightarrow T E'$, $E'$ está no final, então $FOLLOW(E')$ herda $FOLLOW(E)$.
  - \$FOLLOW(E') = FOLLOW(E) = { $, ')' \}$
- $FOLLOW(T)$:
  - Da regra $E \rightarrow T E'$, $T$ é seguido por $E'$. Adicionamos $FIRST(E') - \{\varepsilon\}$ ao $FOLLOW(T)$. Isso adiciona `+`.
  - Como $E'$ é *NULLABLE*, também adicionamos $FOLLOW(E)$ ao $FOLLOW(T)$.
  - \$FOLLOW(T) = { '+' } \cup { \$, ')' } = { '+', $, ')' \}$
- $FOLLOW(T')$: Da regra $T \rightarrow F T'$, $T'$ está no final, então $FOLLOW(T')$ herda $FOLLOW(T)$.
  - \$FOLLOW(T') = FOLLOW(T) = { '+', $, ')' \}$
- - $FOLLOW(F)$:
    - Analisamos todas as regras em que $F$ aparece no lado direito. A única regra relevante é $T \rightarrow F T'$.
    - **Passo 1**: O não-terminal $F$ é seguido pela sequência $T'$. Aplicamos a regra que diz para adicionar $FIRST(T') - \{\varepsilon\}$ ao conjunto $FOLLOW(F)$.
      - Sabemos que $FIRST(T') = \{ '*', \varepsilon \}$.
      - Portanto, adicionamos $\{ * \}$ ao $FOLLOW(F)$.
    - **Passo 2**: Como a sequência que segue $F$ (neste caso, $T'$) é *NULLABLE*, devemos também adicionar o conjunto $FOLLOW$ do não-terminal que está à esquerda da produção, ou seja, $FOLLOW(T)$, ao conjunto $FOLLOW(F)$.
      - Sabemos que $FOLLOW(T) = \{ '+', \$, ')' \}$.
    - **Passo 3**: O conjunto final para $FOLLOW(F)$ é a união dos resultados dos passos anteriores.
      - $FOLLOW(F) = (FIRST(T') - \{\varepsilon\}) \cup FOLLOW(T)$
      - $FOLLOW(F) = \{ * \} \cup \{ '+', \$, ')' \}$
      - $FOLLOW(F) = \{ '*', '+', \$, ')' \}$

### Tabela de Derivação $LL(1)$

Com os conjuntos $FIRST$ e $FOLLOW$ corretos, podemos construir a Tabela de Derivação. A construção da tabela segue um algoritmo preciso com duas regras principais, que utilizam os conjuntos que acabamos de calcular para preencher as células `Tabela[Não-Terminal, Terminal]`:

1. **Regra do** $FIRST$: Para cada produção da gramática, na forma $A \rightarrow \alpha$: para cada símbolo terminal **t** que pertence a $FIRST(\alpha)$, adicione a produção $A \rightarrow \alpha$ na célula `Tabela[A, t]`.

2. **Regra do** $FOLLOW$: Se $\varepsilon$ (a cadeia vazia) pertence a $FIRST(\alpha)$: para cada símbolo terminal **t** (incluindo o marcador **\$**) que pertence a $FOLLOW(A)$, adicione a produção $A \rightarrow \alpha$ na célula `Tabela[A, t]`.

Qualquer célula que permaneça vazia após a aplicação destas regras representará um erro sintático, indicando que a ocorrência daquele terminal é inesperada naquele ponto da análise. Assim, temos:

| Não-Terminal | **id**               | **+**                        | **\***                  | **(**                | **)**                        | **\$**                       |
|:----------|:----------|:----------|:----------|:----------|:----------|:----------|
| **S**        | $S \rightarrow E$    |                              |                         | $S \rightarrow E$    |                              |                              |
| **E**        | $E \rightarrow T E'$ |                              |                         | $E \rightarrow T E'$ |                              |                              |
| **E'**       |                      | $E' \rightarrow + T E'$      |                         |                      | $E' \rightarrow \varepsilon$ | $E' \rightarrow \varepsilon$ |
| **T**        | $T \rightarrow F T'$ |                              |                         | $T \rightarrow F T'$ |                              |                              |
| **T'**       |                      | $T' \rightarrow \varepsilon$ | $T' \rightarrow * F T'$ |                      | $T' \rightarrow \varepsilon$ | $T' \rightarrow \varepsilon$ |
| **F**        | $F \rightarrow id$   |                              |                         | $F \rightarrow (E)$  |                              |                              |

### Processo de Parser Testando com $id + id * id$

Vamos agora rastrear a análise da *string* `id + id * id` usando a pilha, a entrada e a Tabela de Derivação corrigida em relação ao apontamento feito. A inconsistência estava no passo `T(T', +)`, no qual a tabela indica `T' -> ε` (o que é o correto, pois `+` pertence ao `FOLLOW(T')`), e o rastreamento anterior poderia gerar dúvida. O rastreamento correto é o seguinte.

**Notação utilizada no rastreamento:**

- `T(X, a)` significa "consultar a Tabela de Derivação na linha do não-terminal X e coluna do terminal a";
- Por exemplo, `T(S, id)` significa consultar a tabela na linha S, coluna id;
- O resultado da consulta indica qual produção deve ser aplicada;
- "Consumir" significa remover o símbolo tanto do topo da pilha quanto do início da entrada.

| Pilha         | Entrada          | Ação                                    |
|:--------------|:-----------------|:----------------------------------------|
| `S $`         | `id + id * id $` | `T(S, id)` $\rightarrow$ `S -> E`       |
| `E $`         | `id + id * id $` | `T(E, id)` $\rightarrow$ `E -> T E'`    |
| `T E' $`      | `id + id * id $` | `T(T, id)` $\rightarrow$ `T -> F T'`    |
| `F T' E' $`   | `id + id * id $` | `T(F, id)` $\rightarrow$ `F -> id`      |
| `id T' E' $`  | `id + id * id $` | Consumir `id`                           |
| `T' E' $`     | `+ id * id $`    | `T(T', +)` $\rightarrow$ `T' -> ε`      |
| `E' $`        | `+ id * id $`    | `T(E', +)` $\rightarrow$ `E' -> + T E'` |
| `+ T E' $`    | `+ id * id $`    | Consumir `+`                            |
| `T E' $`      | `id * id $`      | `T(T, id)` $\rightarrow$ `T -> F T'`    |
| `F T' E' $`   | `id * id $`      | `T(F, id)` $\rightarrow$ `F -> id`      |
| `id T' E' $`  | `id * id $`      | Consumir `id`                           |
| `T' E' $`     | `* id $`         | `T(T', *)` $\rightarrow$ `T' -> * F T'` |
| `* F T' E' $` | `* id $`         | Consumir `*`                            |
| `F T' E' $`   | `id $`           | `T(F, id)` $\rightarrow$ `F -> id`      |
| `id T' E' $`  | `id $`           | Consumir `id`                           |
| `T' E' $`     | `$`              | `T(T', $)` $\rightarrow$ `T' -> ε`      |
| `E' $`        | `$`              | `T(E', $)` $\rightarrow$ `E' -> ε`      |
| `$`           | `$`              | **Aceita**                              |

Como foi possível consumir toda a *string* e esvaziar a pilha, a *string* `id + id * id` é aceita pela gramática.

### Testando com a *string* $id - id * id$

Vamos analisar a *string* `id - id * id`. O processo inicial é o mesmo do exemplo anterior.

| Pilha        | Entrada          | Ação                                          |
|:-----------------------|:-----------------------|:-----------------------|
| `S $`        | `id - id * id $` | `T(S, id)` $\rightarrow$ `S \rightarrow E`    |
| `E $`        | `id - id * id $` | `T(E, id)` $\rightarrow$ `E \rightarrow T E'` |
| `T E' $`     | `id - id * id $` | `T(T, id)` $\rightarrow$ `T \rightarrow F T'` |
| `F T' E' $`  | `id - id * id $` | `T(F, id)` $\rightarrow$ `F \rightarrow id`   |
| `id T' E' $` | `id - id * id $` | Consumir `id`                                 |
| `T' E' $`    | `- id * id $`    | `T(T', -)` $\rightarrow$ **Erro**             |

A análise para. A célula da tabela para o não-terminal no topo da pilha (`T'`) e o símbolo de entrada (`-`) está vazia. Isso indica um erro sintático.

Portanto, a *string* `id - id * id` **não faz parte da linguagem definida pela gramática fornecida**. O que deveria ser óbvio, já que a gramática não tem regras para lidar com o símbolo `-`.

Vimos, com a mesma gramática, as duas situações possíveis: ou a *string* faz parte da linguagem, ou não. Simples assim.

## Um Exemplo Nem Tão Comum

Este exemplo saiu das vozes da minha cabeça. Pode ser que exista em algum outro lugar, mas não me dei ao trabalho de verificar. É um exemplo que uso há muitos anos, em aula e já nem me preocupo com ele. Se souber a origem, fico grato.

### Gramática Original

Considere a seguinte gramática para expressões booleanas ($OR, AND, NOT$), definida pelo conjunto de regras de produção a seguir:

$$
\begin{array}{ll}
1. & S \rightarrow B \\
2. & B \rightarrow B \,\, OR \,\, M \mid M \\
3. & M \rightarrow M \,\, AND \,\, N \mid N \\
4. & N \rightarrow NOT \,\, N \mid (B) \,\mid id
\end{array}
$$

### Corrigindo a Recursão à Esquerda

Assim como no exemplo anterior, esta gramática não é adequada para um *parser* $LL(1)$ por possuir **recursão à esquerda direta** nas regras dos não-terminais $B$ e $M$. Para prosseguir, precisamos primeiro eliminar essa recursão.

**1. Eliminando a recursão em** $B \rightarrow B \,\, OR \,\, M \mid M$:

- A regra tem o formato $A \rightarrow A\alpha \mid \beta$, na qual $A=B$, $\alpha = OR \,\, M$ e $\beta = M$.
- A transformamos nas novas regras:
    - $B \rightarrow M B'$;
    - $B' \rightarrow OR \,\, M B' \mid \varepsilon$.

**2. Eliminando a recursão em** $M \rightarrow M \,\, AND \,\, N \mid N$:

- A regra tem o formato $A \rightarrow A\alpha \mid \beta$, na qual $A=M$, $\alpha = AND \,\, N$ e $\beta = N$.
- A transformamos nas novas regras:
    - $M \rightarrow N M'$;
    - $M' \rightarrow AND \,\, N M' \mid \varepsilon$.

### Gramática Corrigida (Pronta para LL(1))

A gramática final, equivalente à original mas sem recursão à esquerda, é:

$$
\begin{array}{ll}
1. & S \rightarrow B \\
2. & B \rightarrow M B' \\
3. & B' \rightarrow OR \,\, M B' \mid \varepsilon \\
4. & M \rightarrow N M' \\
5. & M' \rightarrow AND \,\, N M' \mid \varepsilon \\
6. & N \rightarrow NOT \,\, N \\
7. & N \rightarrow (B) \\
8. & N \rightarrow id
\end{array}
$$

Com esta gramática corrigida, podemos prosseguir com os cálculos.

### $NULLABLE$

- $B' \rightarrow \varepsilon$, portanto $B'$ é *NULLABLE*.
- $M' \rightarrow \varepsilon$, portanto $M'$ é *NULLABLE*.
- Nenhum outro não-terminal pode derivar a cadeia vazia.

### $FIRST$

- $FIRST(N)$: A partir das regras de $N$, os primeiros terminais são `NOT`, `(` e `id`.
  - $FIRST(N) = \{ NOT, '(', id \}$
- $FIRST(M')$: A partir de $M' \rightarrow AND \,\, N M' \mid \varepsilon$.
  - $FIRST(M') = \{ AND, \varepsilon \}$
- $FIRST(M)$: A regra é $M \rightarrow N M'$. $FIRST(M) = FIRST(N)$.
  - $FIRST(M) = \{ NOT, '(', id \}$
- $FIRST(B')$: A partir de $B' \rightarrow OR \,\, M B' \mid \varepsilon$.
  - $FIRST(B') = \{ OR, \varepsilon \}$
- $FIRST(B)$: A regra é $B \rightarrow M B'$. $FIRST(B) = FIRST(M)$.
  - $FIRST(B) = \{ NOT, '(', id \}$
- $FIRST(S)$: A regra é $S \rightarrow B$. $FIRST(S) = FIRST(B)$.
  - $FIRST(S) = \{ NOT, '(', id \}$

### $FOLLOW$

- $FOLLOW(S)$: Símbolo inicial.
  - \$FOLLOW(S) = { \$ }\$
- $FOLLOW(B)$:
  - Da regra $S \rightarrow B$, $FOLLOW(B)$ herda $FOLLOW(S)$, então \$FOLLOW(B) = { \$ }\$.
  - Da regra $N \rightarrow (B)$, o símbolo `)` segue $B$.
  - \$FOLLOW(B) = { $, ')' \}$
- $FOLLOW(B')$: Da regra $B \rightarrow M B'$, $B'$ está no final, então $FOLLOW(B')$ herda $FOLLOW(B)$.
  - \$FOLLOW(B') = { $, ')' \}$
- $FOLLOW(M)$:
  - Da regra $B \rightarrow M B'$, $M$ é seguido por $B'$. Adicionamos $FIRST(B') - \{\varepsilon\}$ ao $FOLLOW(M)$, que é $\{ OR \}$.
  - Como $B'$ é *NULLABLE*, também adicionamos $FOLLOW(B)$ ao $FOLLOW(M)$.
  - \$FOLLOW(M) = { OR } \cup { \$, ')' } = { OR, $, ')' \}$
- $FOLLOW(M')$: Da regra $M \rightarrow N M'$, $M'$ está no final, então $FOLLOW(M')$ herda $FOLLOW(M)$.
  - \$FOLLOW(M') = { OR, $, ')' \}$
- $FOLLOW(N)$:
  - Da regra $M \rightarrow N M'$, $N$ é seguido por $M'$. Adicionamos $FIRST(M') - \{\varepsilon\}$ ao $FOLLOW(N)$, que é $\{ AND \}$.
  - Como $M'$ é *NULLABLE*, também adicionamos $FOLLOW(M)$ ao $FOLLOW(N)$.
  - \$FOLLOW(N) = { AND } \cup { OR, \$, ')' } = { AND, OR, $, ')' \}$

### Tabela de Derivação $LL(1)$

| Não-Terminal | **id**               | **OR**                        | **AND**                        | **NOT**                    | **(**                | **)**                        | **\$**                       |
|:--------|:--------|:--------|:--------|:--------|:--------|:--------|:--------|
| **S**        | $S \rightarrow B$    |                               |                                | $S \rightarrow B$          | $S \rightarrow B$    |                              |                              |
| **B**        | $B \rightarrow M B'$ |                               |                                | $B \rightarrow M B'$       | $B \rightarrow M B'$ |                              |                              |
| **B'**       |                      | $B' \rightarrow OR \,\, M B'$ |                                |                            |                      | $B' \rightarrow \varepsilon$ | $B' \rightarrow \varepsilon$ |
| **M**        | $M \rightarrow N M'$ |                               |                                | $M \rightarrow N M'$       | $M \rightarrow N M'$ |                              |                              |
| **M'**       |                      | $M' \rightarrow \varepsilon$  | $M' \rightarrow AND \,\, N M'$ |                            |                      | $M' \rightarrow \varepsilon$ | $M' \rightarrow \varepsilon$ |
| **N**        | $N \rightarrow id$   |                               |                                | $N \rightarrow NOT \,\, N$ | $N \rightarrow (B)$  |                              |                              |

### Testando com *id or not id and (id or id)*

Vamos rastrear a análise da *string* usando a Tabela de Derivação correta.

### Testando com `id or not id and (id or id)`

| Pilha                | Buffer                          | Ação                                                             |
|:-----------------------|:-----------------------|:-----------------------|
| `S $`                | `id or not id and (id or id) $` | `T(S, 'id')` $\rightarrow$ `$S \rightarrow B$`                   |
| `B $`                | `id or not id and (id or id) $` | `T(B, 'id')` $\rightarrow$ `$B \rightarrow M B'$`                |
| `M B' $`             | `id or not id and (id or id) $` | `T(M, 'id')` $\rightarrow$ `$M \rightarrow N M'$`                |
| `N M' B' $`          | `id or not id and (id or id) $` | `T(N, 'id')` $\rightarrow$ `$N \rightarrow \text{id}$`           |
| `id M' B' $`         | `id or not id and (id or id) $` | Consumir `id`                                                    |
| `M' B' $`            | `or not id and (id or id) $`    | `T(M', 'or')` $\rightarrow$ `$M' \rightarrow \varepsilon$`       |
| `B' $`               | `or not id and (id or id) $`    | `T(B', 'or')` $\rightarrow$ `$B' \rightarrow \text{or } M B'$`   |
| `or M B' $`          | `or not id and (id or id) $`    | Consumir `or`                                                    |
| `M B' $`             | `not id and (id or id) $`       | `T(M, 'not')` $\rightarrow$ `$M \rightarrow N M'$`               |
| `N M' B' $`          | `not id and (id or id) $`       | `T(N, 'not')` $\rightarrow$ `$N \rightarrow \text{not } N$`      |
| `not N M' B' $`      | `not id and (id or id) $`       | Consumir `not`                                                   |
| `N M' B' $`          | `id and (id or id) $`           | `T(N, 'id')` $\rightarrow$ `$N \rightarrow \text{id}$`           |
| `id M' B' $`         | `id and (id or id) $`           | Consumir `id`                                                    |
| `M' B' $`            | `and (id or id) $`              | `T(M', 'and')` $\rightarrow$ `$M' \rightarrow \text{and } N M'$` |
| `and N M' B' $`      | `and (id or id) $`              | Consumir `and`                                                   |
| `N M' B' $`          | `(id or id) $`                  | `T(N, '(')` $\rightarrow$ `$N \rightarrow (B)$`                  |
| `( B ) M' B' $`      | `(id or id) $`                  | Consumir `(`                                                     |
| `B ) M' B' $`        | `id or id) $`                   | `T(B, 'id')` $\rightarrow$ `$B \rightarrow M B'$`                |
| `M B' ) M' B' $`     | `id or id) $`                   | `T(M, 'id')` $\rightarrow$ `$M \rightarrow N M'$`                |
| `N M' B' ) M' B' $`  | `id or id) $`                   | `T(N, 'id')` $\rightarrow$ `$N \rightarrow \text{id}$`           |
| `id M' B' ) M' B' $` | `id or id) $`                   | Consumir `id`                                                    |
| `M' B' ) M' B' $`    | `or id) $`                      | `T(M', 'or')` $\rightarrow$ `$M' \rightarrow \varepsilon$`       |
| `B' ) M' B' $`       | `or id) $`                      | `T(B', 'or')` $\rightarrow$ `$B' \rightarrow \text{or } M B'$`   |
| `or M B' ) M' B' $`  | `or id) $`                      | Consumir `or`                                                    |
| `M B' ) M' B' $`     | `id) $`                         | `T(M, 'id')` $\rightarrow$ `$M \rightarrow N M'$`                |
| `N M' B' ) M' B' $`  | `id) $`                         | `T(N, 'id')` $\rightarrow$ `$N \rightarrow \text{id}$`           |
| `id M' B' ) M' B' $` | `id) $`                         | Consumir `id`                                                    |
| `M' B' ) M' B' $`    | `) $`                           | `T(M', ')')` $\rightarrow$ `$M' \rightarrow \varepsilon$`        |
| `B' ) M' B' $`       | `) $`                           | `T(B', ')')` $\rightarrow$ `$B' \rightarrow \varepsilon$`        |
| `) M' B' $`          | `) $`                           | Consumir `)`                                                     |
| `M' B' $`            | `$`                             | `T(M', '$')` $\rightarrow$ `$M' \rightarrow \varepsilon$`        |
| `B' $`               | `$`                             | `T(B', '$')` $\rightarrow$ `$B' \rightarrow \varepsilon$`        |
| `$`                  | `$`                             | **Aceita**                                                       |

Como foi possível consumir toda a *string* de entrada *id or not id and (id or id)* e esvaziar a pilha sem encontrar nenhum erro, a *string* *id or not id and (id or id)* é de fato parte da linguagem definida e pode ser identificada por um *parser* $LL(1)$.

## Conflitos na Tabela de Derivação

Conflitos na Tabela de Derivação $LL(1)$ ocorrem quando há mais de uma regra de produção associada a um mesmo par indicador (terminal, não-terminal). Esta ambiguidade significa que, ao encontrar esse par, o *parser* $LL(1)$ não conseguirá determinar, de forma única e inequívoca, qual regra deverá aplicar a um determinado símbolo de entrada, tornando a gramática ambígua e inadequada para uso com *parsers* $LL(1)$.

**Exemplo 1**: observe que gramática a seguir foi criada para criar um conflito na Tabela de Derivação. Antes de nos preocuparmos com os tipos de conflito, e como solucioná-los, vamos rever todo o processo de criação de uma Tabela de Derivação para entender o problema.

$$
\begin{aligned}
1. &\ E \rightarrow T + E \ \mid  \ T \\
2. &\ T \rightarrow int \ \mid  \ (E)
\end{aligned}
$$

### Conjunto FIRST

1. **Para o não-terminal E**:

    - $E \rightarrow T + E$: o primeiro símbolo é $T$. Portanto, incluímos $FIRST(T)$ em $FIRST(E)$.
    - $E \rightarrow T$: o primeiro símbolo é $T$. Portanto, incluímos $FIRST(T)$ em $FIRST(E)$.

2. **Para o não-terminal T**:

    - $T \rightarrow int$: o primeiro símbolo é $int$. Portanto, $FIRST(T)$ inclui $int$.
    - $T \rightarrow (E)$: o primeiro símbolo é $($. Portanto, $FIRST(T)$ inclui $($.

Assim, temos:

$$
\begin{aligned}
FIRST(T) &= \{ int, ( \} \\
FIRST(E) &= FIRST(T) = \{ int, ( \}
\end{aligned}
$$

### Conjunto FOLLOW

1. **Para o símbolo inicial E**:
    - $FOLLOW(E)$ inclui \$.
2. **Para as produções de E**:
    - $E \rightarrow T + E$:
        - o símbolo $T$ pode ser seguido por $+$, então $+$ está em $FOLLOW(T)$.
        - o símbolo $E$ é o último da produção, então $FOLLOW(E)$ inclui $FOLLOW(E)$.
    - $E \rightarrow T$: o símbolo $T$ é o último da produção, então $FOLLOW(T)$ inclui $FOLLOW(E)$.
3. **Para as produções de T**:
    - $T \rightarrow int$: $int$ é um terminal, não influencia $FOLLOW$.
    - $T \rightarrow (E)$: $E$ pode ser seguido por $)$, então $FOLLOW(E)$ inclui $)$.

Assim, teremos:

$$
\begin{aligned}
FOLLOW(E) &= \{ \$, ) \} \\
FOLLOW(T) &= \{ +, \$, ) \}
\end{aligned}
$$

### Nullable

Para determinar se algum não-terminal é *nullable*, verificamos se ele pode derivar a string vazia $\varepsilon$.

1. **Para E**:
    - $E \rightarrow T + E$: $T$ não é *nullable*, portanto, $E$ não é *nullable* a partir desta produção.
    - $E \rightarrow T$: $T$ não é *nullable*, portanto, $E$ não é *nullable*.
2. **Para T**:
    - $T \rightarrow int$: $int$ não é *nullable*.
    - $T \rightarrow (E)$: $E$ não é *nullable* e $($ é um terminal.

Ou seja, nenhum dos não-terminais é *nullable*:

$$
\begin{aligned}
Nullable(E) &= false \\
Nullable(T) &= false
\end{aligned}
$$

### Resumo dos Conjuntos

$$
\begin{aligned}
FIRST(E) &= \{ int, ( \} \\
FIRST(T) &= \{ int, ( \} \\
FOLLOW(E) &= \{ \$ ) \} \\
FOLLOW(T) &= \{ +, \$ ) \} \\
Nullable(E) &= false \\
Nullable(T) &= false
\end{aligned}
$$

O que permite gerar a seguinte Tabela de Derivação:

| não-terminal | int                        | (                          | \+  | \$  | )   |
|--------------|------------|------------|------------|------------|------------|
| E            | $E \rightarrow T + E$<br>$E \rightarrow T$ | $E \rightarrow T + E$<br>$E \rightarrow T$ |     |     |     |
| T            | $T \rightarrow int$                | $T \rightarrow (E)$                |     |     |     |

Nesta tabela podemos ver um conflito explícito. O não-terminal $E$ possui duas produções para os símbolos $int$ e $($.

Sempre que na criação de Tabelas de Derivação existir um conflito estaremos gerando ambiguidades na derivação. A gramática é ambígua, sempre que uma sentença puder ser derivada de duas ou mais formas diferentes, gerando árvores sintáticas diferentes. Por exemplo, na gramática do **Exemplo 1**, a sentença $int + int$ pode ser derivada tanto como $E → T → int$ seguido de $E → T + E → int + int$ quanto como $E → T + E → T + T → int + int$.

## Tipos de Conflitos Nas Tabelas de Derivação

Conflitos na Tabela de Derivação, ou tabela de análise, $LL(1)$ podem ser classificados em dois tipos principais:

1. **Conflito** $FIRST$/$FIRST$: ocorre quando o conjunto $FIRST$ de duas ou mais produções de um mesmo não-terminal possui um terminal em comum. Na gramática do **Exemplo 1**, as produções $E \rightarrow T + E$ e $E \rightarrow T$ possuem os terminais $int$ e $($ em seus conjuntos $FIRST$. Ao encontrar $int$ ou $($ na entrada, o *parser* não sabe se deve aplicar a regra que deriva uma expressão com um operador $+$ ou a regra que deriva um termo. Neste momento do processo de *parsing* determinismo saiu pela janela e o *parser* $LL(1)$ é inútil.

2. **Conflito** $FIRST$/$FOLLOW$: ocorre quando uma produção tem $\varepsilon$ (a *string* vazia) em seu conjunto $FIRST$ e o conjunto $FOLLOW$ do não-terminal da produção possui um terminal em comum com o $FIRST$ de outra produção do mesmo não-terminal. Por exemplo, na gramática do **Exemplo 1**, se $E \rightarrow \varepsilon$ fosse uma produção e o conjunto $FOLLOW(E)$ contivesse $+$, que também está no $FIRST$ da produção $E \rightarrow T + E$, ao encontrar o fim de uma expressão (representado por um símbolo em $FOLLOW(E)$), o *parser* não saberia se deve aplicar a regra que deriva apenas um termo ou a regra que deriva uma expressão com um operador $+$.

### Resolução de Conflitos

Conflitos na tabela $LL(1)$ podem ser resolvidos das seguintes formas:

1. **Refatoração da gramática**: A gramática pode ser reescrita para eliminar ambiguidades e recursões à esquerda, evitando assim os conflitos.
2. **Fatoração à esquerda**: Produções com prefixos comuns podem ser fatoradas para que a decisão entre elas possa ser tomada com base em um único símbolo de *lookahead*.
3. **Uso de analisadores mais poderosos**: Se os conflitos não puderem ser resolvidos na gramática, pode ser necessário usar um analisador sintático mais poderoso, como um analisador $LR(1)$ ou $LALR(1)$, que conseguem lidar com gramáticas mais complexas.

As soluções 1 e 2 implicam na modificação da sua gramática, o que ocorre com frequência quando começamos do zero. A solução 3, em linguagens complexas, pode ser a solução adequada, mas implica em mudar de algoritmo de *parser*

**Exemplo 2**: resolução de conflito. No exemplo da gramática anterior, o conflito $FIRST$/$FIRST$ pode ser resolvido fatorando as produções de $E$:

$$
\begin{aligned}
1. &\ E \rightarrow T E' \\
2. &\ E' \rightarrow + E \ \mid  \ \varepsilon \\
3. &\ T \rightarrow int \ \mid  \ (E)
\end{aligned}
$$

Se calcularmos os conjuntos $FIRST$ e $FOLLOW$ novamente, teremos:

#### Conjunto FIRST

1. **Para o não-terminal E**:
    - $E \rightarrow T E'$: o primeiro símbolo é $T$. Portanto, incluímos $FIRST(T)$ em $FIRST(E)$.
2. **Para o não-terminal E'**:
    - $E' \rightarrow + E$: o primeiro símbolo é $+$. Portanto, $FIRST(E')$ inclui $+$.
    - $E' \rightarrow \varepsilon$: incluímos $\varepsilon$ em $FIRST(E')$.
3. **Para o não-terminal T**:
    - $T \rightarrow int$: o primeiro símbolo é $int$. Portanto, $FIRST(T)$ inclui $int$.
    - $T \rightarrow (E)$: o primeiro símbolo é \$( \$. Portanto, $FIRST(T)$ inclui \$( \$.

Assim, teremos:

$$
\begin{aligned}
FIRST(T) &= \{ int, ( \} \\
FIRST(E') &= \{ +, \varepsilon \} \\
FIRST(E) &= FIRST(T) = \{ int, ( \}
\end{aligned}
$$

#### Conjunto FOLLOW

1. **Para o símbolo inicial E**:
    - $FOLLOW(E)$ inclui \$.
2. **Para as produções de E**:
    - $E \rightarrow T E'$:
      - O símbolo $E'$ pode ser seguido por $FOLLOW(E)$.
      - Então, $FOLLOW(E')$ inclui $FOLLOW(E)$.
3. **Para as produções de E'**:
    - $E' \rightarrow + E$:
      - O símbolo $E$ pode ser seguido por $FOLLOW(E')$.
      - Então, $FOLLOW(E)$ inclui $FOLLOW(E')$.
    - $E' \rightarrow \varepsilon$: não há efeito em $FOLLOW$.
4. **Para as produções de T**:
    - $T \rightarrow int$: $int$ é um terminal, não influencia $FOLLOW$.
    - $T \rightarrow (E)$: $E$ pode ser seguido por $)$, então $FOLLOW(E)$ inclui $)$.

Assim, teremos:

$$
\begin{aligned}
FOLLOW(E) &= \{ \$, ) \} \\
FOLLOW(E') &= \{ \$, ) \} \\
FOLLOW(T) &= \{ +, \$, ) \}
\end{aligned}
$$

#### Nullable

Para determinar se algum não-terminal é *nullable*, verificamos se ele pode derivar a string vazia $\varepsilon$.

1. **Para E**:
    - $E \rightarrow T E'$: $T$ não é *nullable*, portanto, $E$ não é *nullable*.
2. **Para E'**:
    - $E' \rightarrow + E$: $+$ é um terminal, portanto, não é *nullable*.
    - $E' \rightarrow \varepsilon$: $E'$ é *nullable*.
3. **Para T**:
    - $T \rightarrow int$: $int$ não é *nullable*.
    - $T \rightarrow (E)$: \$( \$ é um terminal, portanto, não é *nullable*.

Assim, teremos:

$$
\begin{aligned}
Nullable(E) &= false \\
Nullable(E') &= true \\
Nullable(T) &= false
\end{aligned}
$$

#### Resumo dos Conjuntos

$$
\begin{aligned}
FIRST(E) &= \{ int, ( \} \\
FIRST(E') &= \{ +, \varepsilon \} \\
FIRST(T) &= \{ int, ( \} \\
FOLLOW(E) &= \{ \$, ) \} \\
FOLLOW(E') &= \{ \$, ) \} \\
FOLLOW(T) &= \{ +, \$, ) \} \\
Nullable(E) &= false \\
Nullable(E') &= true \\
Nullable(T) &= false
\end{aligned}
$$

O que permite gerar a seguinte Tabela de Derivação:

| não-terminal | int         | (           | \+          | \$                   | )                    |
|------------|------------|------------|------------|------------|------------|
| E            | $E \rightarrow TE'$ | $E \rightarrow TE'$ |             |                      |                      |
| E'           |             |             | $E' \rightarrow +E$ | $E' \rightarrow \varepsilon$ | $E' \rightarrow \varepsilon$ |
| T            | $T \rightarrow int$ | $T \rightarrow (E)$ |             |                      |                      |

Agora, a decisão entre derivar uma expressão com um operador $+$ ou apenas um termo pode ser tomada com base no próximo símbolo da entrada: se for $+$, aplica-se a regra $E' \rightarrow + E$; caso contrário, aplica-se a regra $E' \rightarrow \varepsilon$.

Assim como fiz nos artigos anteriores, vou sugerir um pseudocódigo, um tanto inocente, para a criação de tabelas de derivação. Acredito que, com um pouco de cuidado, depois que a amável leitora dominar esta técnica possa criar um pseudocódigo mais eficiente. A fé move montanhas.

### Pseudocódigo para a Criação da Tabela de Derivação

``` pseudo
função construir_tabela(gramatica, nao_terminais, terminais, FIRST, FOLLOW):
    // Inicializa a tabela com entradas vazias (erro)
    Tabela = criar um dicionário aninhado [nao_terminal][terminal]

    // Itera sobre cada produção A -> α
    para cada não-terminal A e suas produções em gramatica:
        para cada produção α (lista de símbolos):
            
            // Calcula o FIRST da sequência α
            first_α = calcular_first_da_sequencia(α, ...)

            // Regra 1: Para cada terminal 't' em FIRST(α)
            para cada terminal t em first_α:
                se t != 'EPSILON':
                    se Tabela[A][t] já está preenchida:
                        Lançar ErroDeConflito(A, t)
                    senão:
                        Tabela[A][t] = produção A -> α

            // Regra 2: Se α pode ser vazio (ε)
            se 'EPSILON' está em first_α:
                // Para cada terminal 't' em FOLLOW(A)
                para cada terminal t em FOLLOW[A]:
                    se Tabela[A][t] já está preenchida:
                        Lançar ErroDeConflito(A, t)
                    senão:
                        Tabela[A][t] = produção A -> ε
    
    retornar Tabela
```

Em fim, este código pode ser implementado em Python por:

``` python
def construir_tabela_ll1(
    gramatica: dict,
    simbolo_inicial: str) -> dict[str, dict[str, list | None]]:
    """
    Constrói a Tabela de Análise LL(1) completa a partir de uma gramática.
    Esta função serve como um integrador para todas as funções anteriores.
    """
    # 1. Identificar todos os símbolos
    nao_terminais = set(gramatica.keys())
    simbolos = set(nao_terminais)
    for producoes in gramatica.values():
        for producao in producoes:
            simbolos.update(producao)
    terminais = sorted(list(simbolos - nao_terminais - {'EPSILON'})) + ['$']
    
    # 2. Calcular os conjuntos
    nullable = calcular_NULLABLE(gramatica)
    first = calcular_FIRST(gramatica, nao_terminais, nullable)
    follow = calcular_FOLLOW(gramatica, simbolo_inicial, nao_terminais, first, nullable)
    
    # 3. Inicializar e preencher a tabela
    tabela = {nt: {t: None for t in terminais} for nt in nao_terminais}
    
    for nt_head, producoes in gramatica.items():
        for producao in producoes:
            first_producao = calcular_first_da_sequencia(producao, first, nullable, nao_terminais)
            
            # Regra 1: FIRST
            for terminal in first_producao - {'EPSILON'}:
                if tabela[nt_head][terminal] is not None:
                    raise ValueError(f"Conflito FIRST/FIRST em [{nt_head}, {terminal}]!")
                tabela[nt_head][terminal] = producao
                
            # Regra 2: FOLLOW
            if 'EPSILON' in first_producao:
                for terminal in follow[nt_head]:
                    if tabela[nt_head][terminal] is not None:
                        raise ValueError(f"Conflito FIRST/FOLLOW em [{nt_head}, {terminal}]!")
                    tabela[nt_head][terminal] = producao

    return tabela

def imprimir_tabela(tabela: dict):
    """Função auxiliar para exibir a tabela de forma legível no console."""
    nao_terminais = sorted(tabela.keys())
    if not nao_terminais: return
    
    terminais = sorted(tabela[nao_terminais[0]].keys())
    
    # Imprimir cabeçalho
    header = f"{'Não-Terminal':<15}" + "".join([f"{t:<18}" for t in terminais])
    print(header)
    print("-" * len(header))
    
    # Imprimir linhas
    for nt in nao_terminais:
        row_str = f"{nt:<15}"
        for t in terminais:
            producao = tabela[nt][t]
            if producao is None:
                cell = " "
            else:
                # Formata a produção como "A -> α"
                cell = f"{nt} → {' '.join(producao)}"
            row_str += f"{cell:<18}"
        print(row_str)

# --- Exemplo de uso para a gramática refatorada (Exemplo 2) ---
gramatica_sem_conflito = {
    'E': [['T', "E'"]],
    "E'": [['+', 'E'], ['EPSILON']],
    'T': [['int'], ['(', 'E', ')']]
}

try:
    tabela_final = construir_tabela_ll1(gramatica_sem_conflito, 'E')
    print("Tabela de Análise LL(1) gerada com sucesso:\n")
    imprimir_tabela(tabela_final)
except ValueError as e:
    print(f"Erro ao gerar tabela: {e}")
```
