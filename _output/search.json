[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Linguagens Formais e Autômatos",
    "section": "",
    "text": "1 Disciplina de Linguagens Formais\nEste é o material de suporte para a disciplina de Linguagens Formais, que abrange conceitos fundamentais de teoria da computação, autômatos, gramáticas e linguagens formais. O curso é dividido em várias partes, cada uma focando em aspectos específicos do tema.\nAlém deste texto o aluno deve consultar os livros e artigos recomendados no plano de ensino da disciplina.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Disciplina de Linguagens Formais</span>"
    ]
  },
  {
    "objectID": "parsers.html",
    "href": "parsers.html",
    "title": "2  Parsers LL(1): O Mundo da Análise Sintática",
    "section": "",
    "text": "2.1 Definição e Características dos Parsers LL(1)\nOs parsers preditivos são analisadores sintáticos descendentes (top-down) que utilizam um único símbolo de lookahead (antecipação) para determinar a regra de produção correta a ser aplicada em cada etapa da análise. Eles predizem qual regra usar com base no próximo símbolo da entrada e no não-terminal atualmente sendo analisado. O termo \\(LL(1)\\) significa:\nUm parser \\(LL(1)\\), requer uma gramática \\(LL(1)\\). Nesta gramática não pode existir qualquer ambiguidade na escolha da regra de produção que será aplicada a cada símbolo de lookahead. Além disso, a gramática não pode ter recursão à esquerda, seja esta recursão direta ou indireta. A recursão à esquerda é um desafio considerável. Existem duas formas de recursão à esquerda:\nAlém do perigo do laço de repetição infinito que faz o pobre Turing se revolver no túmulo, a recursão à esquerda impede o desenvolvimento de uma Tabela de Derivação. Graças a criação de regras em conflito. Duas ou mais regras, para a mesma combinação de símbolo terminal e símbolo não-terminal em um determinado momento do processo de parser.",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Parsers LL(1): O Mundo da Análise Sintática</span>"
    ]
  },
  {
    "objectID": "parsers.html#definição-e-características-dos-parsers-ll1",
    "href": "parsers.html#definição-e-características-dos-parsers-ll1",
    "title": "2  Parsers LL(1): O Mundo da Análise Sintática",
    "section": "",
    "text": "L: Left-to-right scan (varredura da esquerda para a direita) da entrada.\nL: Leftmost derivation (derivação mais à esquerda) da gramática.\n1: Um símbolo de lookahead (antecipação) para tomada de decisão.\n\n\n\nRecursão à Esquerda Direta: ocorre quando um símbolo não-terminal pode ser derivado em uma sequência que começa com ele mesmo. Por exemplo, na regra \\(A → Aa \\mid b\\), o símbolo \\(A\\) pode ser substituído no processo de derivação em \\(Aa\\), onde \\(A\\) aparece novamente no início da regra. E aqui está o laço infinito.\nRecursão à Esquerda Indireta: acontece quando um símbolo não-terminal pode ser derivado em uma sequência que começa com outro símbolo não-terminal, que por sua vez pode ser derivado de volta ao símbolo original. Ilustrando, nas regras \\(A → Ba\\) e \\(B → Ab\\), \\(A\\) deriva para \\(Ba\\), \\(B\\) deriva para \\(Ab\\) e \\(Ab\\) pode derivar novamente para \\(A\\), criando outro laço infinito.",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Parsers LL(1): O Mundo da Análise Sintática</span>"
    ]
  },
  {
    "objectID": "parsers.html#eliminação-da-recursão-à-esquerda",
    "href": "parsers.html#eliminação-da-recursão-à-esquerda",
    "title": "2  Parsers LL(1): O Mundo da Análise Sintática",
    "section": "2.2 Eliminação da Recursão à Esquerda",
    "text": "2.2 Eliminação da Recursão à Esquerda\nFelizmente, existem técnicas para eliminar a recursão à esquerda em gramáticas livres de contexto. Uma técnica comum e eficaz envolve a introdução de novos símbolos não terminais e a substituição de regras recursivas por regras equivalentes que não apresentem recursão. Em alguns casos, a substituição direta dos símbolos não terminais recursivos por suas respectivas regras pode ser suficiente para eliminar a recursão à esquerda direta. Outra técnica, a fatoração à esquerda, pode ser utilizada para eliminar ambiguidades na gramática, mas não resolve diretamente o problema da recursão.\nExemplo 1: eliminando a Recursão à Esquerda Direta, considere a regra \\(A → Aa \\mid b\\). Esta regra pode ser reescrita como:\n\n\\(A \\to bA'\\)\n\\(A' \\to aA' \\mid \\varepsilon\\)\n\nAgora, a gramática não contém mais recursão à esquerda direta. Este é um exemplo simples, adequado a este texto cujo objetivo é o parser em si. A nova regra inclui o não-terminal \\(A'\\), que permite zero ou mais repetições do símbolo \\(a\\). O uso de \\(\\varepsilon\\) (a produção vazia) permite terminar a derivação de \\(A'\\). Será?\nPara verificar a recursão à esquerda indireta, você precisa observar se é possível derivar uma recursão através de uma cadeia de substituições:\n\nSubstituindo \\(A\\):\n\n\\(A \\rightarrow bA'\\)\n\nSubstituindo \\(A'\\):\n\n\\(A' \\rightarrow aA'\\)\n\\(A' \\rightarrow \\varepsilon\\)\n\n\nObserve que substituindo \\(A\\) por \\(bA'\\) e depois \\(A'\\) por \\(aA'\\) ou \\(\\varepsilon\\) não leva de volta a \\(A\\). E parece não haver recursão. Contudo, é necessário verificar se foi criada alguma recursão à esquerda indireta, focando em \\(A'\\):\n\nPrimeira substituição:\n\n\\(A \\rightarrow bA'\\)\n\nSubstituindo \\(A'\\) por \\(aA'\\):\n\n\\(bA' \\rightarrow b(aA')\\)\n\\(bA' \\rightarrow baA'\\)\n\nSubstituindo novamente \\(A'\\) por \\(aA'\\):\n\n\\(baA' \\rightarrow baaA'\\)\n\nE assim por diante… Aqui, \\(A'\\) substitui a si próprio com um prefixo \\(a\\), mas isto não cria recursão indireta ao \\(A'\\) inicial de forma a levar a uma cadeia circular que retorne ao símbolo inicial \\(A\\). A gramática transformada não apresenta recursão à esquerda indireta para \\(A'\\).\n\\(A\\): Não tem recursão à esquerda direta nem indireta, pois \\(A \\rightarrow bA'\\) começa com um terminal.\n\\(A'\\): A regra \\(A' \\rightarrow aA' \\mid \\varepsilon\\) apenas permite que \\(A'\\) produza cadeias de \\(a\\) seguidos possivelmente por \\(\\varepsilon\\), sem retornar a um estado anterior que causaria recursão indireta.\n\nPortanto, a transformação feita elimina a recursão à esquerda direta sem introduzir recursão à esquerda indireta. A recursão â esquerda indireta é mais complexa e requer um texto específico para o assunto. Mas, em linhas gerais você terá que refazer a gramática em face dos objetivos originais para eliminar este tipo de recursão. Vou deixar por sua conta resolver a recursão à esquerda indireta e a ambiguidade que surjam nas gramáticas que você criar.",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Parsers LL(1): O Mundo da Análise Sintática</span>"
    ]
  },
  {
    "objectID": "parsers.html#elementos-fundamentais-do-parser-ll1",
    "href": "parsers.html#elementos-fundamentais-do-parser-ll1",
    "title": "2  Parsers LL(1): O Mundo da Análise Sintática",
    "section": "2.3 Elementos Fundamentais do Parser LL(1)",
    "text": "2.3 Elementos Fundamentais do Parser LL(1)\nComo a classe de gramáticas para um parser \\(LL(1)\\) é limitada (nem todas as gramáticas livres de contexto são \\(LL(1)\\), é muito comum que seja necessário modificar a sua ideia original de gramática para eliminar ambiguidades e recursões à esquerda. Um parser \\(LL(1)\\), para funcionar, precisa dos seguintes elementos:\n\nTabela de Derivação: O parser \\(LL(1)\\) utiliza uma Tabela de Derivação, ou Tabela de Derivação, que mapeia cada combinação de não-terminal e terminal (ou símbolo de fim de entrada) para a regra de produção que deve ser aplicada. Essa tabela é construída a partir da gramática e dos conjuntos \\(FIRST\\) e \\(FOLLOW\\) e será o mapa que guiará todo o processo de análise sintática.\nPilha e Buffer: O parser mantém uma pilha e lê a entrada da esquerda para a direita, carácter por carácter. A pilha inicialmente contém o símbolo inicial da gramática e o símbolo de fim de entrada, \\(\\$\\). A entrada frequentemente é mantida em uma estrutura de dados com funcionalidades de buffer, que pode ser a própria string que está sendo analisada.\nAnálise: Em cada passo:\n\nO parser consulta a Tabela de Derivação usando como índices o não-terminal no topo da pilha e o próximo símbolo da entrada.\nA tabela indica a produção a ser aplicada.\nO não-terminal no topo da pilha é substituído pelos símbolos da produção (empilhados em ordem inversa).\nSe o topo da pilha for um terminal que coincide com o próximo símbolo da entrada, ambos são removidos da pilha e da entrada.\n\nSucesso ou Erro: A análise termina com sucesso quando a pilha e a entrada estão vazias. Caso contrário, ocorre um erro sintático. Erros poderão ocorrer durante o processo sempre que a combinação de símbolos na pilha e no buffer apontarem para uma célula vazia da Tabela de Derivação.",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Parsers LL(1): O Mundo da Análise Sintática</span>"
    ]
  },
  {
    "objectID": "parsers.html#conjuntos-first-follow-e-símbolos-nullable",
    "href": "parsers.html#conjuntos-first-follow-e-símbolos-nullable",
    "title": "2  Parsers LL(1): O Mundo da Análise Sintática",
    "section": "2.4 Conjuntos FIRST, FOLLOW e Símbolos Nullable",
    "text": "2.4 Conjuntos FIRST, FOLLOW e Símbolos Nullable\nCriar um parser \\(LL(1)\\) geralmente exige mais do que apenas os conjuntos \\(FIRST\\) e \\(FOLLOW\\). Este é um processo que envolve garantir a adequação da gramática e seguir etapas específicas para construir a Tabela de Derivação. Vou explorar esse processo de forma mais clara e detalhada, ainda neste texto.\nA gramática criada para o parser \\(LL(1)\\) não pode ter qualquer ambiguidade. Ou seja, cada string da linguagem deve ser derivada em uma e apenas uma árvore sintática. Acrescente-se a isso que a gramática não deve ter regras do tipo \\(A \\rightarrow A\\alpha\\) (recursão direta) nem \\(A \\rightarrow B\\alpha\\) e \\(B \\rightarrow AB\\) (recursão indireta). Ou seja, uma gramática sem recursão à esquerda.\nUma vez que tenha uma gramática adequada, será possível construir uma Tabela de Derivação \\(LL(1)\\). Para isso vamos precisar:\n\nEncontrar os conjuntos \\(FIRST\\) e \\(FOLLOW\\):\n\n\\(FIRST(A)\\): O conjunto de terminais que podem iniciar uma derivação de \\(A\\).\n\\(FOLLOW(A)\\): O conjunto de terminais que podem aparecer imediatamente após \\(A\\) em uma derivação.\n\nConsiderar Símbolos Nullable:\n\nUm símbolo é nullable se pode derivar a cadeia vazia (\\(\\epsilon\\)).\nO cálculo de \\(FIRST\\) e \\(FOLLOW\\) precisa levar em conta os símbolos nullable.\n\nPreencher a Tabela:\n\nPara cada produção \\(A \\rightarrow \\alpha\\):\n\nSe \\(\\alpha\\) começa com um terminal \\(a\\), adicione a produção à célula \\((A, a)\\).\nSe \\(\\alpha\\) é nullable e \\(b\\) está em \\(FOLLOW(A)\\), adicione a produção à célula \\((A, b)\\).\n\n\n\nUm símbolo não-terminal é nullable se ele pode ser derivado para a cadeia vazia (\\(\\varepsilon\\)), ou seja, se ele pode desaparecer durante uma derivação. Por exemplo, na produção \\(A \\rightarrow BC\\), se tanto \\(B\\) quanto \\(C\\) são nullable, então \\(A\\) também é nullable. A presença de símbolos nullable exige alguns ajustes nos algoritmos de identificação de \\(FIRST\\) e \\(FOLLOW\\):\n\n\\(FIRST\\): Se um símbolo é nullable, será necessário adicioná-lo \\(\\epsilon\\) ao seu conjunto \\(FIRST\\). Além disso, ao calcular o \\(FIRST\\) de uma sequência de símbolos, se um símbolo é nullable, também é necessário considerar o \\(FIRST\\) do próximo símbolo.\n\\(FOLLOW\\): Se um símbolo é nullable, ao calcular o \\(FOLLOW\\) de um símbolo que o precede, também é imprescindível considerar o \\(FOLLOW\\) do símbolo anterior.",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Parsers LL(1): O Mundo da Análise Sintática</span>"
    ]
  },
  {
    "objectID": "parsers.html#exemplo-com-símbolos-nullable",
    "href": "parsers.html#exemplo-com-símbolos-nullable",
    "title": "2  Parsers LL(1): O Mundo da Análise Sintática",
    "section": "2.5 Exemplo com Símbolos Nullable",
    "text": "2.5 Exemplo com Símbolos Nullable\nExemplo 2: Considere a gramática representada pelo conjunto de regras de produção a seguir:\n\n\\(S → AB\\)\n\\(A → \\varepsilon\\)\n\\(B → b \\mid \\varepsilon\\)\n\nCálculo de Nullable\n\n\\(A \\rightarrow \\epsilon\\), então \\(A\\) é nullable.\n\\(B \\rightarrow \\epsilon\\), então \\(B\\) é nullable.\nPara \\(S\\), ambos \\(A\\) e \\(B\\) são nullable, então \\(S\\) é nullable.\n\nCálculo de \\(FIRST\\)\n\n\\(FIRST(A) = \\{ \\epsilon \\}\\)\n\\(FIRST(B) = \\{ b, \\epsilon \\}\\)\n\\(FIRST(S) = FIRST(AB) = FIRST(A) ∪ FIRST(B) = \\{ \\epsilon \\} ∪ \\{ b, \\epsilon \\} = \\{ b, \\epsilon \\}\\)\n\nCálculo de \\(FOLLOW\\)\n\n\\(FOLLOW(S) = \\{ \\$ \\}\\)\n\\(FOLLOW(A) = FIRST(B) = \\{ b, \\epsilon \\} (excluindo \\quad \\epsilon)\\)\n\\(FOLLOW(B) = FOLLOW(S) = \\{ \\$ \\}\\)\n\nNeste exemplo, os símbolos nullable influenciam diretamente os conjuntos \\(FIRST\\) e \\(FOLLOW\\), permitindo a construção correta da tabela de parsing \\(LL(1)\\) e garantindo que a gramática pode ser analisada de forma preditiva com um símbolo de lookahead.\nTabela de Derivação \\(LL(1)\\)\n\n\n\n\n\\(b\\)\n\\(\\$\\)\n\n\n\n\n\\(S\\)\n\\(S \\rightarrow AB\\)\n\\(S \\rightarrow AB\\)\n\n\n\\(A\\)\n\\(A \\rightarrow \\varepsilon\\)\n\\(A \\rightarrow \\varepsilon\\)\n\n\n\\(B\\)\n\\(B \\rightarrow b\\)\n\\(B \\rightarrow \\varepsilon\\)\n\n\n\nObservações Importantes sobre as regras de produção:\n\n\\(S \\rightarrow AB\\): se o próximo símbolo de entrada for \\(b\\) ou \\(\\$\\), a produção \\(S \\rightarrow AB\\) deve ser aplicada.\n\\(A \\rightarrow \\epsilon\\): se o próximo símbolo de entrada for \\(b\\) ou \\(\\$\\), a produção \\(A \\rightarrow \\epsilon\\) deve ser aplicada.\n\\(B \\rightarrow b\\): se o próximo símbolo de entrada for \\(b\\), a produção \\(B \\rightarrow b\\) deve ser aplicada.\n\\(B \\rightarrow \\epsilon\\): se o próximo símbolo de entrada for \\(\\$\\), a produção \\(B \\rightarrow \\epsilon\\) deve ser aplicada.\n\nVoltando à gramática original: perceba que a gramática original é ambígua, pois a string vazia, \\(\\varepsilon\\), pode ser derivada de formas diferentes. Esta gramática foi criada, simples, para destacar a ambiguidade. Mas podemos modificar a esta gramática a nosso bel prazer. Lembre-se a linguagem é sua. Sendo assim:\n$1. S b $\nSe observarmos as regras de produção:\n\n\\(S \\rightarrow b\\): essa produção gerará a string \\(b\\).\n\\(S \\rightarrow \\epsilon\\): essa produção gerará a string vazia.",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Parsers LL(1): O Mundo da Análise Sintática</span>"
    ]
  },
  {
    "objectID": "parsers.html#tabela-de-derivação-ll1-para-a-gramática-modificada",
    "href": "parsers.html#tabela-de-derivação-ll1-para-a-gramática-modificada",
    "title": "2  Parsers LL(1): O Mundo da Análise Sintática",
    "section": "2.6 Tabela de Derivação \\(LL(1)\\) para a Gramática Modificada",
    "text": "2.6 Tabela de Derivação \\(LL(1)\\) para a Gramática Modificada\n\n\n\n\nb\n\\(\\$\\)\n\n\n\n\n\\(S\\)\n\\(S \\rightarrow b\\)\n\\(S \\rightarrow \\epsilon\\)\n\n\n\nObservações importantes sobre as regras de produção:\n\nSe o próximo símbolo de entrada for \\(b\\), a produção \\(S \\rightarrow b\\) será aplicada.\nSe o próximo símbolo de entrada for \\(\\$\\) (fim da entrada), a produção \\(S \\rightarrow \\epsilon\\) será aplicada.\n\nE pronto! Neste ponto do texto vimos tudo que precisamos ver e podemos parar. A pobre leitora, nesta altura do campeonato, deve estar pensando mal de mim. Eu sei, parece confuso. Talvez dois exemplos mais detalhados ajudem.",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Parsers LL(1): O Mundo da Análise Sintática</span>"
    ]
  },
  {
    "objectID": "parsers.html#o-exemplo-mais-comum-de-todos",
    "href": "parsers.html#o-exemplo-mais-comum-de-todos",
    "title": "2  Parsers LL(1): O Mundo da Análise Sintática",
    "section": "2.7 O Exemplo Mais Comum de Todos",
    "text": "2.7 O Exemplo Mais Comum de Todos\nO exemplo a seguir está em todos os sites, livros e aulas que eu já vi disponíveis na internet. É tão comum que não me dei ao trabalho de procurar sua origem. Meu instinto me diz que deve ser do livro do Aho, mas não fui conferir. É um exemplo tão bom que deve ser do Aho. Enfim, vamos ao trabalho:\n\n2.7.1 Gramática\nConsidere a gramática representada pelo conjunto de regras de produção a seguir:\n\\(1. S \\rightarrow E\\)\n\\(2. E \\rightarrow E + T \\mid T\\)\n\\(3. T \\rightarrow T * F \\mid F\\)\n\\(4. F \\rightarrow (E) \\mid id\\)\nQue permite criar os seguintes conjuntos:\n\n\n2.7.2 \\(FIRST\\)\n\n\\(FIRST(S) = FIRST(E)\\)\n\\(FIRST(E) = \\{ id, ( \\}\\)\n\\(FIRST(T) = \\{ id, ( \\}\\)\n\\(FIRST(F) = \\{ id, ( \\}\\)\n\n\n\n2.7.3 \\(FOLLOW\\)\n\n\\(FOLLOW(S) = \\{ \\$ \\}\\)\n\\(FOLLOW(E) = \\{ +, ), \\$ \\}\\)\n\\(FOLLOW(T) = \\{ +, *, ), \\$ \\}\\)\n\\(FOLLOW(F) = \\{ +, *, ), \\$ \\}\\)\n\n\n\n2.7.4 \\(NULLABLE\\)\nNenhuma das produções é nullable.\nOs quais, por sua vez, irão permitir a criação da seguinte Tabela de Derivação\n\n\n2.7.5 Tabela de Derivação \\(LL(1)\\)\n\n\n\n\nid\n+\n*\n(\n)\n$\n\n\n\n\nS\nE\n\n\nE\n\n\n\n\nE\nT\n\n\nT\n\n\n\n\nE\nT\nE + T\n\nT\nε\nε\n\n\nT\nF\nε\nT * F\nF\nε\nε\n\n\nF\nid\n\n\n(E)\n\n\n\n\n\nCom a Tabela de Derivação em mãos, podemos partir para a criação do parser. Não vou criar nenhum algoritmo agora, na verdade, vou apenas reproduzir o processo passo a passo, na esperança que a corajosa leitora entenda o algoritmo muito antes de vê-lo formalizado ou implementado.\n\n\n2.7.6 Processo de Parser Testando com \\(id + id * id\\)\nPara verificar se a string id + id  id* faz parte da linguagem representada na gramática dada pode ser identificada por um parser \\(LL(1)\\) usando a Tabela de Derivação acima. Seguiremos um processo de análise preditiva descendente, começando pelo símbolo inicial. Usaremos uma pilha e a própria string de entrada como buffer\nVou começar com a pilha contendo o símbolo inicial da gramática, \\(S\\), e a string de entrada id + id  id$, onde o \\(\\$\\) indica o final da entrada. Se você estiver fazendo o parser* na mão deverá seguir os seguintes passos:\n\nVerificar o topo da pilha (\\(S\\)) e o próximo símbolo de entrada (‘id’).\nUse a Tabela de Derivação para encontrar a produção apropriada, que, neste caso, será \\(S \\rightarrow E\\).\nSubstituir \\(S\\) pela produção \\(E\\) na pilha.\nO próximo passo é verificar o topo da pilha (\\(E\\)) e o próximo símbolo de entrada (‘id’).\nA Tabela indica a regra \\(E \\rightarrow T\\). Substitua \\(E\\) por \\(T\\).\nO próximo passo é verificar o topo da pilha (\\(T\\)) e o próximo símbolo de entrada (‘id’).\nA Tabela indica a regra \\(T \\rightarrow F\\). Substitua \\(T\\) por \\(F\\).\nO próximo passo é verificar o topo da pilha (\\(F\\)) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(F \\rightarrow id\\). Substitua \\(F\\) por ‘id’.\nAgora a pilha tem ‘id’ e a entrada é “id + id * id$”. O próximo passo é consumir ‘id’ da entrada e da pilha, o valor na pilha e no buffer coincidem.\nO topo da pilha agora é \\(T\\) e o próximo símbolo de entrada é ‘+’.\nA Tabela indica \\(E \\rightarrow E + T\\). Substituir \\(E\\) por \\(E + T\\).\nAgora a pilha tem \\(T + T\\) e a entrada é “+ id * id$”. Consumir ‘+’ da entrada e da pilha, pois eles coincidem.\nO próximo passo é verificar o topo da pilha \\(T\\) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(T \\rightarrow F\\). Substituir \\(T\\) por \\(F\\).\nO próximo passo é verificar o topo da pilha \\(F\\) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(F \\rightarrow id\\). Substituir \\(F\\) por ‘id’.\nConsumir ‘id’ da entrada e da pilha, pois eles coincidem.\nO topo da pilha agora é \\(T\\) e o próximo símbolo de entrada é ’*’.\nA Tabela indica \\(T \\rightarrow T * F\\). Substituir \\(T\\) por \\(T * F\\).\nConsumir ’*’ da entrada e da pilha, pois eles coincidem.\nO próximo passo é verificar o topo da pilha \\(T\\) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(T \\rightarrow F\\). Substituir \\(T\\) por \\(F\\).\nO próximo passo é verificar o topo da pilha \\(F\\) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(F \\rightarrow id\\). Substituir \\(F\\) por ‘id’.\nConsumir ‘id’ da entrada e da pilha, pois eles coincidem.\nFinalmente, a pilha está vazia e a entrada foi completamente consumida.\n\nComo foi possível consumir toda string da entrada, id + id  id$, e esvaziar a pilha sem encontrar nenhum erro, a string* id + id  id* é de fato parte da linguagem identificada pelo parser \\(LL(1)\\) que poderá ser criado pela Tabela de Derivação que definimos. Mas estamos em universo onde o céu é sempre azul e as rosas estão sempre desbrochadas.\n\n\n2.7.7 Testando com a string id - id  id*\nVamos analisar a string id - id  id* utilizando a Tabela de Derivação \\(LL(1)\\) que foi estabelecida anteriormente, seguindo os passos do parser \\(LL(1)\\). Começamos com a pilha inicial contendo o símbolo inicial \\(S\\) e a entrada “id - id * id$”.\n\nVerificar o topo da pilha (\\(S\\)) e o próximo símbolo de entrada (‘id’).\nUse a Tabela de Derivação para encontrar a produção apropriada, que, neste caso, será \\(S \\rightarrow E\\).\nSubstituir \\(S\\) pela produção \\(E\\) na pilha.\nO próximo passo é verificar o topo da pilha (\\(E\\)) e o próximo símbolo de entrada (‘id’).\nA Tabela indica a regra \\(E \\rightarrow T\\). Substitua \\(E\\) por \\(T\\).\nO próximo passo é verificar o topo da pilha (\\(T\\)) e o próximo símbolo de entrada (‘id’).\nA Tabela indica a regra \\(T \\rightarrow F\\). Substitua \\(T\\) por \\(F\\).\nO próximo passo é verificar o topo da pilha (\\(F\\)) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(F \\rightarrow id\\). Substitua \\(F\\) por ‘id’.\nAgora a pilha tem ‘id’ e a entrada é “id - id * id$”. O próximo passo é consumir ‘id’ da entrada e da pilha, o valor na pilha e no buffer coincidem.\nVerificar o topo da pilha ($) e o próximo símbolo de entrada (‘-’).\nA Tabela não fornece uma produção para \\(T\\) com entrada ‘-’, indicando que a string não é aceita pela gramática dada.\n\nPortanto, a string id - id id* não faz parte da linguagem definida pela gramática fornecida. O que deveria ser óbvio, já que a gramática não tem regras para lidar com o símbolo ‘-’. Para que a gramática suporte outros símbolos como o ‘-’, regras de produção adicionais devem ser incluídas.\nVimos, com a mesma gramática, as duas situações possíveis: ou a string faz parte da linguagem definida pela gramática, ou não. Simples assim.",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Parsers LL(1): O Mundo da Análise Sintática</span>"
    ]
  },
  {
    "objectID": "parsers.html#um-exemplo-nem-tão-comum",
    "href": "parsers.html#um-exemplo-nem-tão-comum",
    "title": "2  Parsers LL(1): O Mundo da Análise Sintática",
    "section": "2.8 Um Exemplo Nem Tão Comum",
    "text": "2.8 Um Exemplo Nem Tão Comum\nEste exemplo saiu das vozes da minha cabeça. Pode ser que exista em algum outro lugar, mas não me dei ao trabalho de verificar. É um exemplo que uso há muitos anos, em aula e já nem me preocupo com ele. Se souber a origem, fico grato.\n\n2.8.1 Gramática\nConsidere a seguinte gramática para expressões booleanas (\\(OR, AND, NOT\\)), definida pelo conjunto de regras de produção a seguir:\n\\(1. S \\rightarrow B\\)\n\\(2. B \\rightarrow B \\,\\, OR \\,\\, M \\mid M\\)\n\\(3. M \\rightarrow M \\,\\, AND \\,\\, N \\mid N\\)\n\\(4. N \\rightarrow NOT \\,\\, N \\mid (B) \\,\\mid id\\)\nNovamente, graças ao conjunto de regras de produção podemos criar os seguintes conjuntos:\n\n\n2.8.2 \\(FIRST\\)\n\n\\(FIRST(S) = FIRST(B)\\)\n\\(FIRST(B) = FIRST(M) = FIRST(N)\\)\n\\(FIRST(M) = FIRST(N)\\)\n\\(FIRST(N) = \\{ NOT, (, id \\}\\)\n\n\n\n2.8.3 \\(FOLLOW\\)\n\n\\(FOLLOW(S) = \\{ \\$ \\}\\)\n\\(FOLLOW(B) = \\{ OR, ), \\$ \\}\\)\n\\(FOLLOW(M) = \\{ OR, AND, ), \\$ \\}\\)\n\\(FOLLOW(N) = \\{ OR, AND, ), \\$ \\}\\)\n\n\n\n2.8.4 \\(NULLABLE\\)\nNenhuma das produções é nullable.\nCom os conjuntos já criados podemos criar uma Tabela de Derivação:\n\n\n2.8.5 Tabela de Derivação \\(LL(1)\\)\n\n\n\n\nid\nOR\nAND\nNOT\n(\n)\n$\n\n\n\n\nS\nB\n\n\nB\nB\n\n\n\n\nB\nM\n\n\nM\nM\n\n\n\n\nB\nM\nB OR M\n\nM\nM\nε\nε\n\n\nM\nN\nε\nM AND N\nN\nN\nε\nε\n\n\nN\nid\n\n\nNOT N\n(B)\n\n\n\n\n\nCom a Tabela de Derivação, podemos partir para o passo a passo do parser \\(LL(1)\\).\n\n\n2.8.6 Testando com id OR NOT id AND (id OR id)\nPara verificar se a string id OR NOT id AND (id OR id) faz parte da linguagem definida pela gramática dada e se pode ser analisada por um parser \\(LL(1)\\) usando a Tabela de Derivação encontrada, seguiremos o processo de análise preditiva descendente, começando pelo símbolo inicial, \\(S\\), utilizando a Tabela de Derivação para guiar a derivação.\nNovamente o processo iniciará com a pilha contendo o símbolo inicial da gramática, \\(S\\), e a string de entrada id OR NOT id AND (id OR id)$ será usada como buffer, onde o “$” indica o final da entrada. Siga os seguintes passos:\n\nVerificar o topo da pilha (\\(S\\)( e o próximo símbolo de entrada (‘id’).\nUsar a Tabela de Derivação para encontrar a produção apropriada: \\(S \\rightarrow B\\).\nSubstituir \\(S\\) pela produção \\(B\\) na pilha.\nO próximo passo é verificar o topo da pilha (\\(B\\)) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(B \\rightarrow M\\). Substituir \\(B\\) por \\(M\\).\nO próximo passo é verificar o topo da pilha (\\(M\\)) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(M \\rightarrow N\\). Substituir \\(M\\) por \\(N\\).\nO próximo passo é verificar o topo da pilha (\\(N\\)) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(N \\rightarrow id\\). Substituir \\(N\\) por ‘id’.\nAgora a pilha tem ‘id’ e a entrada é id OR NOT id AND (id OR id)$. O próximo passo é consumir ‘id’ da entrada e da pilha, pois eles coincidem.\nO topo da pilha agora é \\(M\\) e o próximo símbolo de entrada é ‘OR’.\nA Tabela indica \\(B \\rightarrow B OR M\\). Substituir \\(B\\) por \\(B OR M\\).\nAgora a pilha tem \\(M OR M\\) e a entrada é “OR NOT id AND (id OR id)$”. Consumir ‘OR’ da entrada e da pilha, pois eles coincidem.\nO próximo passo é verificar o topo da pilha \\(M\\) e o próximo símbolo de entrada (‘NOT’).\nA Tabela indica \\(M \\rightarrow N\\). Substituir \\(M\\) por \\(N\\).\nO próximo passo é verificar o topo da pilha \\(N\\) e o próximo símbolo de entrada (‘NOT’).\nA Tabela indica \\(N \\rightarrow NOT N\\). Substituir \\(N\\) por \\(NOT N\\).\nConsumir ‘NOT’ da entrada e da pilha, pois eles coincidem.\nO próximo passo é verificar o topo da pilha \\(N\\) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(N \\rightarrow id\\). Substituir \\(N\\) por ‘id’.\nConsumir ‘id’ da entrada e da pilha, pois eles coincidem.\nO topo da pilha agora é \\(M\\) e o próximo símbolo de entrada é ‘AND’.\nA Tabela indica \\(M \\rightarrow M AND N\\). Substituir \\(M\\) por \\(M AND N\\).\nConsumir ‘AND’ da entrada e da pilha, pois eles coincidem.\nO próximo passo é verificar o topo da pilha \\(M\\) e o próximo símbolo de entrada (‘(’).\nA Tabela indica \\(M \\rightarrow N\\). Substituir \\(M\\) por \\(N\\).\nO próximo passo é verificar o topo da pilha \\(N\\) e o próximo símbolo de entrada (‘(’).\nA Tabela indica \\(N \\rightarrow (B)\\). Substituir \\(N\\) por \\((B)\\).\nConsumir ‘(’ da entrada e da pilha, pois eles coincidem.\nO próximo passo é verificar o topo da pilha \\(B\\) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(B \\rightarrow M\\). Substituir \\(B\\) por \\(M\\).\nO próximo passo é verificar o topo da pilha \\(M\\) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(M \\rightarrow N\\). Substituir \\(M\\) por \\(N\\).\nO próximo passo é verificar o topo da pilha \\(N\\) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(N \\rightarrow id\\). Substituir \\(N\\) por ‘id’.\nConsumir ‘id’ da entrada e da pilha, pois eles coincidem.\nO topo da pilha agora é \\(B\\) e o próximo símbolo de entrada é ‘OR’.\nA Tabela indica \\(B \\rightarrow B OR M\\). Substituir \\(B\\) por \\(B OR M\\).\nConsumir ‘OR’ da entrada e da pilha, pois eles coincidem.\nO próximo passo é verificar o topo da pilha \\(M\\) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(M \\rightarrow N\\). Substituir \\(M\\) por \\(N\\).\nO próximo passo é verificar o topo da pilha \\(N\\) e o próximo símbolo de entrada (‘id’).\nA Tabela indica \\(N \\rightarrow id\\). Substituir \\(N\\) por ‘id’.\nConsumir ‘id’ da entrada e da pilha, pois eles coincidem.\nConsumir ‘)’ da entrada e da pilha, pois eles coincidem.\nFinalmente, a pilha está vazia e a entrada foi completamente consumida.\n\nComo foi possível consumir toda a string de entrada id OR NOT id AND (id OR id)$ e esvaziar a pilha sem encontrar nenhum erro, a string id OR NOT id AND (id OR id) é de fato parte da linguagem definida e pode ser identificada por um parser \\(LL(1)\\).\nAté agora, o conjuntos \\(FIRST\\), \\(FOLLOW\\) E \\(NULLABLE\\), e a Tabela de Derivação, caíram do céu. Se você é corajoso, sério, destemido e acompanhou todos os passos dos dois últimos exemplos, entendeu como o algoritmo de um parser \\(LL(1)\\) deve funcionar. Se era isso que estava procurado, pode parar por aqui. Agora se quiser entender como são criados os conjuntos e a Tabela de Derivação, tome uma água, respire fundo e continue. Seu próximo passo será entender como criamos os conjuntos \\(FIRST\\) e \\(FOLLOW\\)",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Parsers LL(1): O Mundo da Análise Sintática</span>"
    ]
  },
  {
    "objectID": "first-follow.html",
    "href": "first-follow.html",
    "title": "3  Conjuntos FIRST e FOLLOW",
    "section": "",
    "text": "3.1 O Conjunto FIRST\nO conjunto \\(FIRST\\) de um símbolo não-terminal é o conjunto de todos os terminais que podem aparecer no início de qualquer string derivada desse símbolo, incluindo o símbolo vazio (\\(\\varepsilon\\)) se o não-terminal puder derivar a string vazia. Para os símbolos terminais, o elemento do conjunto \\(FIRST\\) será o próprio símbolo terminal.",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conjuntos FIRST e FOLLOW</span>"
    ]
  },
  {
    "objectID": "first-follow.html#o-conjunto-first",
    "href": "first-follow.html#o-conjunto-first",
    "title": "3  Conjuntos FIRST e FOLLOW",
    "section": "",
    "text": "3.1.1 Regras de Criação do Conjunto FIRST\nPara definir o conjunto \\(FIRST(X)\\) para todos os símbolos não-terminais \\(X\\) de uma gramática que esteja definida por um conjunto de regras de produção, podemos seguir os seguintes passos:\n\nPara símbolos terminais: o conjunto \\(FIRST\\) é o próprio símbolo terminal. Ou seja, se \\(a\\) é um terminal, então \\(FIRST(a) = {a}\\).\nPara um símbolo não-terminal \\(X\\): olhe para cada regra de produção \\(X \\rightarrow \\alpha\\) e siga as seguintes regras:\n\nSe \\(\\alpha\\) é um terminal, adicione \\(\\alpha\\) ao conjunto \\(FIRST(X)\\).\nSe \\(\\alpha\\) começa com um símbolo não-terminal \\(Y\\), adicione \\(FIRST(Y)\\) ao \\(FIRST(X)\\), exceto pelo símbolo de vazio \\((\\varepsilon\\)) se ele estiver presente.\nSe \\(\\alpha\\) consiste apenas em não-terminais e todos eles podem derivar em vazio (diretamente ou indiretamente), adicione \\(\\varepsilon\\) ao conjunto \\(FIRST(X)\\).\n\n\nO símbolo vazio \\(\\varepsilon\\) pertence ao conjunto FIRST(X) se, e somente se, \\(X\\) pode derivar a string vazia (diretamente ou indiretamente).\nRepita esses passos até que os conjuntos \\(FIRST\\) de todos os símbolos não-terminais não possam ser alterado.\n\n\n3.1.2 Exemplo 1: Criação de Conjuntos FIRST\nConsidere a gramática definida pelo seguinte conjunto de regras de produção:\n\\[\n\\begin{array}{cc}\n1. &S \\rightarrow aB \\vert  bA \\\\\n2. &A \\rightarrow c \\vert  d \\\\\n3. &B \\rightarrow e \\vert  f \\\\\n\\end{array}\n\\]\nEste conjunto de regras de produção permite criar:\n\n\n\nSímbolo\nFIRST\nExplicação\n\n\n\n\nS\n{a, b}\nS pode ser derivado em “aB” ou “bA”\n\n\nA\n{c, d}\nA pode ser derivado em “c” ou “d”\n\n\nB\n{e, f}\nB pode ser derivado em “e” ou “f”\n\n\n\nLogo: \\(FIRST =\\{(S,\\{a, b\\}),(A,\\{c, d\\}),(B,\\{e, f\\})\\}\\), um conjunto de tuplas.\nAgora que entendemos o algoritmo, podemos tentar criar um pseudocódigo para encontrar os elementos do conjunto \\(First\\).\n\n\n3.1.3 Algoritmo para calcular o conjunto FIRST\n## Algoritmo para calcular o conjunto FIRST para símbolos não-terminais\n\n# Entrada: Um conjunto de regras de produção P\n# Saída: Um dicionário FIRST, onde FIRST[X] é o conjunto FIRST do símbolo não-terminal X\n\nfunção calcular_FIRST(gramática):\n    FIRST = {}  # Inicializa o dicionário FIRST\n\n    # Passo 1: Inicialização para não-terminais\n    para cada símbolo não-terminal X na gramática:\n        FIRST[X] &lt;- {}\n\n    # Passo 2: Iteração para não-terminais\n    mudou = verdadeiro\n    enquanto mudou:\n        mudou = falso\n        para cada regra de produção X \\rightarrow Y1 Y2 ... Yn na gramática:\n            k = 0\n            adicionou_epsilon = verdadeiro\n            enquanto k &lt; n e adicionou_epsilon:\n                adicionou_epsilon = falso\n                Yk = Y[k]\n\n                # Se Yk é terminal, adicionar Yk ao FIRST[X]\n                se Yk é terminal:\n                    se Yk não está em FIRST[X]:\n                        adicionar Yk a FIRST[X]\n                        mudou = verdadeiro\n                # Se Yk é não-terminal, adicionar FIRST[Yk] ao FIRST[X], exceto \\varepsilon\n                senão:\n                    para cada símbolo t em FIRST[Yk]:\n                        se t != \"\\varepsilon\":\n                            se t não está em FIRST[X]:\n                                adicionar t a FIRST[X]\n                                mudou = verdadeiro\n                        senão:\n                            adicionou_epsilon = verdadeiro\n                k = k + 1\n\n            # Se todos os Y1, Y2, ..., Yn podem derivar \\varepsilon, adicionar \\varepsilon ao FIRST[X]\n            se k == n e adicionou_epsilon:\n                se \"\\varepsilon\" não está em FIRST[X]:\n                    adicionar \"\\varepsilon\" a FIRST[X]\n                    mudou = verdadeiro\n\n    retornar FIRST\nEste pseudocódigo, poderia ser criado em python com um código parecido com este:\ndef calcular_FIRST(producoes):\n    FIRST = {}\n\n    # Passo 1: Inicialização para não-terminais\n    # Identificamos todos os símbolos não-terminais presentes nas produções\n    nao_terminais = {regra.split('\\rightarrow')[0].strip() for regra in producoes}\n\n    # Inicializamos o conjunto FIRST de cada não-terminal como um conjunto vazio\n    for nao_terminal in nao_terminais:\n        FIRST[nao_terminal] = set()\n\n    mudou = True\n    # O loop continua até que não haja mais mudanças nos conjuntos FIRST\n    while mudou:\n        mudou = False\n        # Iteramos por todas as produções da gramática\n        for producao in producoes:\n            partes = producao.split('\\rightarrow')\n            X = partes[0].strip()  # Não-terminal do lado esquerdo da produção\n            Y = partes[1].strip().split()  # Lista de símbolos do lado direito da produção\n\n            k = 0\n            adicionou_epsilon = True  # Flag para controlar a adição de \\varepsilon\n            # Iteramos sobre os símbolos do lado direito da produção\n            while k &lt; len(Y) and adicionou_epsilon:\n                adicionou_epsilon = False\n                Yk = Y[k]\n\n                # Se Yk é um não-terminal, adicionamos seus FIRST ao FIRST de X\n                if Yk in nao_terminais:\n                    for simbolo in FIRST[Yk]:\n                        if simbolo != \"\\varepsilon\":\n                            if simbolo not in FIRST[X]:\n                                FIRST[X].add(simbolo)\n                                mudou = True\n                        else:\n                            adicionou_epsilon = True\n                else:\n                    # Se Yk é um terminal, adicionamos Yk ao FIRST de X\n                    if Yk not in FIRST[X]:\n                        FIRST[X].add(Yk)\n                        mudou = True\n                    adicionou_epsilon = False  # Paramos de adicionar se encontramos um terminal\n                k += 1\n\n            # Se todos os símbolos Y1, Y2, ..., Yn podem derivar \\varepsilon, adicionamos \\varepsilon ao FIRST de X\n            if k == len(Y) and adicionou_epsilon:\n                if \"\\varepsilon\" not in FIRST[X]:\n                    FIRST[X].add(\"\\varepsilon\")\n                    mudou = True\n\n    return FIRST\n\n# Exemplo de uso\nproducoes = [\n    \"S \\rightarrow a B\",\n    \"S \\rightarrow b A\",\n    \"A \\rightarrow c\",\n    \"A \\rightarrow d\",\n    \"B \\rightarrow e\",\n    \"B \\rightarrow f\"\n]\n\nFIRST = calcular_FIRST(producoes)\nfor nao_terminal in FIRST:\n    print(f\"FIRST({nao_terminal}) = {FIRST[nao_terminal]}\")",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conjuntos FIRST e FOLLOW</span>"
    ]
  },
  {
    "objectID": "first-follow.html#o-conjunto-follow",
    "href": "first-follow.html#o-conjunto-follow",
    "title": "3  Conjuntos FIRST e FOLLOW",
    "section": "3.2 O Conjunto FOLLOW",
    "text": "3.2 O Conjunto FOLLOW\nO conjunto \\(FOLLOW\\) de um símbolo não-terminal é o conjunto de terminais que podem aparecer imediatamente à direita (após, follow) desse não-terminal em alguma forma sentencial derivada, ou o símbolo de fim de entrada ($) se o não-terminal puder aparecer no final de uma forma sentencial.\nPara definir o conjunto \\(FOLLOW(A)\\) para cada não-terminal \\(A\\), siga estes passos:\n\nColoque o símbolo de fim de entrada \\((\\$)\\) no \\(FOLLOW\\) do símbolo inicial da gramática. Ao colocar o símbolo de fim de entrada ($) no \\(FOLLOW\\) do símbolo inicial da gramática, garantimos que o analisador sintático reconheça a última derivação da gramática como válida. Isso significa que o analisador estará preparado para encontrar o símbolo (\\(\\$\\)) ao final da string de entrada, indicando que a análise foi concluída com sucesso. Em outras palavras, o símbolo (\\(\\$\\)) no \\(FOLLOW\\) do símbolo inicial representa a expectativa de que a string de entrada seja completamente processada e que não existam símbolos após a última derivada.\nPara cada produção da forma \\(A \\rightarrow \\alpha B \\beta\\), onde \\(B\\) é um não-terminal:\n\n\nSe \\(\\beta\\) não deriva \\(\\varepsilon\\) (a string vazia), adicione \\(FIRST(\\beta)\\) (sem \\(\\varepsilon\\)) a \\(FOLLOW(B)\\).\nSe \\(\\beta\\) deriva \\(\\varepsilon\\) (a string vazia) ou \\(\\beta\\) é a string vazia, adicione \\(FOLLOW(A)\\) a \\(FOLLOW(B)\\).\n\nRepita esses passos até que os conjuntos \\(FOLLOW\\) de todos os símbolos não-terminais não mudem mais.\nExemplo: Considere a gramática definida por:\n\\[\n\\begin{array}{cc}\n1. & S \\rightarrow aB \\vert  bA \\\\\n2. & A \\rightarrow c \\vert  d \\\\\n3. & B \\rightarrow e \\vert  f \\\\\n\\end{array}\n\\]\nConjunto FIRST:\n\n\\(FIRST(S) = \\{a, b\\}\\) (S pode derivar em \\(aB\\) ou \\(bA\\))\n\\(FIRST(A) = \\{c, d\\}\\) (A pode derivar em \\(c\\) ou \\(d\\))\n\\(FIRST(B) = \\{e, f\\}\\) (B pode derivar em \\(e\\) ou \\(f\\))\n\nConjunto FOLLOW:\n\n\\(FOLLOW(S) = \\{\\$\\}\\) (\\(S\\) é o símbolo inicial)\n\\(FOLLOW(A) = \\{\\$, c, d\\}\\)\n\nA aparece em: \\(S \\to bA\\)\nComo não há nada após \\(A\\) na produção acima, adicionamos \\(FOLLOW(S)\\) a \\(FOLLOW(A)\\): \\(\\{\\$\\}\\)\nAlém disso, como \\(A\\) aparece após \\(b\\) na produção \\(S \\to bA\\), e \\(B\\) pode derivar em \\(c\\) ou \\(d\\) (\\(B \\to c \\vert  d\\)), então \\(c\\) e \\(d\\) também podem seguir \\(A\\).\n\n\\(FOLLOW(B) = \\{\\$\\}\\)\n\n\\(B\\) aparece em: \\(S \\rightarrow aB\\)\nComo não há nada após \\(B\\) na produção acima, adicionamos \\(FOLLOW(S)\\) a \\(FOLLOW(B)\\): \\(\\{\\$\\}\\)\n\n\nCriamos o conjunto \\(FIRST\\) porque este é necessário para a criação do conjunto \\(FOLLOW\\). Mas, neste momento nos interessa apenas o conjunto \\(FOLLOW\\). O conjunto resultante será:\n\n\n\n\n\n\n\n\nSímbolo\nFOLLOW\nExplicação\n\n\n\n\n\\(S\\)\n\\(\\{ \\$ \\}\\)\n\\(S\\) é o símbolo inicial, então \\(\\$\\) é o único terminal que pode aparecer à direita de \\(S\\) em uma forma sentencial derivada.\n\n\nA\n\\(\\{ \\$, c, d \\}\\)\n\\(A\\) pode ser seguido por \\(c\\) na regra \\(A \\to c\\), \\(d\\) na regra \\(A \\to d\\), ou pelo símbolo de fim de entrada \\(\\$\\) em regras que contêm \\(A\\).\n\n\n\\(B\\)\n\\(\\{ a, c, d, \\$ \\}\\)\n\\(B\\) pode ser seguido por \\(a\\) na regra \\(S \\to aB\\), \\(c\\) na regra \\(A \\to cB\\), \\(d\\) na regra \\(A \\to dB\\), ou pelo símbolo de fim de entrada \\(\\$\\) em regras que contêm \\(B\\).",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conjuntos FIRST e FOLLOW</span>"
    ]
  },
  {
    "objectID": "first-follow.html#algoritmo-para-calcular-o-conjunto-follow",
    "href": "first-follow.html#algoritmo-para-calcular-o-conjunto-follow",
    "title": "3  Conjuntos FIRST e FOLLOW",
    "section": "3.3 Algoritmo para calcular o conjunto FOLLOW",
    "text": "3.3 Algoritmo para calcular o conjunto FOLLOW\nAssim como fizemos com o \\(FIRST\\) podemos criar um algoritmo para criar o conjunto \\(FOLLOW\\):\n# Entrada: Um conjunto de regras de produção P e o símbolo inicial S\n# Saída: Um dicionário FOLLOW, onde FOLLOW[X] é o conjunto FOLLOW do símbolo não-terminal X\n\nfunção calcular_FOLLOW(producoes, simbolo_inicial):\n    FOLLOW = {}  # Inicializa o dicionário FOLLOW\n\n    # Passo 1: Inicialização para todos os não-terminais\n    para cada símbolo não-terminal X na gramática:\n        FOLLOW[X] &lt;- {}\n\n    # Passo 2: Colocar o símbolo de fim de entrada ($) no FOLLOW do símbolo inicial\n    FOLLOW[simbolo_inicial] &lt;- {$}\n\n    # Passo 3: Iteração para todos os não-terminais\n    mudou = verdadeiro\n    enquanto mudou:\n        mudou = falso\n        para cada regra de produção A \\rightarrow \\alpha na gramática:\n            \\alpha = \\alpha.split()  # Divide a produção em símbolos individuais\n            para cada símbolo B na produção \\alpha:\n                se B é um não-terminal:\n                    # Verifica os símbolos após B na produção\n                    para cada símbolo após B na produção:\n                        se o símbolo é terminal:\n                            se símbolo não está em FOLLOW[B]:\n                                adicionar símbolo a FOLLOW[B]\n                                mudou = verdadeiro\n                            pare\n                        senão:\n                            para cada símbolo t em FIRST[símbolo]:\n                                se t != \"\\varepsilon\":\n                                    se t não está em FOLLOW[B]:\n                                        adicionar t a FOLLOW[B]\n                                        mudou = verdadeiro\n                            se \"\\varepsilon\" não está em FIRST[símbolo]:\n                                pare\n                    # Se não há mais símbolos após B ou todos podem derivar \\varepsilon\n                    se não há mais símbolos após B ou todos podem derivar \\varepsilon:\n                        para cada símbolo t em FOLLOW[A]:\n                            se t não está em FOLLOW[B]:\n                                adicionar t a FOLLOW[B]\n                                mudou = verdadeiro\n\n    retornar FOLLOW\nAgora que temos um pseudo código, podemos partir para o código em Python, para isso é preciso lembrar que vamos precisar do conjunto \\(FIRST\\) para encontrar o conjunto \\(FOLLOW\\).\ndef calcular_FIRST(producoes):\n    FIRST = {}\n\n    # Passo 1: Inicialização para não-terminais\n    nao_terminais = {regra.split('\\rightarrow')[0].strip() for regra in producoes}\n    for nao_terminal in nao_terminais:\n        FIRST[nao_terminal] = set()\n\n    mudou = True\n    while mudou:\n        mudou = False\n        for producao in producoes:\n            partes = producao.split('\\rightarrow')\n            X = partes[0].strip()\n            Y = partes[1].strip().split()\n\n            k = 0\n            adicionou_epsilon = True\n            while k &lt; len(Y) and adicionou_epsilon:\n                adicionou_epsilon = False\n                Yk = Y[k]\n\n                if Yk in nao_terminais:\n                    for simbolo in FIRST[Yk]:\n                        if simbolo != \"\\varepsilon\":\n                            if simbolo not in FIRST[X]:\n                                FIRST[X].add(simbolo)\n                                mudou = True\n                        else:\n                            adicionou_epsilon = True\n                else:\n                    if Yk not in FIRST[X]:\n                        FIRST[X].add(Yk)\n                        mudou = True\n                    adicionou_epsilon = False\n                k += 1\n\n            if k == len(Y) and adicionou_epsilon:\n                if \"\\varepsilon\" not in FIRST[X]:\n                    FIRST[X].add(\"\\varepsilon\")\n                    mudou = True\n\n    return FIRST\n\ndef calcular_FOLLOW(producoes, simbolo_inicial):\n    FIRST = calcular_FIRST(producoes)  # Calcula o conjunto FIRST necessário para FOLLOW\n    FOLLOW = {}\n\n    # Inicializa FOLLOW para todos os não-terminais\n    nao_terminais = {regra.split('\\rightarrow')[0].strip() for regra in producoes}\n    for nao_terminal in nao_terminais:\n        FOLLOW[nao_terminal] = set()\n\n    # Passo 2: Colocar o símbolo de fim de entrada ($) no FOLLOW do símbolo inicial\n    FOLLOW[simbolo_inicial].add('$')\n\n    # Passo 3: Iteração para todos os não-terminais\n    mudou = True  # Flag para controlar se houve mudanças nos conjuntos FOLLOW\n    while mudou:\n        mudou = False  # Inicializa a flag como False no início de cada iteração\n        for producao in producoes:  # Para cada produção na gramática\n            partes = producao.split('\\rightarrow')\n            A = partes[0].strip()  # Não-terminal do lado esquerdo da produção\n            alfa = partes[1].strip().split()  # Símbolos do lado direito da produção\n\n            for i in range(len(alfa)):\n                B = alfa[i]  # Símbolo atual na produção\n                if B in nao_terminais:  # Se B é um não-terminal\n                    beta = alfa[i+1:]  # Símbolos após B na produção\n                    if beta:  # Se há símbolos após B\n                        # Calcula FIRST(beta) e adiciona ao FOLLOW(B) exceto por \\varepsilon\n                        for simbolo in calcular_FIRST(['temp \\rightarrow ' + ' '.join(beta)]).get('temp', []):\n                            if simbolo != '\\varepsilon' and simbolo not in FOLLOW[B]:\n                                FOLLOW[B].add(simbolo)\n                                mudou = True\n                        # Se FIRST(beta) contém \\varepsilon, adiciona FOLLOW(A) ao FOLLOW(B)\n                        if '\\varepsilon' in calcular_FIRST(['temp \\rightarrow ' + ' '.join(beta)]).get('temp', []):\n                            for simbolo in FOLLOW[A]:\n                                if simbolo not in FOLLOW[B]:\n                                    FOLLOW[B].add(simbolo)\n                                    mudou = True\n                    else:  # Se não há símbolos após B\n                        # Adiciona FOLLOW(A) ao FOLLOW(B) diretamente\n                        for simbolo in FOLLOW[A]:\n                            if simbolo not in FOLLOW[B]:\n                                FOLLOW[B].add(simbolo)\n                                mudou = True\n    return FOLLOW\n\n# Exemplo de uso\nproducoes = [\n    \"S \\rightarrow a B\",\n    \"S \\rightarrow b A\",\n    \"A \\rightarrow c\",\n    \"A \\rightarrow d\",\n    \"B \\rightarrow e\",\n    \"B \\rightarrow f\"\n]\nsimbolo_inicial = \"S\"\n\nFOLLOW = calcular_FOLLOW(producoes, simbolo_inicial)\nfor nao_terminal in FOLLOW:\n    print(f\"FOLLOW({nao_terminal}) = {FOLLOW[nao_terminal]}\")",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Conjuntos FIRST e FOLLOW</span>"
    ]
  },
  {
    "objectID": "tabela-derivacao.html",
    "href": "tabela-derivacao.html",
    "title": "4  Tabelas de Derivação (Análise) LL(1)",
    "section": "",
    "text": "4.1 Conflitos na Tabela de Derivação\nConflitos na Tabela de Derivação \\(LL(1)\\) ocorrem quando há mais de uma regra de produção associada a um mesmo par indicador (terminal, não-terminal). Esta ambiguidade significa que, ao encontrar esse par, o parser \\(LL(1)\\) não conseguirá determinar, de forma única e inequívoca, qual regra deverá aplicar a um determinado símbolo de entrada, tornando a gramática ambígua e inadequada para uso com parsers \\(LL(1)\\).\nExemplo 2: o conflito. Observe que gramática a seguir foi criada para criar um conflito na Tabela de Derivação. Antes de nos preocuparmos com os tipos de conflito, e como solucioná-los, vamos rever todo o processo de criação de uma Tabela de Derivação para entender o problema.\n\\[\n\\begin{aligned}\n1. &\\ E \\rightarrow T + E \\ \\vert  \\ T \\\\\n2. &\\ T \\rightarrow int \\ \\vert  \\ (E)\n\\end{aligned}\n\\]",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tabelas de Derivação (Análise) LL(1)</span>"
    ]
  },
  {
    "objectID": "tabela-derivacao.html#conflitos-na-tabela-de-derivação",
    "href": "tabela-derivacao.html#conflitos-na-tabela-de-derivação",
    "title": "4  Tabelas de Derivação (Análise) LL(1)",
    "section": "",
    "text": "4.1.1 Conjunto FIRST\n\nPara o não-terminal E:\n\n\\(E \\rightarrow T + E\\): o primeiro símbolo é \\(T\\). Portanto, incluímos \\(FIRST(T)\\) em \\(FIRST(E)\\).\n\\(E \\rightarrow T\\): o primeiro símbolo é \\(T\\). Portanto, incluímos \\(FIRST(T)\\) em \\(FIRST(E)\\).\n\nPara o não-terminal T:\n\n\\(T \\rightarrow int\\): o primeiro símbolo é \\(int\\). Portanto, \\(FIRST(T)\\) inclui \\(int\\).\n\\(T \\rightarrow (E)\\): o primeiro símbolo é $( $. Portanto, \\(FIRST(T)\\) inclui $( $.\n\n\nAssim, temos:\n\\[\n\\begin{aligned}\nFIRST(T) &= \\{ int, ( \\} \\\\\nFIRST(E) &= FIRST(T) = \\{ int, ( \\}\n\\end{aligned}\n\\]\n\n\n4.1.2 Conjunto FOLLOW\n\nPara o símbolo inicial E:\n\n\\(FOLLOW(E)\\) inclui $.\n\nPara as produções de E:\n\n\\(E \\rightarrow T + E\\):\n\no símbolo \\(T\\) pode ser seguido por \\(+\\), então \\(+\\) está em \\(FOLLOW(T)\\).\no símbolo \\(E\\) é o último da produção, então \\(FOLLOW(E)\\) inclui \\(FOLLOW(E)\\).\n\n\\(E \\rightarrow T\\): o símbolo \\(T\\) é o último da produção, então \\(FOLLOW(T)\\) inclui \\(FOLLOW(E)\\).\n\nPara as produções de T:\n\n\\(T \\rightarrow int\\): \\(int\\) é um terminal, não influencia \\(FOLLOW\\).\n\\(T \\rightarrow (E)\\): \\(E\\) pode ser seguido por \\()\\), então \\(FOLLOW(E)\\) inclui \\()\\).\n\n\nAssim, teremos:\n\\[\n\\begin{aligned}\nFOLLOW(E) &= \\{ \\$, +, ) \\} \\\\\nFOLLOW(T) &= \\{ +, \\$, ) \\}\n\\end{aligned}\n\\]\n\n\n4.1.3 Nullable\nPara determinar se algum não-terminal é nullable, verificamos se ele pode derivar a string vazia \\(\\epsilon\\).\n\nPara E:\n\n\\(E \\rightarrow T + E\\): \\(T\\) não é nullable, portanto, \\(E\\) não é nullable a partir desta produção.\n\\(E \\rightarrow T\\): \\(T\\) não é nullable, portanto, \\(E\\) não é nullable.\n\nPara T:\n\n\\(T \\rightarrow int\\): \\(int\\) não é nullable.\n\\(T \\rightarrow (E)\\): \\(E\\) não é nullable e \\((\\) é um terminal.\n\n\nOu seja, nenhum dos não-terminais é nullable:\n\\[\n\\begin{aligned}\nNullable(E) &= false \\\\\nNullable(T) &= false\n\\end{aligned}\n\\]\n\n\n4.1.4 Resumo dos Conjuntos\n\\[\n\\begin{aligned}\nFIRST(E) &= \\{ int, ( \\} \\\\\nFIRST(T) &= \\{ int, ( \\} \\\\\nFOLLOW(E) &= \\{ \\$, +, ) \\} \\\\\nFOLLOW(T) &= \\{ +, \\$, ) \\} \\\\\nNullable(E) &= false \\\\\nNullable(T) &= false\n\\end{aligned}\n\\]\nO que permite gerar a seguinte Tabela de Derivação:\n\n\n\n\n\n\n\n\n\n\n\nnão-terminal\nint\n(\n+\n$\n)\n\n\n\n\nE\n\\(E \\to T + E\\)\\(E \\to T\\)\n\\(E \\to T + E\\)\\(E \\to T\\)\n\n\n\n\n\nT\n\\(T \\to int\\)\n\\(T \\to (E)\\)\n\n\n\n\n\n\nNesta tabela podemos ver um conflito explícito. O não-terminal \\(E\\) possui duas produções para os símbolos \\(int\\) e \\((\\).\nSempre que na criação de Tabelas de Derivação existir um conflito estaremos gerando ambiguidades na derivação. A gramática é ambígua, sempre que uma sentença puder ser derivada de duas ou mais formas diferentes, gerando árvores sintáticas diferentes. Por exemplo, na gramática do Exemplo 2, a sentença \\(int + int\\) pode ser derivada tanto como \\(E → T → int\\) seguido de \\(E → T + E → int + int\\) quanto como \\(E → T + E → T + T → int + int\\).",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tabelas de Derivação (Análise) LL(1)</span>"
    ]
  },
  {
    "objectID": "tabela-derivacao.html#tipos-de-conflitos",
    "href": "tabela-derivacao.html#tipos-de-conflitos",
    "title": "4  Tabelas de Derivação (Análise) LL(1)",
    "section": "4.2 Tipos de Conflitos",
    "text": "4.2 Tipos de Conflitos\nConflitos na tabela \\(LL(1)\\) podem ser classificados em dois tipos principais:\n\nConflito \\(FIRST\\)/\\(FIRST\\): ocorre quando o conjunto \\(FIRST\\) de duas ou mais produções de um mesmo não-terminal possui um terminal em comum. Na gramática do Exemplo 2, as produções \\(E \\to T + E\\) e \\(E \\to T\\) possuem os terminais \\(int\\) e \\((\\) em seus conjuntos \\(FIRST\\). Ao encontrar \\(int\\) ou \\((\\) na entrada, o parser não sabe se deve aplicar a regra que deriva uma expressão com um operador \\(+\\) ou a regra que deriva um termo. Neste momento do processo de parsing determinismo saiu pela janela e o parser \\(LL(1)\\) é inútil.\nConflito \\(FIRST\\)/\\(FOLLOW\\): ocorre quando uma produção tem \\(\\varepsilon\\) (a string vazia) em seu conjunto \\(FIRST\\) e o conjunto \\(FOLLOW\\) do não-terminal da produção possui um terminal em comum com o \\(FIRST\\) de outra produção do mesmo não-terminal. Por exemplo, na gramática do Exemplo 2, se \\(E \\rightarrow \\varepsilon\\) fosse uma produção e o conjunto \\(FOLLOW(E)\\) contivesse \\(+\\), que também está no \\(FIRST\\) da produção \\(E \\rightarrow T + E\\), ao encontrar o fim de uma expressão (representado por um símbolo em \\(FOLLOW(E)\\)), o parser não saberia se deve aplicar a regra que deriva apenas um termo ou a regra que deriva uma expressão com um operador \\(+\\).\n\n\n4.2.1 Resolução de Conflitos\nConflitos na tabela \\(LL(1)\\) podem ser resolvidos das seguintes formas:\n\nRefatoração da gramática: A gramática pode ser reescrita para eliminar ambiguidades e recursões à esquerda, evitando assim os conflitos.\nFatoração à esquerda: Produções com prefixos comuns podem ser fatoradas para que a decisão entre elas possa ser tomada com base em um único símbolo de lookahead.\nUso de analisadores mais poderosos: Se os conflitos não puderem ser resolvidos na gramática, pode ser necessário usar um analisador sintático mais poderoso, como um analisador \\(LR(1)\\) ou \\(LALR(1)\\), que conseguem lidar com gramáticas mais complexas.\n\nAs soluções 1 e 2 implicam na modificação da sua gramática, o que ocorre com frequência quando começamos do zero. A solução 3, em linguagens complexas, pode ser a solução adequada, mas implica em mudar de algoritmo de parser\nExemplo 3: resolução de conflito. No exemplo da gramática anterior, o conflito \\(FIRST\\)/\\(FIRST\\) pode ser resolvido fatorando as produções de \\(E\\):\n\\[\n\\begin{aligned}\n1. &\\ E \\rightarrow T E' \\\\\n2. &\\ E' \\rightarrow + E \\ \\vert  \\ \\epsilon \\\\\n3. &\\ T \\rightarrow int \\ \\vert  \\ (E)\n\\end{aligned}\n\\]\nSe calcularmos os conjuntos \\(FIRST\\) e \\(FOLLOW\\) novamente, teremos:\n\n\n4.2.2 Conjunto FIRST\n\nPara o não-terminal E:\n\n\\(E \\rightarrow T E'\\): o primeiro símbolo é \\(T\\). Portanto, incluímos \\(FIRST(T)\\) em \\(FIRST(E)\\).\n\nPara o não-terminal E’:\n\n\\(E' \\rightarrow + E\\): o primeiro símbolo é \\(+\\). Portanto, \\(FIRST(E')\\) inclui \\(+\\).\n\\(E' \\rightarrow \\epsilon\\): incluímos \\(\\epsilon\\) em \\(FIRST(E')\\).\n\nPara o não-terminal T:\n\n\\(T \\rightarrow int\\): o primeiro símbolo é \\(int\\). Portanto, \\(FIRST(T)\\) inclui \\(int\\).\n\\(T \\rightarrow (E)\\): o primeiro símbolo é $( $. Portanto, \\(FIRST(T)\\) inclui $( $.\n\n\nAssim, teremos:\n\\[\n\\begin{aligned}\nFIRST(T) &= \\{ int, ( \\} \\\\\nFIRST(E') &= \\{ +, \\epsilon \\} \\\\\nFIRST(E) &= FIRST(T) = \\{ int, ( \\}\n\\end{aligned}\n\\]\n\n\n4.2.3 Conjunto FOLLOW\n\nPara o símbolo inicial E:\n\n\\(FOLLOW(E)\\) inclui $.\n\nPara as produções de E:\n\n\\(E \\rightarrow T E'\\):\n\nO símbolo \\(E'\\) pode ser seguido por \\(FOLLOW(E)\\).\nEntão, \\(FOLLOW(E')\\) inclui \\(FOLLOW(E)\\).\n\n\nPara as produções de E’:\n\n\\(E' \\rightarrow + E\\):\n\nO símbolo \\(E\\) pode ser seguido por \\(FOLLOW(E')\\).\nEntão, \\(FOLLOW(E)\\) inclui \\(FOLLOW(E')\\).\n\n\\(E' \\rightarrow \\epsilon\\): não há efeito em \\(FOLLOW\\).\n\nPara as produções de T:\n\n\\(T \\rightarrow int\\): \\(int\\) é um terminal, não influencia \\(FOLLOW\\).\n\\(T \\rightarrow (E)\\): \\(E\\) pode ser seguido por \\()\\), então \\(FOLLOW(E)\\) inclui \\()\\).\n\n\nAssim, teremos:\n\\[\n\\begin{aligned}\nFOLLOW(E) &= \\{ \\$, ) \\} \\\\\nFOLLOW(E') &= \\{ \\$, ) \\} \\\\\nFOLLOW(T) &= \\{ +, \\$, ) \\}\n\\end{aligned}\n\\]\n\n\n4.2.4 Nullable\nPara determinar se algum não-terminal é nullable, verificamos se ele pode derivar a string vazia \\(\\epsilon\\).\n\nPara E:\n\n\\(E \\rightarrow T E'\\): \\(T\\) não é nullable, portanto, \\(E\\) não é nullable.\n\nPara E’:\n\n\\(E' \\rightarrow + E\\): \\(+\\) é um terminal, portanto, não é nullable.\n\\(E' \\rightarrow \\epsilon\\): \\(E'\\) é nullable.\n\nPara T:\n\n\\(T \\rightarrow int\\): \\(int\\) não é nullable.\n\\(T \\rightarrow (E)\\): $( $ é um terminal, portanto, não é nullable.\n\n\nAssim, teremos:\n\\[\n\\begin{aligned}\nNullable(E) &= false \\\\\nNullable(E') &= true \\\\\nNullable(T) &= false\n\\end{aligned}\n\\]\n\n\n4.2.5 Resumo dos Conjuntos\n\\[\n\\begin{aligned}\nFIRST(E) &= \\{ int, ( \\} \\\\\nFIRST(E') &= \\{ +, \\epsilon \\} \\\\\nFIRST(T) &= \\{ int, ( \\} \\\\\nFOLLOW(E) &= \\{ \\$, ) \\} \\\\\nFOLLOW(E') &= \\{ \\$, ) \\} \\\\\nFOLLOW(T) &= \\{ +, \\$, ) \\} \\\\\nNullable(E) &= false \\\\\nNullable(E') &= true \\\\\nNullable(T) &= false\n\\end{aligned}\n\\]\nO que permite gerar a seguinte Tabela de Derivação:\n\n\n\n\n\n\n\n\n\n\n\nnão-terminal\nint\n(\n+\n$\n)\n\n\n\n\nE\n\\(E \\to TE'\\)\n\\(E \\to TE'\\)\n\n\n\n\n\nE’\n\n\n\\(E' \\to +E\\)\n\\(E' \\to \\varepsilon\\)\n\\(E' \\to \\varepsilon\\)\n\n\nT\n\\(T \\to int\\)\n\\(T \\to (E)\\)\n\n\n\n\n\n\nAgora, a decisão entre derivar uma expressão com um operador \\(+\\) ou apenas um termo pode ser tomada com base no próximo símbolo da entrada: se for \\(+\\), aplica-se a regra \\(E' \\rightarrow + E\\); caso contrário, aplica-se a regra \\(E' \\rightarrow \\varepsilon\\).\nAssim como fiz nos artigos anteriores, vou sugerir um pseudocódigo, um tanto inocente, para a criação de tabelas de derivação. Acredito que, com um pouco de cuidado, depois que a amável leitora dominar esta técnica possa criar um pseudocódigo mais eficiente. A fé move montanhas.",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tabelas de Derivação (Análise) LL(1)</span>"
    ]
  },
  {
    "objectID": "tabela-derivacao.html#pseudocódigo-para-a-criação-da-tabela-de-derivação",
    "href": "tabela-derivacao.html#pseudocódigo-para-a-criação-da-tabela-de-derivação",
    "title": "4  Tabelas de Derivação (Análise) LL(1)",
    "section": "4.3 Pseudocódigo para a criação da Tabela de Derivação",
    "text": "4.3 Pseudocódigo para a criação da Tabela de Derivação\n**Entrada:**\n- Conjuntos de produções da gramática: `Productions`\n- Conjuntos FIRST: `First`\n- Conjuntos FOLLOW: `Follow`\n- Conjuntos Nullable: `Nullable`\n- Conjunto de não-terminais: `NonTerminals`\n- Conjunto de terminais: `Terminals`\n\n**Saída:**\n- Tabela de Derivação LL(1): `ParsingTable`\n\n# Inicialização da Tabela de Derivação LL(1)\nParsingTable = {A: {a: None for a in Terminals + ['$']} for A in NonTerminals}\n\n# Para cada produção A → α\nfor A, productions in Productions.items():\n    for α in productions:\n        # Para cada terminal a em FIRST(α)\n        for a in First[α]:\n            if a != 'ε':\n                # Adicionar a produção A → α na célula [A, a]\n                if ParsingTable[A][a] is None:\n                    ParsingTable[A][a] = A + \" → \" + α\n                else:\n                    raise ConflictError(f\"Conflito na tabela para [{A}, {a}]\")\n\n        # Se ε está em FIRST(α)\n        if 'ε' in First[α]:\n            # Para cada b em FOLLOW(A)\n            for b in Follow[A]:\n                # Adicionar a produção A → α na célula [A, b]\n                if ParsingTable[A][b] is None:\n                    ParsingTable[A][b] = A + \" → \" + α\n                else:\n                    raise ConflictError(f\"Conflito na tabela para [{A}, {b}]\")\n\n            # Se $ está em FOLLOW(A)\n            if '$' in Follow[A]:\n                # Adicionar a produção A → α na célula [A, $]\n                if ParsingTable[A]['$'] is None:\n                    ParsingTable[A]['$'] = A + \" → \" + α\n                else:\n                    raise ConflictError(f\"Conflito na tabela para [{A}, $]\")\n\n# Função para calcular FIRST de uma string\ndef compute_first(α):\n    if α == '':\n        return {'ε'}\n    first_set = set()\n    for symbol in α:\n        first_set.update(First[symbol] - {'ε'})\n        if 'ε' not in First[symbol]:\n            break\n    else:\n        first_set.add('ε')\n    return first_set\nCaramba! Só notei agora, eu praticamente escrevo em python quando estou fazendo pseudocódigos. Isto deve ser mal, muito mal… Acho que vou ficar sem sorvete hoje. Em fim, este código pode ser implementado em python por:\n# Conjuntos de produções\nproductions = {\n    'E': ['T+E', 'T'],\n    'T': ['int', '(E)']\n}\n\n# Conjuntos FIRST\nfirst = {\n    'E': {'int', '('},\n    'T': {'int', '('},\n    'T+E': {'int', '('},\n    'int': {'int'},\n    '(E)': {'('}\n}\n\n# Conjuntos FOLLOW\nfollow = {\n    'E': {'$', ')'},\n    'T': {'+', '$', ')'}\n}\n\n# Conjuntos Nullable\nnullable = {\n    'E': False,\n    'T': False\n}\n\n# Conjunto de não-terminais\nnon_terminals = ['E', 'T']\n\n# Conjunto de terminais\nterminals = ['int', '(', ')', '+', '$']\n\n# Inicialização da Tabela de Derivação LL(1)\nparsing_table = {A: {a: None for a in terminals} for A in non_terminals}\n\n# Função para calcular FIRST de uma string\ndef compute_first(α):\n    if α == '':\n        return {'ε'}\n    first_set = set()\n    i = 0\n    while i &lt; len(α):\n        symbol = α[i]\n        if symbol in first:\n            first_set.update(first[symbol] - {'ε'})\n            if 'ε' not in first[symbol]:\n                break\n        else:\n            # Adiciona todo o terminal se não for um não-terminal\n            terminal = ''\n            while i &lt; len(α) and (α[i].isalnum() or α[i] in ['_', '+', '(', ')']):\n                terminal += α[i]\n                i += 1\n            first_set.add(terminal)\n            if terminal in first and 'ε' in first[terminal]:\n                continue\n            break\n        i += 1\n    else:\n        first_set.add('ε')\n    return first_set\n\n# Preenchimento da Tabela de Derivação\nfor A in productions:\n    for α in productions[A]:\n        first_α = compute_first(α)\n\n        # Para cada terminal em FIRST(α)\n        for a in first_α:\n            if a != 'ε':\n                if a in parsing_table[A]:\n                    if parsing_table[A][a] is None:\n                        parsing_table[A][a] = f\"{A} → {α}\"\n                    else:\n                        print(f\"Conflito na tabela para [{A}, {a}]\")\n                else:\n                    print(f\"Terminal {a} não reconhecido na tabela\")\n\n        # Se ε está em FIRST(α)\n        if 'ε' in first_α:\n            for b in follow[A]:\n                if b in parsing_table[A]:\n                    if parsing_table[A][b] is None:\n                        parsing_table[A][b] = f\"{A} → {α}\"\n                    else:\n                        print(f\"Conflito na tabela para [{A}, {b}]\")\n                else:\n                    print(f\"Terminal {b} não reconhecido na tabela\")\n\n# Exibir a Tabela de Derivação de forma legível\nimport pandas as pd\n\n# Converte os valores None para strings vazias\nformatted_parsing_table = {A: {a: (parsing_table[A][a] if parsing_table[A][a] is not None else '') for a in terminals} for A in non_terminals}\n\n# Cria o DataFrame\ndf = pd.DataFrame(formatted_parsing_table).T\n\n# Reordena as colunas para incluir o símbolo de final de string '$'\ndf = df[terminals]\n\n# Calcula a largura máxima de cada coluna (incluindo o cabeçalho)\ncol_widths = {col: max(df[col].astype(str).str.len().max(), len(col)) for col in df.columns}\n\n# Estiliza o DataFrame para uma melhor visualização com bordas, linhas zebradas e ajuste de largura\nstyled_df = df.style.set_properties(**{'text-align': 'center', 'border': '1px solid black'}).set_table_styles(\n    [dict(selector='th', props=[('text-align', 'center'), ('border', '1px solid black')])]\n).set_caption(\"Tabela de Parsing LL(1)\")\n\n# Define o estilo das células vazias como cinza claro\nstyled_df.set_properties(subset=pd.IndexSlice[:, :], **{'background-color': 'lightgrey' if v == '' else '' for v in df.values.flatten()})\n\n# Adiciona o estilo zebrado\nstyled_df.set_table_styles([\n    {'selector': 'tbody tr:nth-child(even)', 'props': [('background-color', 'lightblue')]},\n    {'selector': 'tbody tr:nth-child(odd)', 'props': [('background-color', 'white')]}\n])\n\n# Ajusta a largura das colunas\nstyled_df.set_properties(subset=pd.IndexSlice[:, :], **{f'width': f'{col_widths[col]*8}px' for col in df.columns})\n\nfrom IPython.display import display\n\ndisplay(styled_df)",
    "crumbs": [
      "Autômatos e Gramáticas",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tabelas de Derivação (Análise) LL(1)</span>"
    ]
  },
  {
    "objectID": "fase1.html",
    "href": "fase1.html",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "",
    "text": "5.1 Objetivo\nPesquisar e praticar conceitos de analisador léxico para desenvolver um programa em Python, C, ou C++ que processe expressões aritméticas em notação polonesa reversa (RPN), conforme definida neste texto, a partir de um arquivo de texto, utilizando máquinas de estado finito (FSMs) implementadas obrigatoriamente com funções. O programa deve executar as expressões em um ambiente de teste (ex.: o notebook do aluno) e em um Arduino Uno, ou Mega. O seu trabalho será gerar o código Assembly, compatível com a arquitetura do Arduino Uno, ou Mega. Um guia de como compilar e executar o código Assembly está incluído na seção Chapter 6 no final deste documento.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#descrição-do-trabalho",
    "href": "fase1.html#descrição-do-trabalho",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "5.2 Descrição do Trabalho",
    "text": "5.2 Descrição do Trabalho\nO objetivo é desenvolver um programa capaz de:\n\nLer um arquivo de texto contendo expressões aritméticas em RPN, segundo o formato especificado neste documento, com uma expressão por linha. Este arquivo contém o código do programa que será analisado pelo analisador léxico.\nAnalisar as expressões usando um analisador léxico baseado em FSMs, com estados implementados por funções.\nTransformar as expressões em um texto contendo o código Assembly para o Arduino, utilizando as operações aritméticas e comandos especiais especificados. As operações serão realizadas no Arduino.\nExecutar as expressões em um Arduino Uno/Mega, de forma que os resultados possam ser acompanhados (display, leds ou serial).\nHospedar o código, arquivos de teste e documentação em um repositório público no GitHub.\n\n\n5.2.1 Características Especiais\nAs expressões devem ser escritas em notação RPN, no formato (A B op), no qual A e B são números reais e op é um operador aritmético. O programa deve suportar operações aritméticas básicas, comandos especiais para manipulação de memória, e deve ser capaz de lidar com expressões aninhadas. Segundo a seguinte sintaxe:\n\nA e B são números reais (usar ponto como separador decimal, ex.: 3.14).\nOperadores suportados na Fase 1:\n\nAdição: + (ex.: (A B +));\nSubtração: - (ex.: (A B -));\nMultiplicação: * (ex.: (A B *));\nDivisão real: / (ex.: (A B /));\nDivisão inteira: / (ex.: (A B /) para inteiros);\nResto da divisão inteira: % (ex.: (A B %));\nPotenciação: ^ (ex.: (A B ^), onde B é um inteiro positivo);\n\nTodas as operações (exceto divisão inteira e resto) usam números reais em formato de meia precisão (16 bits, IEEE 754), com duas casas decimais. A página Os desafios da norma IEEE 754 contém informações relevantes sobre a norma IEEE 754.\nExpressões podem ser aninhadas sem limite, por exemplo:\n\n(A (C D *) +): Soma A ao produto de C e D;\n((A B *) (D E *) /): Divide o produto de A e B pelo produto de D e E.\n((A B +) (C D *) /): Divide a soma de A e B pelo produto de C e D.\n\n\n\n\n5.2.2 Comandos Especiais\nA linguagem que estamos criando inclui comandos especiais para manipulação de memória e resultados:\n\n(N RES): Retorna o resultado da expressão N linhas anteriores (N é um inteiro não negativo).\n(V MEM): Armazena o valor real V em uma memória chamada MEM.\n(MEM): Retorna o valor armazenado em MEM. Se não inicializado, retorna \\(0.0\\).\nCada arquivo de texto, código fonte da linguagem que estamos criando, representa um escopo independente de memória.\nMEM pode ser qualquer conjunto de letras maiúsculas, tal como MEM, VAR, X, etc.\nRES é uma keyword da linguagem que estamos criando.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#analisador-léxico-com-fsm",
    "href": "fase1.html#analisador-léxico-com-fsm",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "5.3 Analisador Léxico com FSM",
    "text": "5.3 Analisador Léxico com FSM\n\nO analisador léxico deve ser implementado usando máquinas de estado finito (FSMs), com cada estado representado por uma função. Qualquer forma diferente de implementação provocará o zeramento do trabalho.\nO FSM deve reconhecer tokens válidos: números reais (duas casas decimais), operadores (+, -, *, /, %, ^), comandos especiais (RES, MEM), e parênteses.\nFunções de teste específicas devem ser criadas para validar o analisador léxico, cobrindo:\n\nEntradas válidas (ex.: (3.14 2.0 +), (5 RES), (10.5 CONTADOr));\nEntradas inválidas (ex.: (3.14 2.0 &), números malformados como 3.14.5, 3,45 ou parênteses desbalanceados).",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#arquivos-de-teste",
    "href": "fase1.html#arquivos-de-teste",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "5.4 Arquivos de Teste",
    "text": "5.4 Arquivos de Teste\n\nFornecer mínimo de 3 arquivos de texto, cada um com pelo menos 10 linhas de expressões RPN.\nCada arquivo deve incluir todas as operações (+, -, *, /, %, ^) e comandos especiais ((N RES), (V MEM), (MEM)).\nOs arquivos devem estar no mesmo diretório do código-fonte e ser processados via argumento de linha de comando (ex.: ./programa teste1.txt).\nO programa não deve incluir menu ou qualquer seleção interativa de arquivos.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#hospedagem-no-github",
    "href": "fase1.html#hospedagem-no-github",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "5.5 Hospedagem no GitHub",
    "text": "5.5 Hospedagem no GitHub\n\nO projeto deve ser hospedado em um repositório público no GitHub. Se o professor não indicar qual repositório deve ser usado, o repositório deve ser criado por um dos alunos do grupo.\nO repositório deve conter:\n\nCódigo-fonte do programa;\nArquivos de teste (mínimo 3);\nFunções de teste para o analisador léxico;\nÚltima versão do Código Assembly para Arduino gerado pelo programa;\nDocumentação (ex.: README.md) explicando como compilar, executar e testar o programa. Contendo o nome da instituição, disciplina, professor e nome dos alunos do grupo, em ordem alfabética seguido do usuário deste aluno no github.\n\nO repositório deve ser organizado com commits claros, as contribuições de cada um dos alunos devem estar registradas na forma de pull requests.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#requisitos-do-código",
    "href": "fase1.html#requisitos-do-código",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "5.6 Requisitos do Código",
    "text": "5.6 Requisitos do Código\n\nAs primeiras linhas do código devem conter:\n\nNomes dos integrantes do grupo, em ordem alfabética seguidos do usuário deste aluno no github.\nNome do grupo no ambiente virtual de aprendizagem (Canvas).\n\nO programa deve receber o nome do arquivo de teste como argumento na linha de comando.\nO código deve ser escrito em Python, C, ou C++. Com as funções nomeadas de acordo com o que está explicitado na Section 5.7.\nA última versão do código Assembly gerado para o Arduino deve ser funcional e incluído no repositório.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#sec-divisaoTarefas",
    "href": "fase1.html#sec-divisaoTarefas",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "5.7 Divisão de Tarefas para a Fase 1",
    "text": "5.7 Divisão de Tarefas para a Fase 1\nPara resolver o problema de processamento de expressões RPN, o trabalho será dividido entre até quatro alunos, trabalhando independentemente, na mesma sala, ou de forma remota. Cada aluno será responsável por uma parte específica do sistema, com interfaces claras para facilitar a integração. Abaixo está uma sugestão da divisão das tarefas, considerando as funções solicitadas: parseExpressao, executarExpressao, gerarAssembly, e exibirResultados.\n\n\n\n\n\n\nWarning\n\n\n\nNota: As tarefas podem ser divididas da forma que cada aluno achar mais conveniente, desde que as funções e interfaces sejam respeitadas.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nNota: O vetor de tokens deve ser salvo em txt para uso nas próximas fases do projeto. Cabe ao grupo decidir o formato que será usado para salvar os tokens. Apenas os tokens referentes a última execução do analisador léxico devem ser salvos.\n\n\n\n5.7.1 Aluno 1: Função parseExpressao e Analisador Léxico com FSM\nResponsabilidades:\n\nImplementar parseExpressao(std::string linha, std::vector&lt;std::string&gt;& _tokens_) (ou equivalente em Python/C) para analisar uma linha de expressão RPN e extrair tokens.\nImplementar o analisador léxico usando FSMs, com cada estado como uma função (ex.: estadoNumero, estadoOperador, estadoParenteses).\nValidar tokens:\n\nNúmeros reais (ex.: 3.14) usando ponto como separador decimal;\nOperadores (+, -, *, /, %, ^);\nComandos especiais (RES, MEM) e parênteses;\nDetectar erros como números malformados (ex.: 3.14.5), parênteses desbalanceados ou operadores inválidos;\n\nCriar funções de teste para o analisador léxico, cobrindo entradas válidas e inválidas.\n\nTarefas Específicas:\n\nEscrever parseExpressao para dividir a linha em tokens usando um FSM;\nValidar tokens (ex.: em C++: if (token.empty() || !isValidNumber(token)));\nTestar o FSM com entradas como (3.14 2.0 +), (5 RES), (3.14.5 2.0 +) (inválido);\nGarantir que o FSM lide com parênteses aninhados e comandos especiais.\n\nInterface:\n\nRecebe uma linha de texto e retorna um vetor de tokens;\nFornece tokens válidos para executarExpressao.\n\n\n\n5.7.2 Aluno 2: Função executarExpressao e Gerenciamento de Memória\nResponsabilidades:\n\nImplementar executarExpressao(const std::vector&lt;std::string&gt;& _tokens_, std::vector&lt;float&gt;& resultados, float& memoria) para executar uma expressão RPN;\nGerenciar a memória MEM para comandos (V MEM) e (MEM);\nManter um histórico de resultados para suportar (N RES);\nCriar funções de teste para validar a execução de expressões e comandos especiais.\n\nTarefas Específicas:\n\nUsar uma pilha para avaliar expressões RPN (ex.: em C++: std::stack&lt;float&gt;);\nImplementar operações (+, -, *, /, %, ^) com precisão de 16 bits (IEEE 754);\nTratar divisão inteira e resto separadamente;\nTestar com expressões como (3.14 2.0 +), ((1.5 2.0 *) (3.0 4.0 *) /), (5.0 MEM), (2 RES);\nVerificar erros como divisão por zero ou N inválido em (N RES).\n\nInterface:\n\nRecebe tokens de parseExpressao e atualiza resultados e memoria;\nFornece resultados para exibirResultados e Assembly.\n\n\n\n5.7.3 Aluno 3: Função gerarAssembly e Leitura de Arquivo\nResponsabilidades:\n\nImplementar gerarAssembly(const std::vector&lt;std::string&gt;& _tokens_, std::string& codigoAssembly) para gerar código Assembly para Arduino;\nImplementar lerArquivo(std::string nomeArquivo, std::vector&lt;std::string&gt;& linhas) para ler o arquivo de entrada;\nCriar funções de teste para validar a leitura de arquivos e a geração de Assembly;\nAlertar se o arquivo tiver linhas malformadas ou exceder limites.\n\nTarefas Específicas:\n\nLer o arquivo linha por linha, ignorando linhas vazias;\nGerar Assembly AVR para operações RPN e comandos especiais (usando registradores e instruções do ATmega328P/Mega);\nTestar com arquivos contendo 10+ linhas, incluindo expressões aninhadas e comandos especiais;\nVerificar erros de abertura de arquivo e exibir mensagens claras.\n\nInterface:\n\nlerArquivo fornece linhas para parseExpressao;\ngerarAssembly produz código Assembly para Arduino.\n\n\n\n5.7.4 Aluno 4: Função exibirResultados, Interface do Usuário e Testes\nResponsabilidades:\n\nImplementar exibirResultados(const std::vector&lt;float&gt;& resultados) para exibir os resultados das expressões;\nImplementar exibirMenu() e gerenciar a interface no main, incluindo leitura do argumento de linha de comando;\nCorrigir problemas de entrada (ex.: em C++: std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'));\nCriar funções de teste para validar a saída e o comportamento do programa completo.\n\nTarefas Específicas:\n\nExibir resultados com formato claro (ex.: uma casa decimal para números reais);\nImplementar o main para chamar lerArquivo, parseExpressao, executarExpressao, e exibirResultados;\nTestar com arquivos de teste fornecidos, verificando saídas para expressões simples e complexas;\nTestar o FSM com comandos especiais como (V MEM) e (MEM);\n\nInterface:\n\nUsa resultados de executarExpressao para exibir saídas;\nGerencia a execução do programa via argumento de linha de comando.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#considerações-para-integração",
    "href": "fase1.html#considerações-para-integração",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "5.8 Considerações para Integração",
    "text": "5.8 Considerações para Integração\n\nInterfaces: concordar com assinaturas das funções e formatos de dados (ex.: vetor de tokens, resultados em float);\nDepuração: testar cada parte isoladamente, simulando entradas/saídas;\nPassos de Integração:\n\nCopiar main e exibirMenu do Aluno 4;\nInserir lerArquivo e gerarAssembly do Aluno 3;\nAdicionar executarExpressao do Aluno 2;\nIncluir parseExpressao do Aluno 1;\n\nResolução de Conflitos: discutir problemas imediatamente na sala, ou de forma remota.\nDepuração Final: Testar o programa com os 3 arquivos de teste, verificando expressões, comandos especiais, e saída Assembly.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#avaliação",
    "href": "fase1.html#avaliação",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "5.9 Avaliação",
    "text": "5.9 Avaliação\nO trabalho será avaliado antes da prova de autoria, com os seguintes critérios: 1. Cálculos e Funcionalidades (70%):\n\nImplementação completa de todas as operações RPN e comandos especiais.\nCada operação não implementada reduz 10% dos 70%.\nFalha na divisão inteira reduz 50% dos 70%.\nAnalisador léxico com FSM funcional e testado.\n\n\nOrganização e Legibilidade do Código (15%):\n\nCódigo claro, comentado e bem estruturado.\nRepositório GitHub organizado, com README claro.\n\nRobustez (15%):\n\nTratamento de erros em expressões complexas e entradas inválidas.\nTestes do analisador léxico cobrindo todos os casos.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#prova-de-autoria",
    "href": "fase1.html#prova-de-autoria",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "5.10 Prova de Autoria",
    "text": "5.10 Prova de Autoria\n\nUm aluno do grupo será sorteado para responder uma pergunta em uma lista de 10 perguntas;\nFalha na resposta reduz 35% da nota obtida na Avaliação do Projeto.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#entrega",
    "href": "fase1.html#entrega",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "5.11 Entrega",
    "text": "5.11 Entrega\n\nO repositório GitHub deve conter:\n\nCódigo-fonte (Python, C, ou C++);\nTrês arquivos de teste com expressões RPN;\nFunções de teste para o analisador léxico;\nCódigo Assembly para Arduino da última execução do analisador léxico;\nArquivo de texto contendo os tokens gerados na última execução do analisador léxico;\nREADME com instruções de compilação, execução e testes;\n\nO programa deve ser executado com o comando ./programa nome_arquivo.cpp (ou equivalente).",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#toolchain-assembly-para-arduino-linha-de-comando",
    "href": "fase1.html#toolchain-assembly-para-arduino-linha-de-comando",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "6.1 Toolchain Assembly para Arduino (Linha de Comando)",
    "text": "6.1 Toolchain Assembly para Arduino (Linha de Comando)\nO conjunto de ferramentas (toolchain) padrão, gratuito e de código aberto para a arquitetura AVR (usada no Arduino Uno/Mega) é o AVR-GCC Toolchain e o AVRDUDE. Este guia mostra como compilar um arquivo Assembly (.s) e enviá-lo para a placa via linha de comando, sem usar a IDE do Arduino.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#ferramentas-necessárias",
    "href": "fase1.html#ferramentas-necessárias",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "6.2 1. Ferramentas Necessárias",
    "text": "6.2 1. Ferramentas Necessárias\nVocê precisa instalar:\n\navr-gcc: compilador/montador para AVR.\navr-libc: biblioteca C padrão para AVR (necessária mesmo em código assembly puro, pois fornece símbolos de inicialização como __do_copy_data, __do_clear_bss, etc.).\navrdude: programa de upload para o microcontrolador.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#instalação",
    "href": "fase1.html#instalação",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "6.3 2. Instalação",
    "text": "6.3 2. Instalação\n\n6.3.1 Linux (Debian/Ubuntu)\nsudo apt update\nsudo apt install gcc-avr binutils-avr avr-libc avrdude\n\nObservação: Para outras distribuições, use o gerenciador de pacotes correspondente (ex: dnf para Fedora ou pacman para Arch).\n\n\n\n6.3.2 Windows\n\n6.3.2.1 Opção 1: Microchip AVR-GCC Toolchain (Recomendado)\n\nFaça o download do “AVR 8-bit Toolchain” do site da Microchip.\nInstale o .exe e adicione a pasta bin da toolchain à variável de ambiente PATH (ex: C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\bin).\nInstale avrdude via Chocolatey ou Scoop:\nchoco install avrdude\n\n\n\n6.3.2.2 Opção 2: WSL (Windows Subsystem for Linux)\n\nInstale o WSL e uma distribuição Linux (ex: Ubuntu) via Microsoft Store.\nSiga as mesmas instruções de instalação para Linux dentro do ambiente WSL.",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#o-processo-de-compilação-e-upload",
    "href": "fase1.html#o-processo-de-compilação-e-upload",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "6.4 3. O Processo de Compilação e Upload",
    "text": "6.4 3. O Processo de Compilação e Upload\nAssumindo que você tenha um arquivo chamado meu_codigo.s.\n\n6.4.1 Passos Principais\n\nMontar e Linkar: Converter o código Assembly (.s) em um arquivo executável no formato ELF (.elf).\nExtrair o HEX: Converter o arquivo .elf para o formato Intel HEX (.hex).\nFazer o Upload: Enviar o arquivo .hex para a memória flash do Arduino usando avrdude.\n\n\n\n6.4.2 Exemplo Completo para Arduino UNO\n\n6.4.2.1 Informações do Hardware\n\nMCU: atmega328p\nProgramador: arduino\nBaud Rate: 115200\nPorta Serial: /dev/ttyACM0 (Linux) ou COM3 (Windows)\n\n# Nome do arquivo de entrada (sem extensão)\nFILENAME=meu_codigo\n\n# MCU e parâmetros do avrdude\nMCU=atmega328p\nAVRDUDE_PARTNO=m328p\nAVRDUDE_PROGRAMMER=arduino\nAVRDUDE_PORT=COM3 # Mude para sua porta. Ex: /dev/ttyACM0 no Linux\nAVRDUDE_BAUDRATE=115200\n\n# 1. Montar e Linkar (Assembly -&gt; ELF)\n# Usamos avr-gcc como front-end. Ele chamará o montador (avr-as) e o linker (avr-ld)\navr-gcc -mmcu=$MCU -o $FILENAME.elf $FILENAME.s\n\n# 2. Extrair o arquivo .hex (ELF -&gt; HEX)\n# -O ihex: formato de saída Intel HEX\n# -R .eeprom: remove a seção de dados da EEPROM do arquivo de saída\navr-objcopy -O ihex -R .eeprom $FILENAME.elf $FILENAME.hex\n\n# 3. Fazer o Upload para o Arduino UNO\navrdude -c $AVRDUDE_PROGRAMMER -p $AVRDUDE_PARTNO -P $AVRDUDE_PORT -b $AVRDUDE_BAUDRATE -U flash:w:$FILENAME.hex\n\n\n6.4.2.2 Exemplo Completo para Arduino MEGA\n\n\n\n6.4.3 Informações do Hardware:\n\nMCU: atmega2560\nProgramador: wiring\nBaud Rate: 115200\nPorta Serial: /dev/ttyACM0 (Linux) ou COM4 (Windows)\n\n# Nome do arquivo de entrada (sem extensão)\nFILENAME=meu_codigo_mega\n\n# MCU e parâmetros do avrdude\nMCU=atmega2560\nAVRDUDE_PARTNO=m2560\nAVRDUDE_PROGRAMMER=wiring\nAVRDUDE_PORT=COM4 # Mude para sua porta. Ex: /dev/ttyACM0 no Linux\nAVRDUDE_BAUDRATE=115200\n\n# 1. Montar e Linkar (Assembly -&gt; ELF)\navr-gcc -mmcu=$MCU -o $FILENAME.elf $FILENAME.s\n\n# 2. Extrair o arquivo .hex (ELF -&gt; HEX)\navr-objcopy -O ihex -R .eeprom $FILENAME.elf $FILENAME.hex\n\n# 3. Fazer o Upload para o Arduino MEGA\navrdude -c $AVRDUDE_PROGRAMMER -p $AVRDUDE_PARTNO -P $AVRDUDE_PORT -b $AVRDUDE_BAUDRATE -U flash:w:$FILENAME.hex",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  },
  {
    "objectID": "fase1.html#observações-importantes",
    "href": "fase1.html#observações-importantes",
    "title": "5  Fase 1 - Projeto Prático",
    "section": "6.5 Observações Importantes",
    "text": "6.5 Observações Importantes\n\nDiferença entre avr-gcc e avrdude:\n\navr-gcc usa -mmcu=atmega328p.\navrdude usa -p m328p.\n\nBootloader:\n\nPressione o botão Reset na placa antes de executar avrdude para garantir que o bootloader esteja ativo.\n\nExemplo Prático:\n\n// meu_codigo.s\n.device atmega328p\n.org 0x0000\nrjmp reset\n\nreset:\n    ldi r16, 0xFF\n    out 0x24, r16        ; DDRB = 0xFF (PB7..PB0 como saída)\n    ldi r16, 0x00\n    out 0x25, r16        ; PORTB = 0x00 (todos apagados)\n\nloop:\n    out 0x25, r16        ; PORTB = valor atual\n    ldi r16, 0x01\n    lsr r16              ; desloca bit para baixo\n    rjmp loop\nCompile e envie:\navr-gcc -mmcu=atmega328p -o led.elf led.s\navr-objcopy -O ihex -R .eeprom led.elf led.hex\navrdude -c arduino -p m328p -P COM3 -b 115200 -U flash:w:led.hex",
    "crumbs": [
      "Projeto da Disciplina",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Fase 1 - Projeto Prático</span>"
    ]
  }
]