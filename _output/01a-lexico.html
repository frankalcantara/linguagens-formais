<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Linguagens Formais e Autômatos - 3&nbsp; Alfabetos, Linguagens e Strings: Fundamentos Matemáticos</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./02-lexico.html" rel="next">
<link href="./01-lexico.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-lexico.html">Analisadores Léxicos</a></li><li class="breadcrumb-item"><a href="./01a-lexico.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Alfabetos, Linguagens e Strings: Fundamentos Matemáticos</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Linguagens Formais e Autômatos</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/linguagens-formais" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Disciplina de Linguagens Formais</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Analisadores Léxicos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Analisadores Léxicos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01a-lexico.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Alfabetos, Linguagens e Strings: Fundamentos Matemáticos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Autômatos Finitos Determinísticos</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Analisadores Sintáticos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./parsers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Parsers LL(1): O Mundo da Análise Sintática</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./first-follow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Conjuntos FIRST e FOLLOW</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./tabela-derivacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Tabelas de Derivação (Análise) LL(1)</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Projeto da Disciplina</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fase1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Fase 1 - Projeto Prático</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apend1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Apêndice 1: A Relação de Myhill-Nerode</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referências</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#alfabetos-os-blocos-fundamentais" id="toc-alfabetos-os-blocos-fundamentais" class="nav-link active" data-scroll-target="#alfabetos-os-blocos-fundamentais"><span class="header-section-number">3.1</span> Alfabetos: Os Blocos Fundamentais</a>
  <ul class="collapse">
  <li><a href="#exemplos-de-alfabetos" id="toc-exemplos-de-alfabetos" class="nav-link" data-scroll-target="#exemplos-de-alfabetos"><span class="header-section-number">3.1.1</span> Exemplos de Alfabetos</a></li>
  <li><a href="#propriedades-matemáticas-dos-alfabetos" id="toc-propriedades-matemáticas-dos-alfabetos" class="nav-link" data-scroll-target="#propriedades-matemáticas-dos-alfabetos"><span class="header-section-number">3.1.2</span> Propriedades Matemáticas dos Alfabetos</a></li>
  <li><a href="#sec-ex-alfabeto" id="toc-sec-ex-alfabeto" class="nav-link" data-scroll-target="#sec-ex-alfabeto"><span class="header-section-number">3.1.3</span> Exercícios 1</a></li>
  </ul></li>
  <li><a href="#strings-sequências-sobre-alfabetos" id="toc-strings-sequências-sobre-alfabetos" class="nav-link" data-scroll-target="#strings-sequências-sobre-alfabetos"><span class="header-section-number">3.2</span> Strings: Sequências Sobre Alfabetos</a>
  <ul class="collapse">
  <li><a href="#a-string-vazia" id="toc-a-string-vazia" class="nav-link" data-scroll-target="#a-string-vazia"><span class="header-section-number">3.2.1</span> A <em>string</em> Vazia</a></li>
  <li><a href="#operações-com-strings" id="toc-operações-com-strings" class="nav-link" data-scroll-target="#operações-com-strings"><span class="header-section-number">3.2.2</span> Operações com Strings</a></li>
  <li><a href="#substrings-prefixos-e-sufixos-entendendo-as-partes-de-uma-string" id="toc-substrings-prefixos-e-sufixos-entendendo-as-partes-de-uma-string" class="nav-link" data-scroll-target="#substrings-prefixos-e-sufixos-entendendo-as-partes-de-uma-string"><span class="header-section-number">3.2.3</span> Substrings, Prefixos e Sufixos: Entendendo as Partes de uma String</a></li>
  <li><a href="#sec-ex-strings" id="toc-sec-ex-strings" class="nav-link" data-scroll-target="#sec-ex-strings"><span class="header-section-number">3.2.4</span> Exercícios 2</a></li>
  </ul></li>
  <li><a href="#linguagens-conjuntos-de-strings" id="toc-linguagens-conjuntos-de-strings" class="nav-link" data-scroll-target="#linguagens-conjuntos-de-strings"><span class="header-section-number">3.3</span> Linguagens: Conjuntos de Strings</a>
  <ul class="collapse">
  <li><a href="#o-conjunto-universal-sigma" id="toc-o-conjunto-universal-sigma" class="nav-link" data-scroll-target="#o-conjunto-universal-sigma"><span class="header-section-number">3.3.1</span> O Conjunto Universal <span class="math inline">\(\Sigma^*\)</span></a></li>
  <li><a href="#exemplos-de-linguagens" id="toc-exemplos-de-linguagens" class="nav-link" data-scroll-target="#exemplos-de-linguagens"><span class="header-section-number">3.3.2</span> Exemplos de Linguagens</a></li>
  <li><a href="#operações-com-linguagens" id="toc-operações-com-linguagens" class="nav-link" data-scroll-target="#operações-com-linguagens"><span class="header-section-number">3.3.3</span> Operações com Linguagens</a></li>
  <li><a href="#as-leis-de-de-morgan-em-linguagens-regulares" id="toc-as-leis-de-de-morgan-em-linguagens-regulares" class="nav-link" data-scroll-target="#as-leis-de-de-morgan-em-linguagens-regulares"><span class="header-section-number">3.3.4</span> As Leis de De Morgan em Linguagens Regulares</a></li>
  <li><a href="#sec-ex-linguagens2" id="toc-sec-ex-linguagens2" class="nav-link" data-scroll-target="#sec-ex-linguagens2"><span class="header-section-number">3.3.5</span> Exercícios 3</a></li>
  </ul></li>
  <li><a href="#expressões-regulares-uma-notação-concisa" id="toc-expressões-regulares-uma-notação-concisa" class="nav-link" data-scroll-target="#expressões-regulares-uma-notação-concisa"><span class="header-section-number">3.4</span> Expressões Regulares: Uma Notação Concisa</a>
  <ul class="collapse">
  <li><a href="#definição-indutiva" id="toc-definição-indutiva" class="nav-link" data-scroll-target="#definição-indutiva"><span class="header-section-number">3.4.1</span> Definição Indutiva</a></li>
  <li><a href="#precedência-dos-operadores" id="toc-precedência-dos-operadores" class="nav-link" data-scroll-target="#precedência-dos-operadores"><span class="header-section-number">3.4.2</span> Precedência dos Operadores</a></li>
  <li><a href="#linguagem-denotada-por-uma-expressão-regular" id="toc-linguagem-denotada-por-uma-expressão-regular" class="nav-link" data-scroll-target="#linguagem-denotada-por-uma-expressão-regular"><span class="header-section-number">3.4.3</span> Linguagem Denotada por uma Expressão Regular</a></li>
  <li><a href="#exemplos-de-expressões-regulares" id="toc-exemplos-de-expressões-regulares" class="nav-link" data-scroll-target="#exemplos-de-expressões-regulares"><span class="header-section-number">3.4.4</span> Exemplos de Expressões Regulares</a></li>
  <li><a href="#equivalência-de-expressões-regulares-e-suas-leis-algébricas" id="toc-equivalência-de-expressões-regulares-e-suas-leis-algébricas" class="nav-link" data-scroll-target="#equivalência-de-expressões-regulares-e-suas-leis-algébricas"><span class="header-section-number">3.4.5</span> Equivalência de Expressões Regulares e suas Leis Algébricas</a></li>
  <li><a href="#notações-convencionais-adicionais" id="toc-notações-convencionais-adicionais" class="nav-link" data-scroll-target="#notações-convencionais-adicionais"><span class="header-section-number">3.4.6</span> Notações Convencionais Adicionais</a></li>
  <li><a href="#aplicações-práticas" id="toc-aplicações-práticas" class="nav-link" data-scroll-target="#aplicações-práticas"><span class="header-section-number">3.4.7</span> Aplicações Práticas</a></li>
  <li><a href="#sec-ex-regex5" id="toc-sec-ex-regex5" class="nav-link" data-scroll-target="#sec-ex-regex5"><span class="header-section-number">3.4.8</span> Exercícios 8</a></li>
  </ul></li>
  <li><a href="#o-lugar-das-linguagens-regulares-poder-e-limitações" id="toc-o-lugar-das-linguagens-regulares-poder-e-limitações" class="nav-link" data-scroll-target="#o-lugar-das-linguagens-regulares-poder-e-limitações"><span class="header-section-number">3.5</span> O Lugar das Linguagens Regulares: Poder e Limitações</a>
  <ul class="collapse">
  <li><a href="#a-essência-do-poder-simplicidade-e-previsibilidade" id="toc-a-essência-do-poder-simplicidade-e-previsibilidade" class="nav-link" data-scroll-target="#a-essência-do-poder-simplicidade-e-previsibilidade"><span class="header-section-number">3.5.1</span> A Essência do Poder: Simplicidade e Previsibilidade</a></li>
  <li><a href="#propriedades-fundamentais-das-linguagens-regulares" id="toc-propriedades-fundamentais-das-linguagens-regulares" class="nav-link" data-scroll-target="#propriedades-fundamentais-das-linguagens-regulares"><span class="header-section-number">3.5.2</span> Propriedades Fundamentais das Linguagens Regulares</a></li>
  <li><a href="#as-fronteiras-do-mundo-regular-o-limite-da-memória" id="toc-as-fronteiras-do-mundo-regular-o-limite-da-memória" class="nav-link" data-scroll-target="#as-fronteiras-do-mundo-regular-o-limite-da-memória"><span class="header-section-number">3.5.3</span> As Fronteiras do Mundo Regular: O Limite da Memória</a></li>
  <li><a href="#o-lema-do-bombeamento-uma-ferramenta-de-prova" id="toc-o-lema-do-bombeamento-uma-ferramenta-de-prova" class="nav-link" data-scroll-target="#o-lema-do-bombeamento-uma-ferramenta-de-prova"><span class="header-section-number">3.5.4</span> O Lema do Bombeamento: Uma Ferramenta de Prova</a></li>
  <li><a href="#exemplo-do-lema-do-bombeamento" id="toc-exemplo-do-lema-do-bombeamento" class="nav-link" data-scroll-target="#exemplo-do-lema-do-bombeamento"><span class="header-section-number">3.5.5</span> Exemplo do Lema do Bombeamento</a></li>
  </ul></li>
  <li><a href="#exercícios-desafiadores" id="toc-exercícios-desafiadores" class="nav-link" data-scroll-target="#exercícios-desafiadores"><span class="header-section-number">3.6</span> Exercícios Desafiadores</a>
  <ul class="collapse">
  <li><a href="#exercício-1" id="toc-exercício-1" class="nav-link" data-scroll-target="#exercício-1"><span class="header-section-number">3.6.1</span> Exercício 1:</a></li>
  </ul></li>
  <li><a href="#exercício-2" id="toc-exercício-2" class="nav-link" data-scroll-target="#exercício-2"><span class="header-section-number">3.7</span> Exercício 2:</a></li>
  <li><a href="#exercício-3" id="toc-exercício-3" class="nav-link" data-scroll-target="#exercício-3"><span class="header-section-number">3.8</span> Exercício 3:</a>
  <ul class="collapse">
  <li><a href="#exercício-4" id="toc-exercício-4" class="nav-link" data-scroll-target="#exercício-4"><span class="header-section-number">3.8.1</span> Exercício 4:</a></li>
  <li><a href="#exercício-5" id="toc-exercício-5" class="nav-link" data-scroll-target="#exercício-5"><span class="header-section-number">3.8.2</span> Exercício 5</a></li>
  </ul></li>
  <li><a href="#exercício-6-classes-de-equivalência" id="toc-exercício-6-classes-de-equivalência" class="nav-link" data-scroll-target="#exercício-6-classes-de-equivalência"><span class="header-section-number">3.9</span> Exercício 6: Classes de Equivalência</a>
  <ul class="collapse">
  <li><a href="#exercício-7-lema-do-bombeamento" id="toc-exercício-7-lema-do-bombeamento" class="nav-link" data-scroll-target="#exercício-7-lema-do-bombeamento"><span class="header-section-number">3.9.1</span> Exercício 7: Lema do Bombeamento</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/linguagens-formais/edit/main/01a-lexico.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linguagens-formais/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-lexico.html">Analisadores Léxicos</a></li><li class="breadcrumb-item"><a href="./01a-lexico.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Alfabetos, Linguagens e Strings: Fundamentos Matemáticos</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-alfabeto-linguagem-string" class="quarto-section-identifier"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Alfabetos, Linguagens e Strings: Fundamentos Matemáticos</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\01a-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>A teoria da computação repousa sobre fundamentos matemáticos que, embora abstratos, fornecem uma base precisa para a compreensão de como as máquinas processam informações. Entre estes fundamentos, os conceitos de <strong>alfabeto</strong>, <strong>linguagem</strong> e <strong><em>string</em></strong> ocupam uma posição central, formando a estrutura conceitual sobre a qual se ergue toda a teoria de linguagens formais e, consequentemente, a engenharia de compiladores.</p>
<p>Estes conceitos, aparentemente simples à primeira vista, revelam-se ferramentas matemáticas poderosas capazes de capturar a essência da comunicação entre humanos e máquinas. A curiosa leitora descobrirá que a formalização matemática destes conceitos elementares permite modelar desde a estrutura de uma palavra até a complexidade de uma linguagem de programação completa.</p>
<p>Neste capítulo, vamos explorar como a matemática dos conjuntos se entrelaça com a intuição linguística. Começaremos com os blocos mais básicos, os símbolos e alfabetos, progredindo por meio das <em>strings</em> e linguagens, até chegarmos às expressões regulares, uma notação concisa e poderosa para descrever conjuntos infinitos de <em>strings</em>.</p>
<section id="alfabetos-os-blocos-fundamentais" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="alfabetos-os-blocos-fundamentais"><span class="header-section-number">3.1</span> Alfabetos: Os Blocos Fundamentais</h2>
<p>Um <strong>alfabeto</strong> constitui o artefato fundamental da teoria de linguagens formais. Matematicamente, um alfabeto é um conjunto finito não-vazio de símbolos, denotado convencionalmente pela letra grega <span class="math inline">\(\Sigma\)</span>, o sigma maiúsculo. Neste contexto, um alfabeto será definido como:</p>
<p><span class="math display">\[\Sigma = \{a_1, a_2, \ldots, a_n\} \text{ tal que } |\Sigma| = n &lt; \infty \text{ e } n \geq 1\]</span></p>
<p>Como esse é o nosso primeiro contato a cuidadosa leitora deve observar que a definição elegante e formal de alfabeto pode ser decomposta em partes mais simples:</p>
<ul>
<li><span class="math inline">\(\Sigma = \{a_1, a_2, \ldots, a_n\}\)</span>: o alfabeto é um conjunto formado por <span class="math inline">\(n\)</span> símbolos distintos (<span class="math inline">\(a_1\)</span> até <span class="math inline">\(a_n\)</span>).</li>
<li><span class="math inline">\(|\Sigma| = n\)</span>: o tamanho do alfabeto (número de símbolos) é <span class="math inline">\(n\)</span>.</li>
<li><span class="math inline">\(n &lt; \infty\)</span>: o alfabeto é <strong>finito</strong> (não possui infinitos símbolos).</li>
<li><span class="math inline">\(n \geq 1\)</span>: o alfabeto é <strong>não vazio</strong>, ou seja, contém pelo menos um símbolo.</li>
</ul>
<p>A natureza dos símbolos que compõem um alfabeto é irrelevante para a teoria matemática subjacente. Um símbolo pode ser uma letra, um dígito, um caractere especial, ou qualquer entidade atômica que possa ser distinguida de outras. A única exigência é que os símbolos sejam mutuamente distintos e que o conjunto seja finito.</p>
<section id="exemplos-de-alfabetos" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="exemplos-de-alfabetos"><span class="header-section-number">3.1.1</span> Exemplos de Alfabetos</h3>
<p>A teoria ganha vida por meio de exemplos concretos. Considere os seguintes alfabetos frequentemente utilizados na ciência da computação:</p>
<ol type="1">
<li><p><strong>Alfabeto binário</strong>: <span class="math inline">\(\Sigma_{\text{bin}} = \{0, 1\}\)</span>. Este alfabeto fundamental aparece em representações binárias, lógica booleana e circuitos digitais. A cardinalidade deste alfabeto é <span class="math inline">\(|\Sigma_{\text{bin}}| = 2\)</span>.</p></li>
<li><p><strong>Alfabeto das letras minúsculas</strong>: <span class="math inline">\(\Sigma_{\text{abc}} = \{a, b, c, \ldots, z\}\)</span>. Usado para modelar identificadores em linguagens de programação e texto em linguagem natural. Sua cardinalidade é <span class="math inline">\(|\Sigma_{\text{abc}}| = 26\)</span>.</p></li>
<li><p><strong>Alfabeto para representação de números decimais</strong>: <span class="math inline">\(\Sigma_{\text{dec}} = \{+, -, ., 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}\)</span>. Fundamental para a representação de números em notação decimal. Incluindo números reais, positivos e negativos, considerando o símbolo ‘.’ como separador decimal. A cardinalidade é <span class="math inline">\(|\Sigma_{\text{dec}}| = 13\)</span>.</p></li>
<li><p><strong>Alfabeto ASCII para Expressões Aritméticas</strong>: <span class="math inline">\(\Sigma_{\text{arit}} = \{a, b, \ldots, z, 0, 1, \ldots, 9, +, -, *, /\}\)</span>. Este exemplo define um subconjunto concreto e útil do ASCII, adequado para modelar identificadores de uma única letra e operações aritméticas simples. O uso de <span class="math inline">\(\ldots\)</span> (elipses) aqui é uma notação concisa para representar todos os caracteres dentro de um intervalo sequencial bem definido, neste caso, as letras minúsculas de ‘a’ a ‘z’ e os dígitos de ‘0’ a ‘9’. Ao contrário de uma definição com uma cardinalidade ambígua, esta abordagem permite um cálculo exato do tamanho do alfabeto considerando letras = <span class="math inline">\({a, b, \ldots, z}\)</span> (26), dígitos = <span class="math inline">\({0, 1, \ldots, 9}\)</span> (10), operadores = <span class="math inline">\({+, -, *, /}\)</span> seria:</p></li>
</ol>
<p><span class="math display">\[|\Sigma_{\text{arit}}| = \text{(letras)} + \text{(dígitos)} + \text{(operadores)} = 26 + 10 + 4 = 40\]</span></p>
</section>
<section id="propriedades-matemáticas-dos-alfabetos" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="propriedades-matemáticas-dos-alfabetos"><span class="header-section-number">3.1.2</span> Propriedades Matemáticas dos Alfabetos</h3>
<p>A definição formal de alfabeto como conjunto finito implica que precisaremos considerar três propriedades importantes:</p>
<ol type="1">
<li><p><strong>Finitude</strong>: todo alfabeto possui um número finito de símbolos. Esta restrição não é uma limitação prática, mas sim uma necessidade teórica que garante a decidibilidade de muitos problemas computacionais. Decidibilidade, neste contexto, refere-se à capacidade de determinar se uma <em>string</em> pertence a uma linguagem definida sobre um alfabeto.</p></li>
<li><p><strong>Distinção</strong>: cada símbolo em um alfabeto é único e distinguível. Formalmente, se <span class="math inline">\(a, b \in \Sigma\)</span> e <span class="math inline">\(a \neq b\)</span>, então <span class="math inline">\(a\)</span> e <span class="math inline">\(b\)</span> são símbolos diferentes.</p></li>
<li><p><strong>Não-ordenação inerente</strong>: um alfabeto, sendo um conjunto matemático, não possui uma ordenação natural. Qualquer ordenação, como a ordem alfabética, é uma convenção externa imposta para conveniência.</p></li>
</ol>
</section>
<section id="sec-ex-alfabeto" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="sec-ex-alfabeto"><span class="header-section-number">3.1.3</span> Exercícios 1</h3>
<ol type="1">
<li><p>Determine a cardinalidade dos seguintes alfabetos:</p>
<ol type="a">
<li><span class="math inline">\(\Sigma_1 = \{a, b, c, +, -, *, /, (, )\}\)</span>;</li>
<li><span class="math inline">\(\Sigma_2 = \{0, 1, 2, \ldots, 9, A, B, C, D, E, F\}\)</span> (hexadecimal);</li>
<li><span class="math inline">\(\Sigma_3 = \{\text{verdadeiro}, \text{falso}, \land, \lor, \neg, (, )\}\)</span>.</li>
</ol></li>
<li><p>Construa alfabetos apropriados para os seguintes contextos:</p>
<ol type="a">
<li>Expressões lógicas booleanas simples com variáveis <span class="math inline">\(p\)</span>, <span class="math inline">\(q\)</span>, <span class="math inline">\(r\)</span>;</li>
<li>Números em notação científica (ex: <span class="math inline">\(1.23 \times 10^{-4}\)</span>);</li>
<li>Coordenadas cartesianas no formato <span class="math inline">\((x, y)\)</span>.</li>
</ol></li>
<li><p>Determine quais dos seguintes conjuntos são alfabetos válidos segundo a definição formal. Justifique sua resposta:</p>
<ol type="a">
<li><span class="math inline">\(A = \emptyset\)</span>;</li>
<li><span class="math inline">\(B = \{\epsilon\}\)</span>;</li>
<li><span class="math inline">\(C = \{1, 2, 3, \ldots\}\)</span>;</li>
<li><span class="math inline">\(D = \{a, b, a\}\)</span>.</li>
</ol></li>
<li><p>Dado o conjunto de <em>strings</em> <span class="math inline">\(S = \{\text{if}, \text{then}, \text{else}, \text{fi}\}\)</span>, determine o menor alfabeto <span class="math inline">\(\Sigma\)</span> tal que todas as <em>strings</em> em <span class="math inline">\(S\)</span> possam ser formadas usando símbolos de <span class="math inline">\(\Sigma\)</span>.</p></li>
<li><p>Compare os alfabetos <span class="math inline">\(\Sigma_A = \{0, 1\}\)</span> e <span class="math inline">\(\Sigma_B = \{a, b, c\}\)</span> em termos de:</p>
<ol type="a">
<li>Cardinalidade;</li>
<li>Número de <em>strings</em> de comprimento 3 que podem ser formadas;</li>
<li>Aplicabilidade para representar números binários.</li>
</ol></li>
</ol>
</section>
</section>
<section id="strings-sequências-sobre-alfabetos" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="strings-sequências-sobre-alfabetos"><span class="header-section-number">3.2</span> Strings: Sequências Sobre Alfabetos</h2>
<p>Uma <strong><em>string</em></strong> (ou <strong>cadeia</strong>) sobre um alfabeto <span class="math inline">\(\Sigma\)</span> é uma sequência finita de símbolos escolhidos de <span class="math inline">\(\Sigma\)</span>. Formalmente, uma <em>string</em> <span class="math inline">\(w\)</span> de comprimento <span class="math inline">\(n\)</span> pode ser representada como:</p>
<p><span class="math display">\[w = a_1a_2\ldots a_n \text{ tal que } a_i \in \Sigma \text{ para } i = 1, 2, \ldots, n\]</span></p>
<p>Na qual, temos:</p>
<ul>
<li><span class="math inline">\(w = a_1a_2\ldots a_n\)</span>: uma <strong><em>string</em></strong> <span class="math inline">\(w\)</span> é uma sequência finita de símbolos concatenados.</li>
<li><span class="math inline">\(a_i \in \Sigma \quad \text{para} \quad i = 1, 2, \ldots, n\)</span>: cada elemento <span class="math inline">\(a_i\)</span> na <em>string</em> pertence ao alfabeto <span class="math inline">\(\Sigma\)</span>.</li>
<li>A <em>string</em> possui comprimento <span class="math inline">\(|w| = n\)</span> (número de símbolos na sequência). Por exemplo, se <span class="math inline">\(w = abc\)</span>, então <span class="math inline">\(|w| = 3\)</span>.</li>
</ul>
<section id="a-string-vazia" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="a-string-vazia"><span class="header-section-number">3.2.1</span> A <em>string</em> Vazia</h3>
<p>Um caso especial é a <strong><em>string</em> vazia</strong>, denotada por <span class="math inline">\(\epsilon\)</span>, letra grega épsilon minúsculo. Esta <em>string</em> existe, não contém símbolos e possui comprimento zero:</p>
<p><span class="math display">\[\epsilon = \text{string vazia tal que } |\epsilon| = 0\]</span></p>
<p>A <em>string</em> vazia desempenha um papel análogo ao número zero na aritmética, servindo como elemento neutro para a operação de concatenação de <em>strings</em>.</p>
</section>
<section id="operações-com-strings" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="operações-com-strings"><span class="header-section-number">3.2.2</span> Operações com Strings</h3>
<p>Assim como a aritmética define operações como adição e multiplicação sobre o conjunto dos números, a teoria das linguagens formais estabelece operações para manipular e combinar <em>strings</em>. Essas operações formam uma espécie de álgebra sobre as <em>strings</em>, permitindo-nos construir sequências complexas a partir de componentes mais simples de maneira formal e precisa. A seguir, exploraremos as operações mais importantes, começando pela mais fundamental de todas, que serve como base para quase todas as outras: a <strong>concatenação</strong>.</p>
<section id="concatenação" class="level4" data-number="3.2.2.1">
<h4 data-number="3.2.2.1" class="anchored" data-anchor-id="concatenação"><span class="header-section-number">3.2.2.1</span> Concatenação</h4>
<p>A operação fundamental com <em>strings</em> é a <strong>concatenação</strong>. Para duas <em>strings</em> <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span>, a concatenação <span class="math inline">\(xy\)</span> é a <em>string</em> formada pela justaposição de <span class="math inline">\(x\)</span> seguida por <span class="math inline">\(y\)</span>.</p>
<p><strong>Definição formal</strong>: se <span class="math inline">\(x = a_1a_2\ldots a_m\)</span> e <span class="math inline">\(y = b_1b_2\ldots b_n\)</span>, então:</p>
<p><span class="math display">\[xy = a_1a_2\ldots a_mb_1b_2\ldots b_n\]</span></p>
<p>Alternativamente, a concatenação pode ser representada com a mesma notação do produto escalar. Assim, a concatenação de <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> pode ser denotada como <span class="math inline">\(x \cdot y\)</span>.</p>
<p><strong>Propriedades da concatenação</strong>:</p>
<ul>
<li><strong>Associatividade</strong>: para <em>strings</em> <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, <span class="math inline">\(z\)</span>, temos <span class="math inline">\((xy)z = x(yz)\)</span>.</li>
<li><strong>Elemento neutro</strong>: para qualquer <em>string</em> <span class="math inline">\(w\)</span>, <span class="math inline">\(w\epsilon = \epsilon w = w\)</span>.</li>
<li><strong>Não-comutatividade</strong>: em geral, <span class="math inline">\(xy \neq yx\)</span>.</li>
</ul>
</section>
<section id="potências-de-strings" class="level4" data-number="3.2.2.2">
<h4 data-number="3.2.2.2" class="anchored" data-anchor-id="potências-de-strings"><span class="header-section-number">3.2.2.2</span> Potências de Strings</h4>
<p>Para uma <em>string</em> <span class="math inline">\(w\)</span> e um inteiro não-negativo <span class="math inline">\(n\)</span>, a <strong>potência</strong> <span class="math inline">\(w^n\)</span> é definida recursivamente:</p>
<p><span class="math display">\[w^0 = \epsilon\]</span> <span class="math display">\[w^{n+1} = w^n \cdot w \text{ para } n \geq 0\]</span></p>
<p>Por exemplo, se <span class="math inline">\(w = ab\)</span>, então <span class="math inline">\(w^3 = ababab\)</span>.</p>
<p>Antes de avançarmos para operações com linguagens, a atenta leitora deve distinguir a operação de <strong>potência de uma <em>string</em></strong> da operação de <strong>Fechamento de Kleene</strong>, que será detalhada adiante. Enquanto a potência <span class="math inline">\(w^n\)</span> aplica-se a uma <em>única string</em> <span class="math inline">\(w\)</span> para produzir como resultado outra <em>única string</em>, o Fechamento de Kleene, denotado por um asterisco, como em <span class="math inline">\(L^*\)</span>, é uma operação que se aplica a um <em>conjunto de strings</em>, uma linguagem, ou a um <em>conjunto de símbolos</em>, um alfabeto. O resultado do Fechamento de Kleene não é uma <em>string</em>, mas sim um novo <em>conjunto de strings</em>, geralmente infinito, representando todas as combinações possíveis de elementos do conjunto original. A potência é, portanto, uma operação sobre elementos individuais, enquanto o Fechamento de Kleene é uma operação sobre conjuntos.</p>
</section>
<section id="reverso-de-strings" class="level4" data-number="3.2.2.3">
<h4 data-number="3.2.2.3" class="anchored" data-anchor-id="reverso-de-strings"><span class="header-section-number">3.2.2.3</span> Reverso de Strings</h4>
<p>O <strong>reverso</strong> de uma <em>string</em> <span class="math inline">\(w\)</span>, denotado por <span class="math inline">\(w^R\)</span>, é a <em>string</em> obtida invertendo a ordem dos símbolos:</p>
<p><strong>Definição recursiva</strong>:</p>
<ul>
<li><span class="math inline">\(\epsilon^R = \epsilon\)</span>;</li>
<li><span class="math inline">\((wa)^R = aw^R\)</span> para <span class="math inline">\(w \in \Sigma^*\)</span> e <span class="math inline">\(a \in \Sigma\)</span>.</li>
</ul>
<p>Por exemplo, se <span class="math inline">\(w = abc\)</span>, então <span class="math inline">\(w^R = cba\)</span>.</p>
</section>
</section>
<section id="substrings-prefixos-e-sufixos-entendendo-as-partes-de-uma-string" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="substrings-prefixos-e-sufixos-entendendo-as-partes-de-uma-string"><span class="header-section-number">3.2.3</span> Substrings, Prefixos e Sufixos: Entendendo as Partes de uma String</h3>
<p>Ao trabalhar com texto e linguagens de programação, raramente tratamos uma <em>string</em> como uma unidade indivisível. Quase sempre precisamos inspecionar, extrair ou analisar suas partes internas. Os conceitos de <strong>substring</strong>, <strong>prefixo</strong> e <strong>sufixo</strong> nos dão um vocabulário formal e preciso para descrever essas partes.</p>
<p>Este vocabulário formado de termos para as partes em que podemos dividir <em>strings</em> será relevante quando: estivermos estudando analisadores léxicos e sintáticos, pois eles frequentemente operam sobre essas partes para identificar padrões, validar estruturas e extrair informações significativas; criando ferramentas de busca e análise de texto, onde precisamos localizar ocorrências de padrões dentro de grandes volumes de texto; ou desenvolvendo algoritmos que manipulam ou processam <em>strings</em> de maneira eficiente; ou ainda, ao implementar funcionalidades de autocompletar em editores de texto e IDEs, onde o sistema sugere palavras ou comandos com base no que o usuário já digitou.</p>
<section id="substring" class="level4" data-number="3.2.3.1">
<h4 data-number="3.2.3.1" class="anchored" data-anchor-id="substring"><span class="header-section-number">3.2.3.1</span> Substring</h4>
<p>Uma substring é simplesmente um pedaço ou um segmento contínuo de caracteres que está dentro de outra <em>string</em>. Formalmente dizemos que uma <em>string</em> <code>$v$</code> é uma substring de <code>$w$</code> se for possível encontrar duas outras <em>strings</em>, <code>$x$</code> (a parte que vem antes) e <code>$y$</code> (a parte que vem depois), de forma que <code>$w = xvy$</code>. As <em>strings</em> <code>$x$</code> ou <code>$y$</code> podem, inclusive, ser vazias.</p>
<p><strong>Exemplo</strong>: Para a <em>string</em> <code>$w = compilador$</code>, as palavras <code>pila</code>, <code>com</code>, <code>dor</code> e <code>compilador</code> são todas substrings válidas. No caso de <code>pila</code>, <code>$x = com$</code> e <code>$y = dor$</code>.</p>
</section>
<section id="prefixo" class="level4" data-number="3.2.3.2">
<h4 data-number="3.2.3.2" class="anchored" data-anchor-id="prefixo"><span class="header-section-number">3.2.3.2</span> Prefixo</h4>
<p>Um prefixo é um trecho que começa exatamente no início de uma <em>string</em>. Formalmente dizemos que uma <em>string</em> <code>$v$</code> é um prefixo de <code>$w$</code> se houver uma <em>string</em> <code>$y$</code> (o resto da <em>string</em>) tal que <code>$w = vy$</code>.</p>
<p><strong>Exemplo</strong>: Para <code>$w = compilador$</code>, alguns prefixos são <code>c</code>, <code>com</code>, <code>compi</code> e a própria <em>string</em> <code>compilador</code>.</p>
<section id="prefixo-próprio" class="level5" data-number="3.2.3.2.1">
<h5 data-number="3.2.3.2.1" class="anchored" data-anchor-id="prefixo-próprio"><span class="header-section-number">3.2.3.2.1</span> Prefixo Próprio</h5>
<p>Dizemos que uma <em>string</em> é um prefixo próprio de outra <em>string</em> se for um prefixo que não seja a própria <em>string</em> inteira. Formalmente, um prefixo <code>$v$</code> de <code>$w$</code> é dito próprio se <code>$v \neq w$</code>.</p>
<p><strong>Exemplo</strong>: Para <code>$w = compilador$</code>, <code>compi</code> é um prefixo próprio, mas <code>compilador</code> não é.</p>
</section>
</section>
<section id="sufixo" class="level4" data-number="3.2.3.3">
<h4 data-number="3.2.3.3" class="anchored" data-anchor-id="sufixo"><span class="header-section-number">3.2.3.3</span> Sufixo</h4>
<p>Um sufixo é um trecho que termina exatamente no final de uma <em>string</em>. Formalmente dizemos que uma <em>string</em> <code>$v$</code> é um sufixo de <code>$w$</code> se houver uma <em>string</em> <code>$x$</code> (a parte inicial) tal que <code>$w = xv$</code>.</p>
<p><strong>Exemplo</strong>: Para <code>$w = compilador$</code>, alguns sufixos são <code>r</code>, <code>dor</code>, <code>lador</code> e a própria <em>string</em> <code>compilador</code>.</p>
<section id="sufixo-próprio" class="level5" data-number="3.2.3.3.1">
<h5 data-number="3.2.3.3.1" class="anchored" data-anchor-id="sufixo-próprio"><span class="header-section-number">3.2.3.3.1</span> Sufixo Próprio</h5>
<p>Dizemos que uma <em>string</em> é um sufixo próprio se for qualquer sufixo que não seja a própria <em>string</em> inteira. Formalmente, um sufixo <code>$v$</code> de <code>$w$</code> é dito próprio se `<span class="math inline">\(v \neq w\)</span>.</p>
<p><strong>Exemplo</strong>: Para <code>$w = compilador$</code>, <code>lador</code> é um sufixo próprio, mas <code>compilador</code> não é.</p>
<p>Definir formalmente essas <em>partes</em> de uma <em>string</em> é fundamental para a ciência da computação, pois elas são a base para inúmeras operações e algoritmos:</p>
</section>
</section>
</section>
<section id="sec-ex-strings" class="level3" data-number="3.2.4">
<h3 data-number="3.2.4" class="anchored" data-anchor-id="sec-ex-strings"><span class="header-section-number">3.2.4</span> Exercícios 2</h3>
<ol type="1">
<li>Sejam <span class="math inline">\(x = ab\)</span> e <span class="math inline">\(y = cd\)</span>. Calcule:
<ol type="a">
<li><span class="math inline">\(xy\)</span> e <span class="math inline">\(yx\)</span>;</li>
<li><span class="math inline">\(x^3\)</span> e <span class="math inline">\(y^2\)</span>;</li>
<li><span class="math inline">\((xy)^2\)</span> e <span class="math inline">\(x^2y^2\)</span>;</li>
<li><span class="math inline">\(|x^n|\)</span> em função de <span class="math inline">\(n\)</span>.</li>
</ol></li>
<li>Para as <em>strings</em> dadas, determine seus reversos:
<ol type="a">
<li><span class="math inline">\(w_1 = abcde\)</span>;</li>
<li><span class="math inline">\(w_2 = palíndromo\)</span>;</li>
<li><span class="math inline">\(w_3 = \epsilon\)</span> (string vazia);</li>
<li>Prove que <span class="math inline">\((\epsilon)^R = \epsilon\)</span>.</li>
</ol></li>
<li>Demonstre as seguintes propriedades usando <em>strings</em> específicas:
<ol type="a">
<li>Associatividade: <span class="math inline">\((xy)z = x(yz)\)</span> para <span class="math inline">\(x = a\)</span>, <span class="math inline">\(y = bc\)</span>, <span class="math inline">\(z = d\)</span>;</li>
<li>Elemento neutro: <span class="math inline">\(w\epsilon = \epsilon w = w\)</span> para <span class="math inline">\(w = abc\)</span>;</li>
<li>Não-comutatividade: encontre <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> tais que <span class="math inline">\(xy \neq yx\)</span>.</li>
</ol></li>
<li>Para a <em>string</em> <span class="math inline">\(w = compilador\)</span>:
<ol type="a">
<li>Liste todos os prefixos próprios;</li>
<li>Liste todos os sufixos próprios;</li>
<li>Identifique todas as substrings de comprimento 4;</li>
<li>Determine quantos prefixos e sufixos <span class="math inline">\(w\)</span> possui no total.</li>
</ol></li>
<li>Seja <span class="math inline">\(w = aba\)</span>. Calcule:
<ol type="a">
<li><span class="math inline">\((w^R)^2\)</span>;</li>
<li><span class="math inline">\((w^2)^R\)</span>;</li>
<li><span class="math inline">\(w^R w\)</span>;</li>
<li>Verifique se <span class="math inline">\((w^2)^R = (w^R)^2\)</span>.</li>
</ol></li>
</ol>
</section>
</section>
<section id="linguagens-conjuntos-de-strings" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="linguagens-conjuntos-de-strings"><span class="header-section-number">3.3</span> Linguagens: Conjuntos de Strings</h2>
<p>Uma <strong>linguagem</strong> sobre um alfabeto <span class="math inline">\(\Sigma\)</span> é simplesmente um conjunto de <em>strings</em> formadas a partir de símbolos de <span class="math inline">\(\Sigma\)</span>. Formalmente:</p>
<p><span class="math display">\[L \subseteq \Sigma^*\]</span></p>
<p>na qual <span class="math inline">\(\Sigma^*\)</span> denota o conjunto de todas as <em>strings</em> possíveis sobre <span class="math inline">\(\Sigma\)</span>, incluindo a <em>string</em> vazia <span class="math inline">\(\epsilon\)</span>.</p>
<section id="o-conjunto-universal-sigma" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="o-conjunto-universal-sigma"><span class="header-section-number">3.3.1</span> O Conjunto Universal <span class="math inline">\(\Sigma^*\)</span></h3>
<p>O conjunto <span class="math inline">\(\Sigma^*\)</span> (lê-se <em>sigma estrela</em> ou <em>fechamento de Kleene de <span class="math inline">\(\Sigma\)</span></em>) é definido como:</p>
<p><span class="math display">\[\Sigma^* = \Sigma^0 \cup \Sigma^1 \cup \Sigma^2 \cup \Sigma^3 \cup \ldots\]</span></p>
<p>na qual:</p>
<ul>
<li><span class="math inline">\(\Sigma^0 = \{\epsilon\}\)</span>;</li>
<li><span class="math inline">\(\Sigma^1 = \Sigma = \{a_1, a_2, \ldots, a_n\}\)</span>;</li>
<li><span class="math inline">\(\Sigma^2 = \{xy \mid x, y \in \Sigma\}\)</span>;</li>
<li><span class="math inline">\(\Sigma^k = \{w \mid |w| = k \text{ e } w \text{ é string sobre } \Sigma\}\)</span>.</li>
</ul>
<p>Dessa forma, <span class="math inline">\(\Sigma^k\)</span> é o conjunto de todas as <em>strings</em> de comprimento <span class="math inline">\(k\)</span> formadas por símbolos de <span class="math inline">\(\Sigma\)</span></p>
<p>Para o alfabeto binário <span class="math inline">\(\Sigma = \{0, 1\}\)</span>:</p>
<p><span class="math display">\[\Sigma^* = \{\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, 101, 110, 111, \ldots\}\]</span></p>
</section>
<section id="exemplos-de-linguagens" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="exemplos-de-linguagens"><span class="header-section-number">3.3.2</span> Exemplos de Linguagens</h3>
<ol type="1">
<li><p><strong>Linguagem vazia</strong>: <span class="math inline">\(L_{\emptyset} = \emptyset\)</span>. A linguagem que não contém nenhuma <em>string</em>. É importante distinguir da linguagem que contém apenas a <em>string</em> vazia.</p></li>
<li><p><strong>Linguagem contendo apenas a <em>string</em> vazia</strong>: <span class="math inline">\(L_{\epsilon} = \{\epsilon\}\)</span>. Uma linguagem com exatamente um elemento, a <em>string</em> vazia.</p></li>
<li><p><strong>Linguagem de todas as <em>strings</em> binárias</strong>: <span class="math inline">\(L_{\text{todas}} = \{0, 1\}^*\)</span>. Esta linguagem contém todas as <em>strings</em> possíveis sobre o alfabeto binário.</p></li>
<li><p><strong>Linguagem de <em>strings</em> binárias de comprimento par</strong>: <span class="math display">\[L_{\text{par}} = \{w \in \{0, 1\}^* \mid |w| \text{ é par}\}\]</span></p></li>
</ol>
<p><strong>Linguagem de identificadores válidos</strong>: para modelar identificadores em uma linguagem de programação: <span class="math display">\[L_{\text{id}} = \{w \in \{a, \ldots, z, A, \ldots, Z, 0, \ldots, 9, \_\}^* \mid w \text{ inicia com letra ou } \_\}\]</span></p>
</section>
<section id="operações-com-linguagens" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="operações-com-linguagens"><span class="header-section-number">3.3.3</span> Operações com Linguagens</h3>
<p>Da mesma forma que operamos com <em>strings</em> individuais, podemos realizar operações com linguagens inteiras para construir novas linguagens a partir de outras. Uma vez que uma linguagem é, por definição, um conjunto de <em>strings</em> (<span class="math inline">\(L \subseteq \Sigma^*\)</span>), ela herda naturalmente as operações fundamentais da teoria dos conjuntos. Adicionalmente, estenderemos as operações que vimos para <em>strings</em>, como a concatenação, para que se apliquem a conjuntos inteiros de <em>strings</em>. Iniciaremos nossa exploração com as operações que derivam diretamente da natureza das linguagens como conjuntos.</p>
<section id="união-de-linguagens" class="level4" data-number="3.3.3.1">
<h4 data-number="3.3.3.1" class="anchored" data-anchor-id="união-de-linguagens"><span class="header-section-number">3.3.3.1</span> União de Linguagens</h4>
<p>A <strong>união</strong> representa a operação mais natural e intuitiva entre linguagens, capturando a essência da <strong>escolha</strong> ou <strong>alternativa</strong>. Quando unimos duas linguagens, criamos uma nova linguagem que aceita qualquer <em>string</em> que pertença a pelo menos uma das linguagens originais. É como estabelecer uma regra de aceitação do tipo <em>ou isto, ou aquilo, ou ambos</em>.</p>
<p>Esta operação herda diretamente da teoria dos conjuntos, mas seu significado em linguagens formais transcende a mera manipulação de conjuntos, tornando-se uma ferramenta fundamental para expressar alternativas em especificações de linguagens.</p>
<p><strong>União</strong>: A união de duas linguagens <span class="math inline">\(L_1\)</span> e <span class="math inline">\(L_2\)</span> é:</p>
<p><span class="math display">\[L_1 \cup L_2 = \{w \mid w \in L_1 \text{ ou } w \in L_2\}\]</span></p>
<p>A palavra <em>ou</em> aqui é inclusiva: uma <em>string</em> pertence à união se está em <span class="math inline">\(L_1\)</span>, ou em <span class="math inline">\(L_2\)</span>, ou em ambas.</p>
<section id="exemplos-de-união" class="level5" data-number="3.3.3.1.1">
<h5 data-number="3.3.3.1.1" class="anchored" data-anchor-id="exemplos-de-união"><span class="header-section-number">3.3.3.1.1</span> Exemplos de União</h5>
<p><strong>Exemplo 1</strong>: Linguagens de Tokens Simples</p>
<ul>
<li><span class="math inline">\(L_{\text{num}} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}\)</span> (dígitos);</li>
<li><span class="math inline">\(L_{\text{op}} = \{+, -, *, /\}\)</span> (operadores);</li>
<li><span class="math inline">\(L_{\text{token}} = L_{\text{num}} \cup L_{\text{op}} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, -, *, /\}\)</span>.</li>
</ul>
<p>Esta união modela os tokens básicos de uma calculadora simples.</p>
<p><strong>Exemplo 2</strong>: Linguagens de Comprimentos Específicos</p>
<ul>
<li><span class="math inline">\(L_{\text{par}} = \{w \in \{a, b\}^* \mid |w| \text{ é par}\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{ímpar}} = \{w \in \{a, b\}^* \mid |w| \text{ é ímpar}\}\)</span>;<br>
</li>
<li><span class="math inline">\(L_{\text{par}} \cup L_{\text{ímpar}} = \{a, b\}^*\)</span> (todas as <em>strings</em> sobre <span class="math inline">\(\{a, b\}\)</span>).</li>
</ul>
<p><strong>Exemplo 3</strong>: Linguagens Sobrepostas</p>
<ul>
<li><span class="math inline">\(L_1 = \{a, ab, abc\}\)</span>;</li>
<li><span class="math inline">\(L_2 = \{ab, bc, c\}\)</span>;</li>
<li><span class="math inline">\(L_1 \cup L_2 = \{a, ab, abc, bc, c\}\)</span>.</li>
</ul>
<p>Note que <span class="math inline">\(ab\)</span> aparece em ambas as linguagens, mas na união aparece apenas uma vez, seguindo a definição de conjunto.</p>
</section>
<section id="propriedades-algébricas-da-união" class="level5" data-number="3.3.3.1.2">
<h5 data-number="3.3.3.1.2" class="anchored" data-anchor-id="propriedades-algébricas-da-união"><span class="header-section-number">3.3.3.1.2</span> Propriedades Algébricas da União</h5>
<p>A união satisfaz propriedades fundamentais que a tornam uma operação bem-comportada:</p>
<p><strong>1. Comutatividade</strong>: <span class="math display">\[L_1 \cup L_2 = L_2 \cup L_1\]</span></p>
<p>A ordem das linguagens na união não importa.</p>
<p><strong>2. Associatividade</strong>: <span class="math display">\[(L_1 \cup L_2) \cup L_3 = L_1 \cup (L_2 \cup L_3)\]</span></p>
<p>Podemos agrupar uniões de qualquer forma, permitindo escrever <span class="math inline">\(L_1 \cup L_2 \cup L_3\)</span> sem ambiguidade.</p>
<p><strong>3. Elemento Neutro</strong>: <span class="math display">\[L \cup \emptyset = \emptyset \cup L = L\]</span></p>
<p>A linguagem vazia não adiciona elementos a qualquer união.</p>
<p><strong>4. Idempotência</strong>: <span class="math display">\[L \cup L = L\]</span></p>
<p>Unir uma linguagem consigo mesma não a modifica.</p>
<p><strong>5. Absorção</strong>: <span class="math display">\[L \cup \Sigma^* = \Sigma^*\]</span></p>
<p>Unir qualquer linguagem com a linguagem universal resulta na linguagem universal.</p>
</section>
<section id="aplicações-práticas-da-união" class="level5" data-number="3.3.3.1.3">
<h5 data-number="3.3.3.1.3" class="anchored" data-anchor-id="aplicações-práticas-da-união"><span class="header-section-number">3.3.3.1.3</span> Aplicações Práticas da União</h5>
<p><strong>1. Definição de Alfabetos Estendidos</strong>: em linguagens de programação, frequentemente definimos categorias de caracteres como:</p>
<ul>
<li>Letras: <span class="math inline">\(L_{\text{letras}} = \{a, b, \ldots, z, A, B, \ldots, Z\}\)</span>;</li>
<li>Dígitos: <span class="math inline">\(L_{\text{dígitos}} = \{0, 1, \ldots, 9\}\)</span>;<br>
</li>
<li>Alfanuméricos: <span class="math inline">\(L_{\text{alfanum}} = L_{\text{letras}} \cup L_{\text{dígitos}}\)</span>.</li>
</ul>
<p><strong>2. Validação de Formatos Alternativos</strong>: para aceitar diferentes formatos de data:</p>
<ul>
<li><span class="math inline">\(L_{\text{br}} = \{dd/mm/aaaa\}\)</span> (formato brasileiro);</li>
<li><span class="math inline">\(L_{\text{us}} = \{mm/dd/aaaa\}\)</span> (formato americano);</li>
<li><span class="math inline">\(L_{\text{iso}} = \{aaaa-mm-dd\}\)</span> (formato ISO);</li>
<li><span class="math inline">\(L_{\text{data}} = L_{\text{br}} \cup L_{\text{us}} \cup L_{\text{iso}}\)</span>.</li>
</ul>
<p><strong>3. Tratamento de Variações Lexicais</strong>: em processamento de linguagem natural:</p>
<ul>
<li><span class="math inline">\(L_{\text{sim}} = \{\text{sim}, \text{yes}, \text{oui}, \text{sí}\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{não}} = \{\text{não}, \text{no}, \text{non}\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{resposta}} = L_{\text{sim}} \cup L_{\text{não}}\)</span>.</li>
</ul>
</section>
</section>
<section id="concatenação-de-linguagens" class="level4" data-number="3.3.3.2">
<h4 data-number="3.3.3.2" class="anchored" data-anchor-id="concatenação-de-linguagens"><span class="header-section-number">3.3.3.2</span> Concatenação de Linguagens</h4>
<p>A <strong>concatenação</strong> captura a essência da <strong>composição sequencial</strong>: formar novas <em>strings</em> justapondo elementos de duas linguagens em uma ordem específica. É como estabelecer uma regra de construção do tipo <em>primeiro algo de <span class="math inline">\(L_1\)</span>, depois algo de <span class="math inline">\(L_2\)</span></em>.</p>
<p>Esta operação estende naturalmente a concatenação de <em>strings</em> individuais para conjuntos inteiros de <em>strings</em>, criando um mecanismo fundamental para a construção de linguagens complexas a partir de componentes mais simples.</p>
<p><strong>Concatenação</strong>: A concatenação de duas linguagens <span class="math inline">\(L_1\)</span> e <span class="math inline">\(L_2\)</span> é:</p>
<p><span class="math display">\[L_1 \cdot L_2 = \{xy \mid x \in L_1 \text{ e } y \in L_2\}\]</span></p>
<p>O resultado é o conjunto de todas as <em>strings</em> possíveis formadas escolhendo-se uma <em>string</em> de <span class="math inline">\(L_1\)</span> seguida por uma <em>string</em> de <span class="math inline">\(L_2\)</span>.</p>
<section id="exemplos-de-concatenação" class="level5" data-number="3.3.3.2.1">
<h5 data-number="3.3.3.2.1" class="anchored" data-anchor-id="exemplos-de-concatenação"><span class="header-section-number">3.3.3.2.1</span> Exemplos de Concatenação</h5>
<p><strong>Exemplo 1</strong>: construção de Identificadores</p>
<ul>
<li><span class="math inline">\(L_{\text{letra}} = \{a, b, c, \ldots, z\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{dígito}} = \{0, 1, 2, \ldots, 9\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{letra}} \cdot L_{\text{dígito}} = \{a0, a1, \ldots, a9, b0, b1, \ldots, z9\}\)</span>.</li>
</ul>
<p>Esta concatenação gera todos os identificadores de exatamente dois caracteres que começam com uma letra seguida de um dígito.</p>
<p><strong>Exemplo 2</strong>: Construção Passo a Passo</p>
<ul>
<li><span class="math inline">\(L_1 = \{a, bb\}\)</span>;</li>
<li><span class="math inline">\(L_2 = \{c, dd\}\)</span>;</li>
<li><span class="math inline">\(L_1 \cdot L_2 = \{ac, add, bbc, bbdd\}\)</span>.</li>
</ul>
<p>Cálculo detalhado:</p>
<ul>
<li><span class="math inline">\(a \in L_1, c \in L_2 \Rightarrow ac \in L_1 \cdot L_2\)</span></li>
<li><span class="math inline">\(a \in L_1, dd \in L_2 \Rightarrow add \in L_1 \cdot L_2\)</span><br>
</li>
<li><span class="math inline">\(bb \in L_1, c \in L_2 \Rightarrow bbc \in L_1 \cdot L_2\)</span></li>
<li><span class="math inline">\(bb \in L_1, dd \in L_2 \Rightarrow bbdd \in L_1 \cdot L_2\)</span></li>
</ul>
<p><strong>Exemplo 3</strong>: Concatenação com Linguagem Unitária</p>
<ul>
<li><span class="math inline">\(L = \{hello, hi\}\)</span>;</li>
<li><span class="math inline">\(\{!\} = \{!\}\)</span>;</li>
<li><span class="math inline">\(L \cdot \{!\} = \{hello!, hi!\}\)</span>.</li>
</ul>
</section>
<section id="propriedades-algébricas-da-concatenação" class="level5" data-number="3.3.3.2.2">
<h5 data-number="3.3.3.2.2" class="anchored" data-anchor-id="propriedades-algébricas-da-concatenação"><span class="header-section-number">3.3.3.2.2</span> Propriedades Algébricas da Concatenação</h5>
<p>A concatenação possui um conjunto distinto de propriedades que a diferenciam significativamente da união:</p>
<p><strong>1. Associatividade</strong>: <span class="math display">\[(L_1 \cdot L_2) \cdot L_3 = L_1 \cdot (L_2 \cdot L_3)\]</span></p>
<p>Podemos agrupar concatenações de qualquer forma, permitindo escrever <span class="math inline">\(L_1 \cdot L_2 \cdot L_3\)</span> sem ambiguidade.</p>
<p><strong>2. Elemento Neutro</strong>: <span class="math display">\[L \cdot \{\epsilon\} = \{\epsilon\} \cdot L = L\]</span></p>
<p>A linguagem contendo apenas a <em>string</em> vazia atua como elemento neutro para a concatenação.</p>
<p><strong>3. Elemento Anulador</strong>: <span class="math display">\[L \cdot \emptyset = \emptyset \cdot L = \emptyset\]</span></p>
<p>A linguagem vazia anula qualquer concatenação.</p>
<p><strong>4. Não-Comutatividade</strong> (propriedade crucial): <span class="math display">\[L_1 \cdot L_2 \neq L_2 \cdot L_1 \text{ (em geral)}\]</span></p>
<p>A ordem na concatenação importa fundamentalmente. Do exemplo anterior:</p>
<ul>
<li><span class="math inline">\(L_1 \cdot L_2 = \{ac, add, bbc, bbdd\}\)</span>;</li>
<li><span class="math inline">\(L_2 \cdot L_1 = \{ca, cbb, dda, ddbb\}\)</span>;</li>
</ul>
<p><strong>5. Distributividade sobre União</strong>: <span class="math display">\[L_1 \cdot (L_2 \cup L_3) = L_1 \cdot L_2 \cup L_1 \cdot L_3\]</span> <span class="math display">\[(L_1 \cup L_2) \cdot L_3 = L_1 \cdot L_3 \cup L_2 \cdot L_3\]</span></p>
<p>Esta propriedade é fundamental para simplificação de expressões regulares.</p>
</section>
<section id="casos-especiais-da-concatenação" class="level5" data-number="3.3.3.2.3">
<h5 data-number="3.3.3.2.3" class="anchored" data-anchor-id="casos-especiais-da-concatenação"><span class="header-section-number">3.3.3.2.3</span> Casos Especiais da Concatenação</h5>
<p><strong>1. Concatenação com a Linguagem Universal</strong>: <span class="math display">\[L \cdot \Sigma^* = \{xy \mid x \in L, y \in \Sigma^*\}\]</span></p>
<p>Resulta em todas as <em>strings</em> que começam com algum elemento de <span class="math inline">\(L\)</span>.</p>
<p><strong>2. Autoconcatenação</strong>: <span class="math display">\[L \cdot L = L^2 = \{xy \mid x, y \in L\}\]</span></p>
<p>Base para a definição de potências de linguagens.</p>
<p><strong>3. Concatenação de Linguagens Infinitas</strong>:</p>
<p>Se <span class="math inline">\(L_1\)</span> tem <span class="math inline">\(m\)</span> elementos e <span class="math inline">\(L_2\)</span> tem <span class="math inline">\(n\)</span> elementos, então <span class="math inline">\(|L_1 \cdot L_2| \leq mn\)</span>, com igualdade quando todas as concatenações resultam em <em>strings</em> distintas.</p>
</section>
<section id="aplicações-práticas-da-concatenação" class="level5" data-number="3.3.3.2.4">
<h5 data-number="3.3.3.2.4" class="anchored" data-anchor-id="aplicações-práticas-da-concatenação"><span class="header-section-number">3.3.3.2.4</span> Aplicações Práticas da Concatenação</h5>
<p><strong>1. Construção de Padrões Estruturados</strong>: Para validar endereços de email (versão muito simplificada):</p>
<ul>
<li><span class="math inline">\(L_{\text{usuário}} = \{[a-zA-Z0-9]+\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{domínio}} = \{[a-zA-Z0-9.-]+\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{ext}} = \{[a-zA-Z]{2,}\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{email}} = L_{\text{usuário}} \cdot \{@\} \cdot L_{\text{domínio}} \cdot \{.\} \cdot L_{\text{ext}}\)</span>.</li>
</ul>
<p><strong>2. Análise Sintática</strong>: Em linguagens de programação:</p>
<ul>
<li><span class="math inline">\(L_{\text{tipo}} = \{int, float, string\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{id}} = \{[a-zA-Z][a-zA-Z0-9]*\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{declaração}} = L_{\text{tipo}} \cdot \{\)</span> <span class="math inline">\(\} \cdot L_{\text{id}}\)</span>.</li>
</ul>
<p><strong>3. Protocolos de Comunicação</strong>:</p>
<ul>
<li><span class="math inline">\(L_{\text{header}} = \{HTTP/1.1, HTTP/2.0\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{método}} = \{GET, POST, PUT, DELETE\}\)</span>;</li>
<li><span class="math inline">\(L_{\text{requisição}} = L_{\text{método}} \cdot \{\)</span> <span class="math inline">\(\} \cdot L_{\text{URL}} \cdot \{\)</span> <span class="math inline">\(\} \cdot L_{\text{header}}\)</span>.</li>
</ul>
</section>
<section id="autômatos-e-complexidade" class="level5" data-number="3.3.3.2.5">
<h5 data-number="3.3.3.2.5" class="anchored" data-anchor-id="autômatos-e-complexidade"><span class="header-section-number">3.3.3.2.5</span> Autômatos e Complexidade</h5>
<p>A concatenação de linguagens finitas tem complexidade <span class="math inline">\(O(|L_1| \times |L_2|)\)</span> no caso geral, mas pode ser otimizada quando as linguagens têm estruturas específicas. Esta consideração é crucial em implementações práticas de analisadores léxicos e sintáticos.</p>
<p>Na teoria de autômatos, a concatenação corresponde à construção sequencial: aceitar uma <em>string</em> em <span class="math inline">\(L_1 \cdot L_2\)</span> significa processar uma parte inicial com um autômato para <span class="math inline">\(L_1\)</span> e a parte restante com um autômato para <span class="math inline">\(L_2\)</span>. Esta intuição será fundamental para construções como a de Thompson para expressões regulares.</p>
<p>A concatenação, portanto, não é apenas uma operação matemática, mas a operação que captura a essência da <strong>sequencialidade</strong> na computação e na especificação de linguagens.</p>
</section>
</section>
<section id="interseção-e-complemento" class="level4" data-number="3.3.3.3">
<h4 data-number="3.3.3.3" class="anchored" data-anchor-id="interseção-e-complemento"><span class="header-section-number">3.3.3.3</span> Interseção e Complemento</h4>
<p>Além das operações que derivam diretamente da teoria dos conjuntos (união) e das que estendem conceitos de <em>strings</em> (concatenação), duas operações adicionais desempenham papéis fundamentais na teoria de linguagens formais: a <strong>interseção</strong> e o <strong>complemento</strong>. Estas operações, embora não sejam diretamente expressáveis por expressões regulares simples, são cruciais para compreender o poder e as limitações das Linguagens Regulares.</p>
<p><strong>Interseção</strong>: a interseção de duas linguagens <span class="math inline">\(L_1\)</span> e <span class="math inline">\(L_2\)</span> será dada por:</p>
<p><span class="math display">\[L_1 \cap L_2 = \{w \mid w \in L_1 \text{ e } w \in L_2\}\]</span></p>
<p>A interseção captura as <em>strings</em> que pertencem simultaneamente a ambas as linguagens. Esta operação é particularmente útil para construir linguagens que devem satisfazer múltiplas condições.</p>
<p><strong>Exemplo prático</strong>: Considere uma linguagem de programação onde queremos definir identificadores que:</p>
<ol type="a">
<li>Comecem com letra: <span class="math inline">\(L_1 = \{w \in \{a, \ldots, z, 0, \ldots, 9\}^* \mid w \text{ inicia com letra}\}\)</span></li>
<li>Tenham comprimento par: <span class="math inline">\(L_2 = \{w \in \{a, \ldots, z, 0, \ldots, 9\}^* \mid |w| \text{ é par}\}\)</span></li>
</ol>
<p>A interseção <span class="math inline">\(L_1 \cap L_2\)</span> contém exatamente os identificadores que começam com letra <strong>e</strong> têm comprimento par.</p>
<p><strong>Complemento</strong>: O complemento de uma linguagem <span class="math inline">\(L\)</span> sobre um alfabeto <span class="math inline">\(\Sigma\)</span> é:</p>
<p><span class="math display">\[\overline{L} = \Sigma^* - L = \{w \in \Sigma^* \mid w \notin L\}\]</span></p>
<p>O complemento de <span class="math inline">\(L\)</span> contém todas as <em>strings</em> possíveis sobre <span class="math inline">\(\Sigma\)</span> <strong>exceto</strong> aquelas que pertencem a <span class="math inline">\(L\)</span>. Esta operação é fundamental para expressar condições negativas.</p>
<p><strong>Exemplo prático</strong>: Se <span class="math inline">\(L\)</span> é a linguagem de todas as <em>strings</em> binárias que contêm a substring <span class="math inline">\(01\)</span>, então <span class="math inline">\(\overline{L}\)</span> é a linguagem de todas as <em>strings</em> binárias que <strong>não</strong> contêm <span class="math inline">\(01\)</span> como substring — exatamente o padrão que vimos nos exemplos anteriores ser descrito pela expressão <span class="math inline">\(1^*0^*\)</span>.</p>
<p>Na prática, interseção e complemento aparecem frequentemente em:</p>
<ol type="1">
<li><strong>Validação de dados</strong>: Verificar que uma entrada satisfaz múltiplas condições simultaneamente</li>
<li><strong>Análise de segurança</strong>: Definir padrões de tráfego permitido como complemento de padrões maliciosos</li>
<li><strong>Processamento de linguagens naturais</strong>: Filtrar textos que pertencem a uma categoria mas não a outra</li>
<li><strong>Otimização de compiladores</strong>: Análise de fluxo de dados onde certas condições devem ser simultaneamente satisfeitas</li>
</ol>
<p>Estas operações, embora mais abstratas que concatenação e união, formam uma base teórica sólida que será fundamental quando explorarmos autômatos finitos e técnicas mais avançadas de análise de linguagens.</p>
</section>
<section id="potências-de-linguagens" class="level4" data-number="3.3.3.4">
<h4 data-number="3.3.3.4" class="anchored" data-anchor-id="potências-de-linguagens"><span class="header-section-number">3.3.3.4</span> Potências de Linguagens</h4>
<p>Para uma linguagem <span class="math inline">\(L\)</span> e um inteiro não-negativo <span class="math inline">\(n\)</span>:</p>
<p><span class="math display">\[L^0 = \{\epsilon\}\]</span> <span class="math display">\[L^{n+1} = L^n \cdot L \text{ para } n \geq 0\]</span></p>
</section>
<section id="fechamento-de-kleene-e-fechamento-positivo" class="level4" data-number="3.3.3.5">
<h4 data-number="3.3.3.5" class="anchored" data-anchor-id="fechamento-de-kleene-e-fechamento-positivo"><span class="header-section-number">3.3.3.5</span> Fechamento de Kleene e Fechamento Positivo</h4>
<p>Entre todas as operações com linguagens, o <strong>fechamento de Kleene</strong> destaca-se como uma das mais poderosas e fundamentais. Nomeada em homenagem ao matemático Stephen Kleene, esta operação captura a essência da <strong>repetição arbitrária</strong> — um conceito central tanto na teoria formal quanto nas aplicações práticas da computação.</p>
<p>Intuitivamente, o fechamento de Kleene de uma linguagem <span class="math inline">\(L\)</span> representa todas as possíveis concatenações de zero ou mais elementos de <span class="math inline">\(L\)</span>. É como se perguntássemos: <em>Que <em>strings</em> podemos formar se nos for permitido escolher elementos de <span class="math inline">\(L\)</span> quantas vezes quisermos, incluindo a possibilidade de não escolher nenhum?</em></p>
<p><strong>Fechamento de Kleene</strong>: O fechamento de Kleene de uma linguagem <span class="math inline">\(L\)</span> é:</p>
<p><span class="math display">\[L^* = L^0 \cup L^1 \cup L^2 \cup L^3 \cup \ldots = \bigcup_{i=0}^{\infty} L^i\]</span></p>
<p>Esta definição revela uma estrutura elegante: <span class="math inline">\(L^*\)</span> é construído pela união de todas as potências possíveis de <span class="math inline">\(L\)</span>, começando de <span class="math inline">\(L^0 = \{\epsilon\}\)</span> (a linguagem contendo apenas a <em>string</em> vazia) e estendendo-se infinitamente.</p>
<p><strong>Fechamento Positivo</strong>: O fechamento positivo de <span class="math inline">\(L\)</span> é uma variação que exclui a possibilidade de <em>não escolher nada</em>:</p>
<p><span class="math display">\[L^+ = L^1 \cup L^2 \cup L^3 \cup \ldots = \bigcup_{i=1}^{\infty} L^i = L \cdot L^*\]</span></p>
<p>A diferença fundamental é que <span class="math inline">\(L^+\)</span> exige <strong>pelo menos uma</strong> escolha de <span class="math inline">\(L\)</span>, enquanto <span class="math inline">\(L^*\)</span> permite zero escolhas.</p>
<p>A relação entre fechamento de Kleene e o fechamento positivo depende crucialmente de um fator: se a <em>string</em> vazia <span class="math inline">\(\epsilon\)</span> pertence ou não à linguagem original <span class="math inline">\(L\)</span>.</p>
<p><strong>Caso 1</strong>: Se <span class="math inline">\(\epsilon \notin L\)</span>, então: <span class="math display">\[L^+ = L^* - \{\epsilon\}\]</span></p>
<p>Neste caso, como <span class="math inline">\(\epsilon \notin L\)</span>, ela só pode aparecer em <span class="math inline">\(L^*\)</span> através de <span class="math inline">\(L^0 = \{\epsilon\}\)</span>. Todas as outras potências <span class="math inline">\(L^i\)</span> para <span class="math inline">\(i \geq 1\)</span> não contêm <span class="math inline">\(\epsilon\)</span>, pois são formadas por concatenações de elementos de <span class="math inline">\(L\)</span> que não incluem <span class="math inline">\(\epsilon\)</span>.</p>
<p><strong>Caso 2</strong>: Se <span class="math inline">\(\epsilon \in L\)</span>, então: <span class="math display">\[L^+ = L^*\]</span></p>
<p>Neste caso, se <span class="math inline">\(\epsilon \in L = L^1\)</span>, então <span class="math inline">\(\epsilon \in L^+\)</span>. Como <span class="math inline">\(\epsilon\)</span> também está em <span class="math inline">\(L^*\)</span> (via <span class="math inline">\(L^0\)</span>), e ambos contêm todas as outras potências, os conjuntos são idênticos.</p>
<section id="exemplos" class="level5" data-number="3.3.3.5.1">
<h5 data-number="3.3.3.5.1" class="anchored" data-anchor-id="exemplos"><span class="header-section-number">3.3.3.5.1</span> Exemplos</h5>
<p><strong>Exemplo 1</strong>: <span class="math inline">\(L = \{a\}\)</span></p>
<ul>
<li><span class="math inline">\(L^* = \{\epsilon, a, aa, aaa, aaaa, \ldots\} = \{a^n \mid n \geq 0\}\)</span></li>
<li><span class="math inline">\(L^+ = \{a, aa, aaa, aaaa, \ldots\} = \{a^n \mid n \geq 1\}\)</span></li>
<li>Como <span class="math inline">\(\epsilon \notin L\)</span>, temos <span class="math inline">\(L^+ = L^* - \{\epsilon\}\)</span></li>
</ul>
<p><strong>Exemplo 2</strong>: <span class="math inline">\(L = \{ab, cd\}\)</span></p>
<ul>
<li><span class="math inline">\(L^* = \{\epsilon, ab, cd, abab, abcd, cdab, cdcd, ababab, \ldots\}\)</span></li>
<li><span class="math inline">\(L^+ = \{ab, cd, abab, abcd, cdab, cdcd, ababab, \ldots\}\)</span></li>
<li>Novamente, <span class="math inline">\(L^+ = L^* - \{\epsilon\}\)</span></li>
</ul>
<p><strong>Exemplo 3</strong>: <span class="math inline">\(L = \{\epsilon, a\}\)</span></p>
<ul>
<li><span class="math inline">\(L^* = L^+ = \{\epsilon, a, aa, aaa, \ldots\} = \{a^n \mid n \geq 0\}\)</span></li>
<li>Como <span class="math inline">\(\epsilon \in L\)</span>, ambos os fechamentos são idênticos</li>
</ul>
</section>
<section id="propriedades-matemáticas-fundamentais" class="level5" data-number="3.3.3.5.2">
<h5 data-number="3.3.3.5.2" class="anchored" data-anchor-id="propriedades-matemáticas-fundamentais"><span class="header-section-number">3.3.3.5.2</span> Propriedades Matemáticas Fundamentais</h5>
<p>Os fechamentos de Kleene satisfazem várias propriedades algébricas importantes:</p>
<p><strong>1. Idempotência do Fechamento de Kleene</strong>: <span class="math display">\[(L^*)^* = L^*\]</span></p>
<p><strong>Intuição</strong>: Aplicar o fechamento de Kleene duas vezes não adiciona novos elementos. Se já temos todas as concatenações possíveis de <span class="math inline">\(L\)</span>, concatenar essas concatenações não produz nada novo.</p>
<p><strong>2. Inclusão da Linguagem Original</strong>: <span class="math display">\[L \subseteq L^+ \subseteq L^*\]</span></p>
<p><strong>3. Elemento Neutro</strong>: <span class="math display">\[L^* = \{\epsilon\} \cup L^+\]</span></p>
<p><strong>4. Relação com Concatenação</strong>: <span class="math display">\[L^* = \{\epsilon\} \cup L \cdot L^*\]</span></p>
<p>Esta última propriedade fornece uma <strong>definição recursiva</strong> alternativa para o fechamento de Kleene, extremamente útil em demonstrações formais e construções de autômatos.</p>
</section>
<section id="casos-especiais-importantes" class="level5" data-number="3.3.3.5.3">
<h5 data-number="3.3.3.5.3" class="anchored" data-anchor-id="casos-especiais-importantes"><span class="header-section-number">3.3.3.5.3</span> Casos Especiais Importantes</h5>
<p><strong>Linguagem Vazia</strong>: Para <span class="math inline">\(L = \emptyset\)</span>: <span class="math display">\[\emptyset^* = \{\epsilon\}\]</span> <span class="math display">\[\emptyset^+ = \emptyset\]</span></p>
<p><strong>Justificativa</strong>: Como não podemos escolher elementos de <span class="math inline">\(\emptyset\)</span>, a única <em>concatenação</em> possível é a de zero elementos, resultando em <span class="math inline">\(\epsilon\)</span>.</p>
<p><strong>Linguagem com <em>string</em> Vazia</strong>: Para <span class="math inline">\(L = \{\epsilon\}\)</span>: <span class="math display">\[\{\epsilon\}^* = \{\epsilon\}\]</span> <span class="math display">\[\{\epsilon\}^+ = \{\epsilon\}\]</span></p>
<p><strong>Justificativa</strong>: Concatenar <span class="math inline">\(\epsilon\)</span> consigo mesmo qualquer número de vezes sempre resulta em <span class="math inline">\(\epsilon\)</span>.</p>
</section>
<section id="aplicações-práticas-em-ciência-da-computação" class="level5" data-number="3.3.3.5.4">
<h5 data-number="3.3.3.5.4" class="anchored" data-anchor-id="aplicações-práticas-em-ciência-da-computação"><span class="header-section-number">3.3.3.5.4</span> Aplicações Práticas em Ciência da Computação</h5>
<p><strong>1. Análise Léxica</strong>: o padrão <code>[a-zA-Z][a-zA-Z0-9]*</code> para identificadores utiliza o fechamento de Kleene implicitamente, onde <code>[a-zA-Z0-9]*</code> representa <span class="math inline">\(\Sigma^*\)</span> para o alfabeto alfanumérico.</p>
<p><strong>2. Expressões Regulares em Editores de Texto</strong>: o operador <code>*</code> em expressões regulares corresponde diretamente ao fechamento de Kleene, permitindo buscar padrões com repetições arbitrárias.</p>
<p><strong>3. Protocolos de Comunicação</strong>: muitos protocolos definem mensagens como sequências de unidades básicas, onde o fechamento de Kleene modela a repetição arbitrária dessas unidades.</p>
<p><strong>4. Análise de Algoritmos</strong>: estruturas como loops infinitos ou processos iterativos são naturalmente modelados usando fechamentos de Kleene de operações básicas.</p>
</section>
<section id="conexão-com-autômatos-finitos" class="level5" data-number="3.3.3.5.5">
<h5 data-number="3.3.3.5.5" class="anchored" data-anchor-id="conexão-com-autômatos-finitos"><span class="header-section-number">3.3.3.5.5</span> Conexão com Autômatos Finitos</h5>
<p>O fechamento de Kleene possui uma interpretação natural em termos de autômatos finitos: <span class="math inline">\(L^*\)</span> corresponde à linguagem aceita por um autômato que pode <em>reiniciar</em> infinitas vezes após aceitar uma <em>string</em> de <span class="math inline">\(L\)</span>. Esta conexão será fundamental quando explorarmos a construção de Thompson para converter expressões regulares em autômatos.</p>
</section>
<section id="fechamento-como-operação-universal" class="level5" data-number="3.3.3.5.6">
<h5 data-number="3.3.3.5.6" class="anchored" data-anchor-id="fechamento-como-operação-universal"><span class="header-section-number">3.3.3.5.6</span> Fechamento como Operação Universal</h5>
<p>Uma perspectiva interessante é que o fechamento de Kleene pode ser visto como a <strong>menor</strong> solução para a equação: <span class="math display">\[X = \{\epsilon\} \cup L \cdot X\]</span></p>
<p>Esta caracterização como ponto fixo mínimo conecta os fechamentos de Kleene com áreas avançadas da ciência da computação, incluindo semântica denotacional e análise de programas.</p>
<p>O fechamento de Kleene, portanto, não é apenas uma operação matemática abstrata, mas uma ferramenta conceitual poderosa que captura a essência da computação iterativa e da geração de linguagens através de repetição controlada.</p>
</section>
</section>
<section id="propriedades-e-fechamento" class="level4" data-number="3.3.3.6">
<h4 data-number="3.3.3.6" class="anchored" data-anchor-id="propriedades-e-fechamento"><span class="header-section-number">3.3.3.6</span> Propriedades e Fechamento</h4>
<p>Uma propriedade notável das Linguagens Regulares é que elas são <strong>fechadas</strong> sob ambas as operações:</p>
<p><strong>Teorema (Fechamento das Linguagens Regulares)</strong>:</p>
<p>Se <span class="math inline">\(L_1\)</span> e <span class="math inline">\(L_2\)</span> são Linguagens Regulares sobre um alfabeto <span class="math inline">\(\Sigma\)</span>, então:</p>
<ol type="1">
<li><span class="math inline">\(L_1 \cap L_2\)</span> é uma Linguagem Regular</li>
<li><span class="math inline">\(\overline{L_1}\)</span> é uma Linguagem Regular</li>
</ol>
<p>Esta propriedade de fechamento é uma das características que tornam as Linguagens Regulares tão robustas e úteis na prática. Ela garante que operações complexas entre Linguagens Regulares sempre produzem linguagens que permanecem dentro da mesma classe de complexidade.</p>
</section>
</section>
<section id="as-leis-de-de-morgan-em-linguagens-regulares" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="as-leis-de-de-morgan-em-linguagens-regulares"><span class="header-section-number">3.3.4</span> As Leis de De Morgan em Linguagens Regulares</h3>
<p>As Leis de De Morgan são um par de regras fundamentais da teoria dos conjuntos que se aplicam diretamente às linguagens formais, uma vez que linguagens são conjuntos de <em>strings</em>. Elas estabelecem uma relação poderosa entre as operações de união, interseção e complemento.</p>
<p>As leis são definidas da seguinte forma:</p>
<ol type="1">
<li><p>O complemento da união é a interseção dos complementos: <span class="math display">\[ \overline{L_1 \cup L_2} = \overline{L_1} \cap \overline{L_2} \]</span></p></li>
<li><p>O complemento da interseção é a união dos complementos: <span class="math display">\[ \overline{L_1 \cap L_2} = \overline{L_1} \cup \overline{L_2} \]</span></p></li>
</ol>
<p>A principal importância dessas leis reside na sua capacidade de <strong>simplificar e transformar especificações de linguagens</strong>, especialmente aquelas que envolvem condições negativas (negações). As Leis de De Morgan nos permitem reescrever uma condição complexa de uma forma diferente e, muitas vezes, mais fácil de entender ou construir. A utilidade dessas leis se manifesta em:</p>
<ol type="1">
<li><p><strong>Expressar Negações Complexas</strong>: as Leis de De Morgan permitem converter uma negação sobre uma operação complexa (como <em>não ser (A ou B)</em>) em operações mais simples sobre negações individuais (<em>não ser A</em> E <em>não ser B</em>).</p></li>
<li><p><strong>Manipulação Algébrica</strong>: Assim como na álgebra tradicional, as leis permitem manipular formalmente as descrições de linguagens para otimizá-las ou provar equivalências.</p></li>
</ol>
<p>Como exemplo, se quisermos uma linguagem que descreva <em>strings</em> que <strong>não</strong> terminam em <code>$01$</code> <strong>nem</strong> em <code>$10$</code>, estamos descrevendo uma condição <code>$ \neg (A \lor B) $</code>. Usando a primeira lei de De Morgan, podemos transformar isso em <code>$ (\neg A) \land (\neg B) $</code>:</p>
<p><span class="math display">\[ \overline{L_{01} \cup L_{10}} = \overline{L_{01}} \cap \overline{L_{10}} \]</span></p>
<p>Isso significa que podemos construir a linguagem procurando por <em>strings</em> que satisfaçam duas condições simultaneamente: não terminar em <code>$01$</code> <strong>E</strong> não terminar em <code>$10$</code>.</p>
<p>No contexto das Linguagens Regulares, as Leis de De Morgan são mais uma ferramenta <strong>teórica</strong> do que uma sintaxe prática dentro das expressões regulares básicas. As operações de interseção (<span class="math inline">\(`\cap`\)</span>) e complemento (<span class="math inline">\(`\overline{L}`\)</span>) não possuem operadores diretos nas expressões regulares tradicionais (como <code>$*$</code> para Kleene ou <code>$ \cup $</code> para união).</p>
<p>O seu uso prático e teórico ocorre principalmente na <strong>teoria dos autômatos finitos</strong>:</p>
<ol type="1">
<li><p><strong>Construção de Autômatos</strong>: Sabemos que as Linguagens Regulares são fechadas sob interseção e complemento. Isso significa que se temos autômatos para <code>$L_1$</code> e <code>$L_2$</code>, podemos construir autômatos para <code>$L_1 \cap L_2$</code> e <code>$ \overline{L_1} $</code>. As Leis de De Morgan garantem que podemos, por exemplo, construir um autômato para <code>$ \overline{L_1 \cup L_2} $</code> construindo autômatos para <code>$ \overline{L_1} $</code> e <code>$ \overline{L_2} $</code> e depois aplicando o algoritmo de interseção sobre eles.</p></li>
<li><p><strong>Provas de Equivalência</strong>: As leis são usadas para provar que duas descrições de linguagens diferentes são, na verdade, equivalentes, o que é fundamental para a otimização de analisadores léxicos.</p></li>
</ol>
<p>Em resumo, embora você não escreva <code>$ \overline{L_1} \cap \overline{L_2} $</code> diretamente em uma expressão regular comum, as Leis de De Morgan são o fundamento matemático que garante que podemos construir uma máquina (um autômato finito) para reconhecer essa linguagem complexa, validando o poder e a robustez da classe das Linguagens Regulares.</p>
<section id="limitações-das-expressões-regulares-básicas" class="level4" data-number="3.3.4.1">
<h4 data-number="3.3.4.1" class="anchored" data-anchor-id="limitações-das-expressões-regulares-básicas"><span class="header-section-number">3.3.4.1</span> Limitações das Expressões Regulares Básicas</h4>
<p>É importante observar que, embora as Linguagens Regulares sejam fechadas sob interseção e complemento, essas operações <strong>não são diretamente expressáveis</strong> usando apenas as três operações fundamentais das expressões regulares (união <span class="math inline">\(\cup\)</span>, concatenação <span class="math inline">\(\cdot\)</span>, e fechamento de Kleene <span class="math inline">\(*\)</span>).</p>
<p>Para expressar interseções e complementos, frequentemente precisamos:</p>
<ol type="a">
<li><strong>Construir autômatos finitos</strong> correspondentes às expressões regulares;</li>
<li><strong>Aplicar algoritmos específicos</strong> para interseção e complemento de autômatos;</li>
<li><strong>Converter o resultado de volta</strong> para uma expressão regular sempre que possível.</li>
</ol>
<p>Este é um exemplo de como a teoria matemática subjacente (autômatos finitos) pode ser mais expressiva que a notação conveniente (expressões regulares) para certas operações, embora ambas representem exatamente a mesma classe de linguagens.</p>
</section>
</section>
<section id="sec-ex-linguagens2" class="level3" data-number="3.3.5">
<h3 data-number="3.3.5" class="anchored" data-anchor-id="sec-ex-linguagens2"><span class="header-section-number">3.3.5</span> Exercícios 3</h3>
<ol type="1">
<li>Sejam <span class="math inline">\(L_1 = \{a, ab, b\}\)</span> e <span class="math inline">\(L_2 = \{b, ba, \epsilon\}\)</span>. Calcule:
<ol type="a">
<li><span class="math inline">\(L_1 \cup L_2\)</span>;</li>
<li><span class="math inline">\(L_1 \cap L_2\)</span>;</li>
<li><span class="math inline">\(L_1 - L_2\)</span> (diferença);</li>
<li><span class="math inline">\(|L_1 \cup L_2|\)</span> e <span class="math inline">\(|L_1 \cap L_2|\)</span>.</li>
</ol></li>
<li>Para as linguagens <span class="math inline">\(L_1 = \{a, bb\}\)</span> e <span class="math inline">\(L_2 = \{c, dd\}\)</span>:
<ol type="a">
<li>Calcule <span class="math inline">\(L_1 \cdot L_2\)</span> e <span class="math inline">\(L_2 \cdot L_1\)</span>;</li>
<li>Determine <span class="math inline">\(|L_1 \cdot L_2|\)</span>;</li>
<li>Verifique se <span class="math inline">\(L_1 \cdot L_2 = L_2 \cdot L_1\)</span>.</li>
</ol></li>
<li>Seja <span class="math inline">\(L = \{a, b\}\)</span>. Determine:
<ol type="a">
<li><span class="math inline">\(L^0\)</span>, <span class="math inline">\(L^1\)</span>, <span class="math inline">\(L^2\)</span>;</li>
<li><span class="math inline">\(|L^n|\)</span> em função de <span class="math inline">\(n\)</span>;</li>
<li>As três primeiras <em>strings</em> em ordem lexicográfica de <span class="math inline">\(L^3\)</span>.</li>
</ol></li>
<li>Para <span class="math inline">\(L = \{ab\}\)</span>:
<ol type="a">
<li>Liste os elementos de <span class="math inline">\(L^*\)</span> até <em>strings</em> de comprimento 6;</li>
<li>Determine <span class="math inline">\(L^+\)</span>;</li>
<li>Verifique se <span class="math inline">\(\epsilon \in L^*\)</span> e se <span class="math inline">\(\epsilon \in L^+\)</span>.</li>
</ol></li>
<li>Seja <span class="math inline">\(L = \{a\}\)</span>. Prove ou refute:
<ol type="a">
<li><span class="math inline">\(L^* = L^+\)</span>;</li>
<li><span class="math inline">\(L^* \cup L^+ = L^*\)</span>;</li>
<li><span class="math inline">\((L^*)^* = L^*\)</span>;</li>
<li>Se <span class="math inline">\(\epsilon \in L\)</span>, então <span class="math inline">\(L^+ = L^*\)</span>.</li>
</ol></li>
</ol>
</section>
</section>
<section id="expressões-regulares-uma-notação-concisa" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="expressões-regulares-uma-notação-concisa"><span class="header-section-number">3.4</span> Expressões Regulares: Uma Notação Concisa</h2>
<p>As <strong>expressões regulares</strong> fornecem uma notação algébrica concisa e poderosa para descrever linguagens. Esta notação, introduzida por <a href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene">Stephen Kleene</a>, como vimos na <a href="01-lexico.html#sec-kleene" class="quarto-xref"><span>Section 2.1.2</span></a>, permite especificar conjuntos potencialmente infinitos de <em>strings</em> por meio de padrões finitos.</p>
<section id="definição-indutiva" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="definição-indutiva"><span class="header-section-number">3.4.1</span> Definição Indutiva</h3>
<p>A definição de uma expressão regular sobre um alfabeto <span class="math inline">\(\Sigma\)</span> possui uma natureza indutiva, o que significa que ela é construída progressivamente, de elementos simples para estruturas complexas. Primeiramente, definimos as expressões regulares mais elementares, que servem como nossos <strong>casos base</strong>. Em seguida, estabelecemos as regras de construção, ou <strong>casos indutivos</strong>, que nos permitem combinar expressões existentes para formar novas:</p>
<p><strong>Casos base</strong>:</p>
<ol type="1">
<li><span class="math inline">\(\emptyset\)</span> é uma expressão regular que denota a linguagem vazia;</li>
<li><span class="math inline">\(\epsilon\)</span> é uma expressão regular que denota a linguagem <span class="math inline">\(\{\epsilon\}\)</span>;</li>
<li>Para cada <span class="math inline">\(a \in \Sigma\)</span>, <span class="math inline">\(a\)</span> é uma expressão regular que denota a linguagem <span class="math inline">\(\{a\}\)</span>.</li>
</ol>
<p><strong>Casos indutivos</strong>: Se <span class="math inline">\(r\)</span> e <span class="math inline">\(s\)</span> são expressões regulares, então:</p>
<ol type="1">
<li><span class="math inline">\((r \cup s)\)</span> é uma expressão regular (<strong>união</strong>);</li>
<li><span class="math inline">\((r \cdot s)\)</span> ou simplesmente <span class="math inline">\((rs)\)</span> é uma expressão regular (<strong>concatenação</strong>);</li>
<li><span class="math inline">\((r^*)\)</span> é uma expressão regular (<strong>fechamento de Kleene</strong>).</li>
</ol>
</section>
<section id="precedência-dos-operadores" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="precedência-dos-operadores"><span class="header-section-number">3.4.2</span> Precedência dos Operadores</h3>
<p>De forma análoga à precedência de operadores na aritmética, onde a multiplicação (como em <span class="math inline">\(5 \cdot 2\)</span>) é executada antes da adição (como em <span class="math inline">\(3 + 5\)</span>), as operações em expressões regulares também seguem uma hierarquia de prioridade. Esta convenção é adotada para simplificar a escrita e reduzir o uso excessivo de parênteses, tornando as expressões mais limpas e legíveis. A ordem de precedência, da maior para a menor, é a seguinte:</p>
<ol type="1">
<li><strong>Fechamento de Kleene</strong> (<span class="math inline">\(*\)</span>) - maior precedência</li>
<li><strong>Concatenação</strong> (<span class="math inline">\(\cdot\)</span>) - precedência média</li>
<li><strong>União</strong> (<span class="math inline">\(\cup\)</span>) - menor precedência</li>
</ol>
<p>Tomemos como exemplo a expressão <span class="math inline">\(ab^* \cup c\)</span>. Para interpretá-la, aplicamos a hierarquia de precedência em etapas:</p>
<ol type="1">
<li>Primeiro, o operador de maior prioridade, o <strong>Fechamento de Kleene</strong> (<span class="math inline">\(*\)</span>), é aplicado ao seu argumento imediato à esquerda, <span class="math inline">\(b\)</span>, resultando em <code>(b*)</code>.</li>
<li>Em seguida, a <strong>concatenação</strong> (que tem precedência sobre a união) liga o <code>a</code> ao resultado anterior, formando <code>(a(b*))</code>.</li>
<li>Por fim, o operador de menor prioridade, a <strong>união</strong> (<span class="math inline">\(\cup\)</span>), combina os termos adjacentes, levando à interpretação final e inequívoca: <span class="math inline">\(((a(b^*)) \cup c)\)</span>.</li>
</ol>
</section>
<section id="linguagem-denotada-por-uma-expressão-regular" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="linguagem-denotada-por-uma-expressão-regular"><span class="header-section-number">3.4.3</span> Linguagem Denotada por uma Expressão Regular</h3>
<p>Até agora, definimos uma expressão regular <span class="math inline">\(r\)</span> como uma sequência de símbolos, ou seja, uma construção puramente <strong>sintática</strong>. Agora, precisamos lhe atribuir um <strong>significado (semântica)</strong>, definindo precisamente qual linguagem ela descreve. Para isso, introduzimos a notação <span class="math inline">\(L(r)\)</span> para representar a linguagem denotada por <span class="math inline">\(r\)</span>. A definição de <span class="math inline">\(L(r)\)</span> é indutiva, espelhando perfeitamente a estrutura usada para definir a sintaxe de uma expressão regular:</p>
<p><strong>Casos base</strong>:</p>
<ul>
<li><span class="math inline">\(L(\emptyset) = \emptyset\)</span></li>
<li><span class="math inline">\(L(\epsilon) = \{\epsilon\}\)</span></li>
<li><span class="math inline">\(L(a) = \{a\}\)</span> para <span class="math inline">\(a \in \Sigma\)</span></li>
</ul>
<p><strong>Casos indutivos</strong>:</p>
<ul>
<li><span class="math inline">\(L(r \cup s) = L(r) \cup L(s)\)</span></li>
<li><span class="math inline">\(L(rs) = L(r) \cdot L(s)\)</span></li>
<li><span class="math inline">\(L(r^*) = (L(r))^*\)</span></li>
</ul>
<p>Este processo de definição nos permite <em>computar</em> a linguagem de qualquer expressão. Por exemplo, para decodificar <span class="math inline">\(r = (a \cup b)c\)</span>, aplicamos as regras indutivamente: partindo dos casos base <span class="math inline">\(L(a)=\{a\}\)</span>, <span class="math inline">\(L(b)=\{b\}\)</span> e <span class="math inline">\(L(c)=\{c\}\)</span>, usamos a regra da união para obter <span class="math inline">\(L(a \cup b) = \{a, b\}\)</span>. Por fim, a regra da concatenação nos dá o resultado final: <span class="math inline">\(L(r) = L(a \cup b) \cdot L(c) = \{a, b\} \cdot \{c\} = \{ac, bc\}\)</span>.</p>
<section id="sec-ex-regex" class="level4" data-number="3.4.3.1">
<h4 data-number="3.4.3.1" class="anchored" data-anchor-id="sec-ex-regex"><span class="header-section-number">3.4.3.1</span> Exercícios 4</h4>
<ol type="1">
<li>Determine a linguagem denotada pelas seguintes expressões regulares:
<ol type="a">
<li><span class="math inline">\(r_1 = a \cup b\)</span>;</li>
<li><span class="math inline">\(r_2 = (a \cup b)(a \cup b)\)</span>;</li>
<li><span class="math inline">\(r_3 = a^*b\)</span>;</li>
<li><span class="math inline">\(r_4 = (ab)^*\)</span>.</li>
</ol></li>
<li>Reescreva as seguintes expressões com parênteses explícitos, respeitando a precedência:
<ol type="a">
<li><span class="math inline">\(ab^* \cup c\)</span>;</li>
<li><span class="math inline">\(a \cup bc^*\)</span>;</li>
<li><span class="math inline">\(ab \cup cd^*e\)</span>;</li>
<li><span class="math inline">\(a^*b^* \cup c^*\)</span>.</li>
</ol></li>
<li>Para cada expressão regular, determine se as <em>strings</em> dadas pertencem à linguagem:
<ol type="a">
<li><span class="math inline">\(r = a^*ba^*\)</span>: <em>strings</em> <span class="math inline">\(\{ab, ba, aba, baa, bb\}\)</span>;</li>
<li><span class="math inline">\(r = (a \cup b)^*b\)</span>: <em>strings</em> <span class="math inline">\(\{b, ab, ba, abb, bbb\}\)</span>.</li>
</ol></li>
<li>Use a definição indutiva de <span class="math inline">\(L(r)\)</span> para calcular <span class="math inline">\(L((a \cup b)c)\)</span>:
<ol type="a">
<li>Identifique os casos base aplicáveis;</li>
<li>Aplique as regras indutivas passo a passo;</li>
<li>Apresente o resultado final.</li>
</ol></li>
<li>Construa expressões regulares que denotem as seguintes linguagens:
<ol type="a">
<li><span class="math inline">\(L_1 = \{a, b, aa, bb\}\)</span>;</li>
<li><span class="math inline">\(L_2 = \{\epsilon, a, aa, aaa\}\)</span>;</li>
<li><span class="math inline">\(L_3 = \{w \in \{a,b\}^* \mid w \text{ termina com } a\}\)</span>.</li>
</ol></li>
</ol>
</section>
</section>
<section id="exemplos-de-expressões-regulares" class="level3" data-number="3.4.4">
<h3 data-number="3.4.4" class="anchored" data-anchor-id="exemplos-de-expressões-regulares"><span class="header-section-number">3.4.4</span> Exemplos de Expressões Regulares</h3>
<p>Com os fundamentos teóricos e a semântica de <span class="math inline">\(L(r)\)</span> estabelecidos, a melhor maneira de permitir que a esforçada leitora crie uma intuição sobre o poder expressivo das expressões regulares é por meio da análise de exemplos práticos. Os casos a seguir ilustram como padrões textuais concisos podem descrever com precisão linguagens complexas e, frequentemente, infinitas. Cada exemplo serve para solidificar a conexão entre a notação abstrata e os conjuntos de <em>strings</em> concretos que ela representa.</p>
<ol type="1">
<li><p><strong>Exemplo 1</strong>: <em>strings</em> binárias terminando em <span class="math inline">\(01\)</span> <span class="math display">\[r_1 = (0 \cup 1)^*01\]</span> <span class="math display">\[L(r_1) = \{01, 001, 101, 0001, 0101, 1001, 1101, \ldots\}\]</span></p>
<p><strong>Análise</strong>: Esta expressão é dividida em duas partes. A primeira, <code>$(0 \cup 1)^*$</code>, gera qualquer sequência possível de ’0’s e ’1’s de qualquer comprimento, incluindo a <em>string</em> vazia <span class="math inline">\(\epsilon\)</span>. A segunda parte, <code>01</code>, é uma <em>string</em> literal. Ao concatenar as duas, forçamos que qualquer <em>string</em> gerada pela primeira parte seja seguida por <code>01</code>, garantindo assim a terminação desejada.</p>
<p><strong><span class="math inline">\(L(r_1)\)</span> contém</strong>: <span class="math inline">\(\{01, 101, 001, 11101, \ldots\}\)</span>. <strong><span class="math inline">\(L(r_1)\)</span> não contém</strong>: <span class="math inline">\(\{\epsilon, 0, 1, 10, 010, \ldots\}\)</span>.</p></li>
<li><p><strong>Exemplo 2</strong>: <em>strings</em> sobre <span class="math inline">\(\{a, b\}\)</span> com número par de <span class="math inline">\(a\)</span>’s <span class="math display">\[r_2 = b^*(ab^*ab^*)^*\]</span></p>
<p><strong>Análise</strong>: esta é uma construção elegante. A parte central é <code>$(ab^*ab^*)$</code>. Observe que dentro dos parênteses existem exatamente dois <span class="math inline">\(a\)</span>’s. Os <span class="math inline">\(b^*\)</span>’s permitem que qualquer número de <span class="math inline">\(b\)</span>’s apareçam antes, entre e depois desses <span class="math inline">\(a\)</span>’s. O Fechamento de Kleene externo, <code>$(...)^*</code>, permite que este bloco contendo dois <span class="math inline">\(a\)</span>’s se repita zero ou mais vezes. Se o bloco se repete <span class="math inline">\(k\)</span> vezes, o número total de <span class="math inline">\(a\)</span>’s será <span class="math inline">\(2k\)</span>, que é sempre um número par (0, 2, 4, …). O <span class="math inline">\(b^*\)</span> no início permite que a <em>string</em> comece com <span class="math inline">\(b\)</span>’s ou, caso o bloco não se repita nenhuma vez, gere <em>strings</em> compostas apenas por <span class="math inline">\(b\)</span>’s (que possuem zero <span class="math inline">\(a\)</span>’s, e zero é par).</p>
<p><strong><span class="math inline">\(L(r_2)\)</span> contém</strong>: <span class="math inline">\(\{b, bb, abab, aab, baab, bbaabb, \ldots\}\)</span>. <strong><span class="math inline">\(L(r_2)\)</span> não contém</strong>: <span class="math inline">\(\{a, bbbab, aaabb, \ldots\}\)</span>.</p></li>
<li><p><strong>Exemplo 3</strong>: Identificadores que começam com letra <span class="math display">\[r_3 = (a \cup b \cup \ldots \cup z)(a \cup b \cup \ldots \cup z \cup 0 \cup 1 \cup \ldots \cup 9)^*\]</span></p>
<p><strong>Análise</strong>: Esta expressão regular define uma regra clássica para identificadores (nomes de variáveis, funções, etc.) em muitas linguagens de programação. Ela é composta por duas partes concatenadas que impõem uma estrutura rígida:</p>
<ul>
<li>A primeira parte, <code>$(a \cup b \cup \ldots \cup z)$</code>, estabelece a condição para o caractere inicial. Ela exige que a <em>string</em> comece com exatamente uma letra minúscula.</li>
<li>A segunda parte, <code>$(a \cup b \cup \ldots \cup z \cup 0 \cup 1 \cup \ldots \cup 9)^*$</code>, define os caracteres subsequentes. O Fechamento de Kleene (<code>$*$</code>) permite que o caractere inicial seja seguido por uma sequência de zero ou mais caracteres, que podem ser letras minúsculas ou dígitos.</li>
</ul>
<p><strong><span class="math inline">\(L(r_3)\)</span> contém</strong>: <code>{x, nome, var1, contador, a1b2c3, ...}</code>. <strong><span class="math inline">\(L(r_3)\)</span> não contém</strong>: <code>{1var, _nome, temp-1, $var, ...}</code>.</p></li>
<li><p><strong>Exemplo 4</strong>: Números inteiros com sinal opcional <span class="math display">\[r_4 = (\epsilon \cup + \cup -)(0 \cup 1 \cup \ldots \cup 9)(0 \cup 1 \cup \ldots \cup 9)^*\]</span></p>
<p><strong>Análise</strong>: Esta expressão é construída em três partes lógicas para capturar a estrutura de um número inteiro:</p>
<ol type="1">
<li><code>$(\epsilon \cup + \cup -)$</code>: A primeira parte define o prefixo do número. A união com a <em>string</em> vazia (<code>$\epsilon$</code>) torna o caractere de sinal (<code>+</code> ou <code>-</code>) opcional. Isso permite que o número comece diretamente com um dígito.</li>
<li><code>$(0 \cup 1 \cup \ldots \cup 9)$</code>: Esta parte garante que, após o sinal (ou a ausência dele), exista <strong>pelo menos um</strong> dígito. Isso é fundamental para invalidar <em>strings</em> que contenham apenas um sinal, como <code>+</code> ou <code>-</code>.</li>
<li><code>$(0 \cup 1 \cup \ldots \cup 9)^*</code>: O Fechamento de Kleene na parte final permite que este primeiro dígito seja seguido por uma sequência de zero ou mais dígitos adicionais, formando números de qualquer comprimento.</li>
</ol>
<p><strong><span class="math inline">\(L(r_4)\)</span> contém</strong>: <code>{42, -199, +7, 0, 9, 007, ...}</code>. <strong><span class="math inline">\(L(r_4)\)</span> não contém</strong>: <code>{\epsilon, +, -, --5, 1+1, 9A, ...}</code>.</p>
<p><strong>Nota sobre a limitação</strong>: é importante que a atenta leitora note que esta expressão regular, embora funcional, aceita números com zeros à esquerda (como <code>007</code>), o que pode não ser desejável em todos os contextos de programação ou validação. Expressões mais complexas podem ser criadas para proibir essa característica, por exemplo, tratando o <code>0</code> como um caso especial separado de números que começam com <code>$[1-9]$</code>.</p></li>
</ol>
<p>Esses exemplos demonstram a notável versatilidade das expressões regulares. Com apenas três operações fundamentais — união, concatenação e Fechamento de Kleene — somos capazes de descrever uma vasta gama de padrões, desde sequências simples e finitas até conjuntos infinitos com regras estruturais complexas. Fica evidente como essa ferramenta se torna indispensável na análise léxica, validação de dados e em inúmeras outras tarefas da computação. Contudo, apesar de seu poder, veremos adiante que existem linguagens, até mesmo algumas com descrições aparentemente simples, que transcendem a capacidade expressiva das expressões regulares.</p>
<section id="sec-ex-regex2" class="level4" data-number="3.4.4.1">
<h4 data-number="3.4.4.1" class="anchored" data-anchor-id="sec-ex-regex2"><span class="header-section-number">3.4.4.1</span> Exercícios 5</h4>
<ol type="1">
<li>Baseando-se no exemplo de <em>strings</em> terminando em <span class="math inline">\(01\)</span>:
<ol type="a">
<li>Construa uma expressão para <em>strings</em> terminando em <span class="math inline">\(10\)</span>;</li>
<li>Construa uma expressão para <em>strings</em> começando com <span class="math inline">\(01\)</span>;</li>
<li>Construa uma expressão para <em>strings</em> que contêm <span class="math inline">\(01\)</span> como substring;</li>
<li>Construa uma expressão para <em>strings</em> que <strong>não</strong> contêm <span class="math inline">\(01\)</span>.</li>
</ol></li>
<li>Inspirando-se no exemplo de número par de <span class="math inline">\(a\)</span>’s:
<ol type="a">
<li>Construa uma expressão para <em>strings</em> com número ímpar de <span class="math inline">\(a\)</span>’s sobre <span class="math inline">\(\{a,b\}\)</span>;</li>
<li>Construa uma expressão para <em>strings</em> com número múltiplo de 3 de <span class="math inline">\(a\)</span>’s;</li>
<li>Construa uma expressão para <em>strings</em> com pelo menos dois <span class="math inline">\(a\)</span>’s.</li>
</ol></li>
<li>Baseando-se no padrão de identificadores:
<ol type="a">
<li>Modifique para permitir underscores em qualquer posição;</li>
<li>Modifique para proibir dígitos na primeira e última posições;</li>
<li>Crie um padrão para identificadores que devem ter entre 3 e 8 caracteres.</li>
</ol></li>
<li>Estendendo o exemplo de números inteiros:
<ol type="a">
<li>Construa uma expressão para números decimais (com ponto decimal);</li>
<li>Construa uma expressão para números em notação científica simples (<span class="math inline">\(1e5\)</span>, <span class="math inline">\(2e-3\)</span>);</li>
<li>Construa uma expressão para números hexadecimais com prefixo <span class="math inline">\(0x\)</span>.</li>
</ol></li>
<li>Para as expressões construídas nos exercícios anteriores:
<ol type="a">
<li>Verifique se as <em>strings</em> <span class="math inline">\(\{101, 1010, 0101\}\)</span> pertencem ao padrão <em>termina em 10</em>;</li>
<li>Verifique se <span class="math inline">\(\{aab, baba, ababa\}\)</span> têm número ímpar de <span class="math inline">\(a\)</span>’s;</li>
<li>Teste se <span class="math inline">\(\{var_1, _temp, item2_\}\)</span> são identificadores válidos com underscores.</li>
</ol></li>
</ol>
</section>
</section>
<section id="equivalência-de-expressões-regulares-e-suas-leis-algébricas" class="level3" data-number="3.4.5">
<h3 data-number="3.4.5" class="anchored" data-anchor-id="equivalência-de-expressões-regulares-e-suas-leis-algébricas"><span class="header-section-number">3.4.5</span> Equivalência de Expressões Regulares e suas Leis Algébricas</h3>
<p>Ao explorarmos o poder das expressões regulares, a atenta leitora descobrirá que diferentes expressões podem, na verdade, descrever exatamente a mesma linguagem. De forma análoga à álgebra tradicional, onde <span class="math inline">\(x(y+z)\)</span> e <span class="math inline">\(xy + xz\)</span> são formulações distintas para o mesmo resultado, na teoria das linguagens podemos ter duas expressões sintaticamente diferentes que são semanticamente idênticas. Essa noção de equivalência não é apenas uma curiosidade teórica; ela é fundamental para a otimização e simplificação de padrões, permitindo-nos encontrar a representação mais concisa ou computacionalmente mais eficiente para uma dada linguagem.</p>
<p>A perspicaz leitora perceberá que a capacidade de manipular expressões e transformá-las em formas equivalentes, porém mais simples, é uma habilidade poderosa, especialmente na construção de analisadores léxicos e ferramentas de processamento de texto.</p>
<p>Formalmente, duas expressões regulares <span class="math inline">\(r\)</span> e <span class="math inline">\(s\)</span> são ditas <strong>equivalentes</strong>, o que denotamos por <span class="math inline">\(r \equiv s\)</span>, se, e somente se, elas denotam a mesma linguagem. Matematicamente, isso é expresso como:</p>
<p><span class="math display">\[r \equiv s \iff L(r) = L(s)\]</span></p>
<p>Para manipular e simplificar expressões regulares, contamos com um conjunto de leis algébricas que governam as operações de união, concatenação e fechamento de Kleene. Estas leis são a base para a otimização de padrões.</p>
<section id="principais-leis-algébricas" class="level4" data-number="3.4.5.1">
<h4 data-number="3.4.5.1" class="anchored" data-anchor-id="principais-leis-algébricas"><span class="header-section-number">3.4.5.1</span> Principais Leis Algébricas</h4>
<p>A seguir, apresentamos as identidades mais importantes que as expressões regulares satisfazem. Para expressões regulares <span class="math inline">\(r\)</span>, <span class="math inline">\(s\)</span> e <span class="math inline">\(t\)</span>:</p>
<section id="leis-associativas-e-comutativas" class="level5" data-number="3.4.5.1.1">
<h5 data-number="3.4.5.1.1" class="anchored" data-anchor-id="leis-associativas-e-comutativas"><span class="header-section-number">3.4.5.1.1</span> Leis Associativas e Comutativas</h5>
<p>Estas leis nos permitem reagrupar e reordenar os termos em operações de união e concatenação.</p>
<ol type="1">
<li><p><strong>Comutatividade da União</strong>: a ordem na união não importa. <span class="math display">\[r \cup s \equiv s \cup r\]</span></p></li>
<li><p><strong>Associatividade da União</strong>: podemos agrupar uniões de qualquer forma. <span class="math display">\[(r \cup s) \cup t \equiv r \cup (s \cup t)\]</span></p></li>
<li><p><strong>Associatividade da Concatenação</strong>: o agrupamento na concatenação também é flexível. Lembre-se, no entanto, que a concatenação <em>não é</em> comutativa (<span class="math inline">\(rs \not\equiv sr\)</span> em geral). <span class="math display">\[(rs)t \equiv r(st)\]</span></p></li>
</ol>
</section>
<section id="leis-de-identidade-e-anulação" class="level5" data-number="3.4.5.1.2">
<h5 data-number="3.4.5.1.2" class="anchored" data-anchor-id="leis-de-identidade-e-anulação"><span class="header-section-number">3.4.5.1.2</span> Leis de Identidade e Anulação</h5>
<p>Estas leis definem o papel dos elementos especiais <span class="math inline">\(\epsilon\)</span> (a <em>string</em> vazia) e <span class="math inline">\(\emptyset\)</span> (a linguagem vazia).</p>
<ol type="1">
<li><p><strong>Elemento Neutro da Concatenação</strong>: A <em>string</em> vazia é o elemento neutro da concatenação. <span class="math display">\[r\epsilon \equiv \epsilon r \equiv r\]</span></p></li>
<li><p><strong>Elemento Anulador da Concatenação</strong>: Concatenar com a linguagem vazia resulta na linguagem vazia. <span class="math display">\[r\emptyset \equiv \emptyset r \equiv \emptyset\]</span></p></li>
<li><p><strong>Elemento Neutro da União</strong>: A linguagem vazia é o elemento neutro da união. <span class="math display">\[r \cup \emptyset \equiv \emptyset \cup r \equiv r\]</span></p></li>
</ol>
</section>
<section id="lei-distributiva" class="level5" data-number="3.4.5.1.3">
<h5 data-number="3.4.5.1.3" class="anchored" data-anchor-id="lei-distributiva"><span class="header-section-number">3.4.5.1.3</span> Lei Distributiva</h5>
<p>Esta lei conecta as operações de concatenação e união, de forma muito semelhante à álgebra numérica.</p>
<ol type="1">
<li><strong>Distributividade da Concatenação sobre a União</strong>: <span class="math display">\[r(s \cup t) \equiv rs \cup rt\]</span> <span class="math display">\[(s \cup t)r \equiv sr \cup tr\]</span></li>
</ol>
</section>
<section id="lei-da-idempotência" class="level5" data-number="3.4.5.1.4">
<h5 data-number="3.4.5.1.4" class="anchored" data-anchor-id="lei-da-idempotência"><span class="header-section-number">3.4.5.1.4</span> Lei da Idempotência</h5>
<p>Esta lei estabelece que a união de uma expressão com ela mesma não adiciona nada novo.</p>
<ol type="1">
<li><strong>Idempotência da União</strong>: <span class="math display">\[r \cup r \equiv r\]</span></li>
</ol>
</section>
<section id="leis-do-fechamento-de-kleene" class="level5" data-number="3.4.5.1.5">
<h5 data-number="3.4.5.1.5" class="anchored" data-anchor-id="leis-do-fechamento-de-kleene"><span class="header-section-number">3.4.5.1.5</span> Leis do Fechamento de Kleene</h5>
<p>Estas propriedades definem a natureza do operador de fechamento.</p>
<ol type="1">
<li><strong>Definição Recursiva</strong>: o fechamento de <span class="math inline">\(r\)</span> é a <em>string</em> vazia ou um <span class="math inline">\(r\)</span> seguido por mais <em>r’s</em>. <span class="math display">\[r^* \equiv \epsilon \cup rr^*\]</span></li>
</ol>
<p>2.<strong>Fechamento do Fechamento</strong>: aplicar o fechamento duas vezes é redundante.</p>
<pre><code>$$(r^*)^* \equiv r^*$$</code></pre>
<ol start="3" type="1">
<li><p><strong>Fechamento da Linguagem Vazia</strong>: A única <em>string</em> que pode ser formada por zero ou mais escolhas da linguagem vazia é a <em>string</em> vazia.</p>
<p><span class="math display">\[\emptyset^* \equiv \epsilon\]</span></p></li>
<li><p><strong>Fechamento da <em>string</em> Vazia</strong>: o mesmo se aplica à linguagem contendo apenas a <em>string</em> vazia.</p>
<p><span class="math display">\[\epsilon^* \equiv \epsilon\]</span></p></li>
</ol>
</section>
</section>
<section id="exemplo-prático-de-simplificação" class="level4" data-number="3.4.5.2">
<h4 data-number="3.4.5.2" class="anchored" data-anchor-id="exemplo-prático-de-simplificação"><span class="header-section-number">3.4.5.2</span> Exemplo Prático de Simplificação</h4>
<p>Para que a atenta leitora possa ver a utilidade dessas leis em ação, vamos simplificar a expressão regular <span class="math inline">\(r = a(b \cup c) \cup ab\)</span>. Nosso objetivo é encontrar uma expressão equivalente que seja mais curta.</p>
<ol type="1">
<li><p><strong>Expressão Inicial</strong>: <span class="math inline">\(r = a(b \cup c) \cup ab\)</span></p></li>
<li><p><strong>Aplicar a Distributividade</strong>: usamos a lei distributiva à esquerda no termo <span class="math inline">\(a(b \cup c)\)</span>.</p>
<p><span class="math display">\[r \equiv (ab \cup ac) \cup ab\]</span></p></li>
<li><p><strong>Aplicar a Comutatividade</strong>: reordenamos os termos da união para agrupar os termos idênticos.</p>
<p><span class="math display">\[r \equiv ab \cup ab \cup ac\]</span></p></li>
<li><p><strong>Aplicar a Idempotência</strong>: a união de <span class="math inline">\(ab\)</span> com <span class="math inline">\(ab\)</span> é simplesmente <span class="math inline">\(ab\)</span>.</p>
<p><span class="math display">\[r \equiv ab \cup ac\]</span></p></li>
<li><p><strong>Chegamos à expressão</strong>: <span class="math inline">\(s = ab \cup ac\)</span>. Como <span class="math inline">\(L(r) = L(s)\)</span>.</p></li>
</ol>
<p>As expressões são equivalentes (<span class="math inline">\(a(b \cup c) \cup ab \equiv ab \cup ac\)</span>), mas a segunda é visivelmente mais simples. Essa capacidade de simplificação tem valor prático no projeto de compiladores e em sistemas de busca de texto.</p>
</section>
<section id="sec-ex-regex3" class="level4" data-number="3.4.5.3">
<h4 data-number="3.4.5.3" class="anchored" data-anchor-id="sec-ex-regex3"><span class="header-section-number">3.4.5.3</span> Exercícios 6</h4>
<ol type="1">
<li>Use as leis algébricas para simplificar:
<ol type="a">
<li><span class="math inline">\((a \cup \emptyset)b\)</span>;</li>
<li><span class="math inline">\(a(\epsilon \cup b)\)</span>;</li>
<li><span class="math inline">\((a \cup a)^*\)</span>;</li>
<li><span class="math inline">\(a \cup ab^*a\)</span>.</li>
</ol></li>
<li>Simplifique a expressão <span class="math inline">\(((a \cup b)a) \cup (aa)\)</span> usando as leis passo a passo:
<ol type="a">
<li>Identifique que leis podem ser aplicadas;</li>
<li>Mostre cada passo da simplificação;</li>
<li>Verifique o resultado testando <em>strings</em> específicas.</li>
</ol></li>
<li>Prove que as seguintes expressões são equivalentes:
<ol type="a">
<li><span class="math inline">\(a^*a\)</span> e <span class="math inline">\(aa^*\)</span>;</li>
<li><span class="math inline">\((a \cup b)^*\)</span> e <span class="math inline">\(\epsilon \cup (a \cup b)(a \cup b)^*\)</span>;</li>
<li><span class="math inline">\(a^*b^*\)</span> e <span class="math inline">\((a \cup b)^*\)</span> (esta é falsa - encontre um contraexemplo).</li>
</ol></li>
<li>Simplifique usando as leis do fechamento:
<ol type="a">
<li><span class="math inline">\((a^*)^*\)</span>;</li>
<li><span class="math inline">\(\epsilon^* \cup a^*\)</span>;</li>
<li><span class="math inline">\(\emptyset^* \cup a\)</span>;</li>
<li><span class="math inline">\((a \cup \epsilon)^*\)</span>.</li>
</ol></li>
<li>Para a expressão <span class="math inline">\(ab^* \cup abb^* \cup abbb^*\)</span>:
<ol type="a">
<li>Identifique o padrão comum;</li>
<li>Use a distributividade para fatorar;</li>
<li>Simplifique usando propriedades do fechamento de Kleene;</li>
<li>Verifique que as linguagens são idênticas.</li>
</ol></li>
</ol>
</section>
</section>
<section id="notações-convencionais-adicionais" class="level3" data-number="3.4.6">
<h3 data-number="3.4.6" class="anchored" data-anchor-id="notações-convencionais-adicionais"><span class="header-section-number">3.4.6</span> Notações Convencionais Adicionais</h3>
<p>Embora as três operações fundamentais, união (<span class="math inline">\(\cup\)</span>), concatenação (<span class="math inline">\(\cdot\)</span>) e fechamento de Kleene (<span class="math inline">\(*\)</span>), sejam teoricamente suficientes para descrever qualquer Linguagem Regular, na prática, elas podem gerar expressões longas, repetitivas e de difícil leitura. Para contornar essa complexidade, foram introduzidas diversas notações adicionais que funcionam como abreviações ou <em>macros</em>.</p>
<p>A criativa leitora pode enxergar estas notações como <em>funções</em> ou <em>módulos</em> predefinidos: elas não adicionam um novo poder teórico ao formalismo, mas aumentam a expressividade e a conveniência da escrita, permitindo construir padrões complexos de forma mais limpa e intuitiva. Dominar estas abreviações é um passo importante para escrever expressões regulares eficazes no mundo real.</p>
<p>A seguir, detalhamos as notações mais comuns.</p>
<ol type="1">
<li><p><strong>Fechamento Positivo (<span class="math inline">\(r^+\)</span>)</strong></p>
<ul>
<li><strong>Definição</strong>: É uma abreviação para <em>uma ou mais</em> ocorrências de <span class="math inline">\(r\)</span>. Formalmente, <span class="math inline">\(r^+ \equiv rr^*\)</span>.</li>
<li><strong>Análise</strong>: Enquanto <span class="math inline">\(r^*\)</span> corresponde a zero ou mais repetições, <span class="math inline">\(r^+\)</span> exige que o padrão ocorra pelo menos uma vez. É uma das abreviações mais utilizadas.</li>
</ul></li>
</ol>
<p><strong>Exemplo</strong>: Para descrever números inteiros positivos, podemos usar a expressão <span class="math inline">\([1-9][0-9]^*\)</span>. Usando o fechamento positivo, a expressão para um ou mais dígitos, <span class="math inline">\([0-9]^+\)</span>, pode ser mais intuitiva em certos contextos, embora a primeira seja mais precisa para evitar zeros à esquerda. Um exemplo mais direto é <span class="math inline">\(a^+\)</span>, que denota a linguagem <span class="math inline">\(\{a, aa, aaa, \ldots\}\)</span>, sendo mais concisa que <span class="math inline">\(aa^*\)</span>.</p>
<ol type="1">
<li><p><strong>Opcionalidade (<span class="math inline">\(r?\)</span>)</strong></p>
<p><strong>Definição</strong>: Indica que a expressão <span class="math inline">\(r\)</span> é opcional, podendo aparecer uma ou nenhuma vez. É um atalho para <span class="math inline">\((\epsilon \cup r)\)</span>. <strong>Análise</strong>: Esta notação é perfeita para partes de um padrão que podem ou não estar presentes.</p>
<p><strong>Exemplo</strong>: Para validar URLs que podem ser <code>http</code> ou <code>https</code> (com ‘s’ opcional), usamos a expressão <code>https?</code>. Ela corresponde a <code>http</code> ou <code>https</code>. Outro exemplo seria modelar um número com sinal opcional: <span class="math inline">\((+ \cup -)? [0-9]^+\)</span>.</p></li>
<li><p><strong>Classes de Caracteres (<span class="math inline">\([\ldots]\)</span>)</strong></p>
<p><strong>Definição</strong>: Funcionam como uma abreviação para uma união de múltiplos caracteres. Por exemplo, <span class="math inline">\([abc] \equiv (a \cup b \cup c)\)</span>. <strong>Análise</strong>: Tornam a expressão muito mais compacta quando precisamos permitir um de vários caracteres possíveis em uma determinada posição.</p>
<p><strong>Exemplo</strong>: Para encontrar qualquer vogal minúscula, em vez de escrever <span class="math inline">\((a \cup e \cup i \cup o \cup u)\)</span>, podemos simplesmente usar <span class="math inline">\([aeiou]\)</span>.</p></li>
<li><p><strong>Intervalos em Classes de Caracteres (<span class="math inline">\([a-z]\)</span>)</strong></p>
<p><strong>Definição</strong>: Dentro de uma classe de caracteres, o hífen <code>-</code> pode ser usado para denotar um intervalo de símbolos com base em uma ordem convencional (como a da tabela ASCII). <strong>Análise</strong>: Esta é uma generalização poderosa das classes de caracteres, evitando a necessidade de listar todos os símbolos individualmente.</p>
<p><strong>Exemplo</strong>: Para descrever uma letra minúscula qualquer, usamos <span class="math inline">\([a-z]\)</span>. Para um dígito hexadecimal, podemos combinar intervalos: <span class="math inline">\([0-9a-fA-F]\)</span>.</p></li>
<li><p><strong>Negação de Classes de Caracteres (<span class="math inline">\([^\ldots]\)</span>)</strong></p>
<p><strong>Definição</strong>: O acento circunflexo <code>^</code>, quando é o primeiro símbolo dentro de uma classe, nega o conjunto. A classe passa a corresponder a qualquer caractere do alfabeto <span class="math inline">\(\Sigma\)</span> <em>exceto</em> os que estão listados. <strong>Análise</strong>: É útil para especificar proibições, ou seja, tudo, exceto um pequeno conjunto de caracteres.</p>
<p><strong>Exemplo</strong>: Uma expressão para encontrar uma <em>string</em> que não contenha vogais poderia usar <span class="math inline">\([^aeiou]\)</span>. Para encontrar um caractere que não é um dígito, usamos <span class="math inline">\([^0-9]\)</span>.</p></li>
<li><p><strong>Quantificadores de Repetição (<span class="math inline">\(\{n, m\}\)</span>)</strong></p>
<p><strong>Definição</strong>: Oferecem um controle preciso sobre o número de repetições de uma expressão <span class="math inline">\(r\)</span>. <strong>Análise</strong>: Generalizam as operações <span class="math inline">\(?\)</span>, <span class="math inline">\(*\)</span> e <span class="math inline">\(+\)</span>, permitindo especificar limites exatos, mínimos ou intervalos de ocorrências.</p>
<ul>
<li><span class="math inline">\(r\{n\}\)</span>: <span class="math inline">\(r\)</span> repetido exatamente <span class="math inline">\(n\)</span> vezes.</li>
<li><span class="math inline">\(r\{n,m\}\)</span>: <span class="math inline">\(r\)</span> repetido no mínimo <span class="math inline">\(n\)</span> e no máximo <span class="math inline">\(m\)</span> vezes.</li>
<li><span class="math inline">\(r\{n,\}\)</span>: <span class="math inline">\(r\)</span> repetido pelo menos <span class="math inline">\(n\)</span> vezes.</li>
</ul>
<p><strong>Exemplos</strong>:</p>
<ol type="a">
<li><strong>CEP Brasileiro</strong>: Um CEP no formato <code>XXXXX-XXX</code> pode ser descrito por <span class="math inline">\([0-9]\{5\}-[0-9]\{3\}\)</span>.</li>
<li><strong>Validade de Senha</strong>: Uma regra de senha que exige de <span class="math inline">\(8\)</span> a <span class="math inline">\(16\)</span> caracteres alfanuméricos pode ser modelada por <span class="math inline">\([a-zA-Z0-9]\{8,16\}\)</span>.</li>
<li><strong>Identificador Mínimo</strong>: Um nome de variável que precisa ter pelo menos <span class="math inline">\(3\)</span> caracteres, começando com uma letra e seguido por letras ou números, pode ser escrito como <span class="math inline">\([a-zA-Z][a-zA-Z0-9]\{2,\}\)</span>.</li>
</ol></li>
</ol>
<section id="sec-ex-regex4" class="level4" data-number="3.4.6.1">
<h4 data-number="3.4.6.1" class="anchored" data-anchor-id="sec-ex-regex4"><span class="header-section-number">3.4.6.1</span> Exercícios 7</h4>
<ol type="1">
<li>Reescreva usando apenas união (<span class="math inline">\(\cup\)</span>), concatenação e fechamento de Kleene (<span class="math inline">\(*\)</span>):
<ol type="a">
<li><span class="math inline">\(a^+\)</span>;</li>
<li><span class="math inline">\(b?\)</span>;</li>
<li><span class="math inline">\([abc]\)</span>;</li>
<li><span class="math inline">\(a\{3\}\)</span>;</li>
<li><span class="math inline">\(b\{2,4\}\)</span>.</li>
</ol></li>
<li>Construa expressões usando classes de caracteres para:
<ol type="a">
<li>Qualquer dígito: <span class="math inline">\([0-9]\)</span>;</li>
<li>Qualquer letra minúscula: <span class="math inline">\([a-z]\)</span>;</li>
<li>Qualquer caractere que não seja espaço: <span class="math inline">\([^ ]\)</span>;</li>
<li>Qualquer caractere alfanumérico: <span class="math inline">\([a-zA-Z0-9]\)</span>.</li>
</ol></li>
<li>Use quantificadores para construir padrões para:
<ol type="a">
<li>CEP brasileiro no formato <span class="math inline">\(99999-999\)</span>;</li>
<li>Placa de carro brasileira antiga <span class="math inline">\(AAA-9999\)</span>;</li>
<li>Senha com exatamente 8 caracteres alfanuméricos;</li>
<li>Código de área de telefone com 2 ou 3 dígitos.</li>
</ol></li>
<li>Construa expressões regulares para validar:
<ol type="a">
<li>URL simples começando com <span class="math inline">\(http\)</span> ou <span class="math inline">\(https\)</span>;</li>
<li>Data no formato <span class="math inline">\(dd/mm/aaaa\)</span> (versão simples);</li>
<li>Horário no formato <span class="math inline">\(hh:mm\)</span> (24 horas);</li>
<li>Número de CPF no formato <span class="math inline">\(999.999.999-99\)</span>.</li>
</ol></li>
<li>Reescreva as seguintes expressões de forma mais concisa:
<ol type="a">
<li><span class="math inline">\((a \cup b \cup c \cup d)(a \cup b \cup c \cup d)^*\)</span>;</li>
<li><span class="math inline">\(a(\epsilon \cup b)\)</span>;</li>
<li><span class="math inline">\((0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)(0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)^*\)</span>;</li>
</ol></li>
</ol>
</section>
</section>
<section id="aplicações-práticas" class="level3" data-number="3.4.7">
<h3 data-number="3.4.7" class="anchored" data-anchor-id="aplicações-práticas"><span class="header-section-number">3.4.7</span> Aplicações Práticas</h3>
<p>Após a jornada pelos fundamentos matemáticos, a curiosa leitora pode estar se perguntando: onde essa teoria se manifesta no dia a dia da computação? A resposta curta é: em praticamente todos os lugares. As expressões regulares representam um dos casos mais bem-sucedidos de uma teoria matemática que transcendeu a academia e se tornou uma ferramenta indispensável, utilizada diariamente por desenvolvedores de software, administradores de sistemas e cientistas de dados.</p>
<p>Para a resposta longa precisamos abandonar o formalismo puro para ilustrar como as expressões regulares, com suas notações concisas, resolvem problemas concretos.</p>
<section id="análise-léxica-em-compiladores" class="level4" data-number="3.4.7.1">
<h4 data-number="3.4.7.1" class="anchored" data-anchor-id="análise-léxica-em-compiladores"><span class="header-section-number">3.4.7.1</span> Análise Léxica em Compiladores</h4>
<p>A análise léxica é a primeira fase da compilação de um programa. O analisador, chamado de <em>scanner</em> ou <em>lexer</em>, lê o código-fonte como uma sequência de caracteres e a converte em uma sequência de <em>tokens</em>, unidades lexicais como identificadores, palavras-chave, números e operadores. Cada tipo de <em>token</em> é definido precisamente por um padrão, que é, em sua essência, uma expressão regular.</p>
<p><strong>Exemplo 1: identificadores</strong>: nomes de variáveis, funções, etc..</p>
<p><strong>Padrão</strong>: <code>[a-zA-Z_][a-zA-Z0-9_]*</code>. <strong>Análise</strong>: Este padrão decreta que um identificador deve começar com uma letra (maiúscula ou minúscula) ou um underscore (<code>[a-zA-Z_]</code>), seguido por zero ou mais caracteres que podem ser letras, números ou underscores (<code>[a-zA-Z0-9_]*</code>).</p>
<p><strong>Exemplo 2: números inteiros</strong>:</p>
<p><strong>Padrão</strong>: <code>-?[1-9][0-9]*|0</code>. <strong>Análise</strong>: Este padrão elegante lida com vários casos. O <code>-?</code> torna o sinal de negativo opcional. O trecho <code>[1-9][0-9]*</code> garante que números com múltiplos dígitos não comecem com zero (como <code>042</code>). Por fim, o <code>|0</code> trata o número zero como um caso especial.</p>
</section>
<section id="validação-de-dados-de-entrada" class="level4" data-number="3.4.7.2">
<h4 data-number="3.4.7.2" class="anchored" data-anchor-id="validação-de-dados-de-entrada"><span class="header-section-number">3.4.7.2</span> Validação de Dados de Entrada</h4>
<p>Em qualquer aplicação que receba dados de um usuário, é vital garantir que esses dados estejam no formato correto antes de serem processados. As expressões regulares são a ferramenta padrão para essa tarefa de validação.</p>
<p><strong>Exemplo 1: endereço de e-mail (Muito Simplificado)</strong>:</p>
<p><strong>Padrão</strong>: <code>[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}</code> <strong>Análise</strong>: Embora um padrão de e-mail 100% compatível com as RFCs seja extremamente complexo, esta versão simplificada cobre a maioria dos casos. Ela busca: uma sequência de caracteres de usuário (<code>[...]+</code>), o símbolo <code>@</code>, uma sequência de caracteres de domínio (<code>[...]+</code>), um ponto literal (<code>\.</code>) e, por fim, o domínio de topo (TLD) com pelo menos duas letras (<code>[a-zA-Z]{2,}</code>).</p>
</section>
<section id="telefone-formato-brasileiro" class="level4" data-number="3.4.7.3">
<h4 data-number="3.4.7.3" class="anchored" data-anchor-id="telefone-formato-brasileiro"><span class="header-section-number">3.4.7.3</span> Telefone (Formato Brasileiro)</h4>
<p><strong>Padrão</strong>: <code>\([0-9]{2}\) ?[0-9]{4,5}-[0-9]{4}</code> <strong>Análise</strong>: Este padrão modela um número de telefone comum no Brasil, incluindo o DDD entre parênteses e um espaço opcional e pode ser dividido nas seguintes partes:</p>
<ol type="1">
<li><code>\(</code> e <code>\)</code>: Correspondem aos parênteses literais. Como <code>(</code> e <code>)</code> são metacaracteres em expressões regulares, eles precisam ser <em>escapados</em> com uma barra invertida para serem tratados como caracteres literais;</li>
<li><code>[0-9]{2}</code>: Exige exatamente dois dígitos numéricos para o código de área (DDD);</li>
<li><code>?</code>: Permite a existência opcional de um único caractere de espaço após os parênteses do DDD;</li>
<li><code>[0-9]{4,5}</code>: Captura a primeira parte do número, que pode ter 4 ou 5 dígitos, acomodando tanto números fixos quanto números móveis que já adotaram o nono dígito;</li>
<li><code>-[0-9]{4}</code>: Corresponde ao hífen literal e aos 4 dígitos finais do número.</li>
</ol>
</section>
<section id="busca-extração-e-substituição-de-texto" class="level4" data-number="3.4.7.4">
<h4 data-number="3.4.7.4" class="anchored" data-anchor-id="busca-extração-e-substituição-de-texto"><span class="header-section-number">3.4.7.4</span> Busca, Extração e Substituição de Texto</h4>
<p>Esta é talvez a aplicação mais visível das expressões regulares, formando o coração de ferramentas como <code>grep</code> e <code>sed</code> em sistemas Unix, e as funcionalidades de <em>Localizar e Substituir</em> em editores de texto e ambientes integrados de edição (IDEs).</p>
<p><strong>Exemplo 1: busca por Palavras Exatas</strong>:</p>
<p><strong>Padrão</strong>: <code>\b[Pp]alavra\b</code> <strong>Análise</strong>: O <code>\b</code> é uma <em>âncora</em> que corresponde a uma fronteira de palavra (<em>word boundary</em>). Isso garante que a busca encontre <em>palavra</em> como uma palavra inteira, e não como parte de <em>subpalavra</em>. O <code>[Pp]</code> torna a busca insensível a maiúsculas para a primeira letra.</p>
</section>
<section id="hora-formato-24h-hhmm-ou-hhmmss" class="level4" data-number="3.4.7.5">
<h4 data-number="3.4.7.5" class="anchored" data-anchor-id="hora-formato-24h-hhmm-ou-hhmmss"><span class="header-section-number">3.4.7.5</span> Hora (Formato 24h: HH:MM ou HH:MM:SS)</h4>
<p><strong>Padrão</strong>: <code>([01][0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?</code> <strong>Análise</strong>: Este é um excelente exemplo de como expressões regulares podem validar formatos com regras numéricas. Ele valida horas no formato 24h, com segundos opcionais e pode ser dividido em partes:</p>
<ol type="1">
<li><code>([01][0-9]|2[0-3])</code>: Esta parte valida as horas. A união <code>|</code> cria duas possibilidades: ou um dígito de <code>0</code> ou <code>1</code> seguido por qualquer dígito (<code>00</code>-<code>19</code>), ou o dígito <code>2</code> seguido por um dígito de <code>0</code> a <code>3</code> (<code>20</code>-<code>23</code>).</li>
<li><code>:</code>: Corresponde ao separador literal.</li>
<li><code>[0-5][0-9]</code>: Valida os minutos, garantindo que estejam no intervalo de <code>00</code> a <code>59</code>.</li>
<li><code>(:[0-5][0-9])?</code>: Esta parte torna os segundos opcionais. Os parênteses agrupam o separador <code>:</code> e os dígitos dos segundos. O quantificador <code>?</code> aplicado a este grupo faz com que toda a seção de segundos (<code>:SS</code>) possa aparecer uma ou nenhuma vez.</li>
</ol>
<p><strong><span class="math inline">\(L(r)\)</span> contém</strong>: <code>{14:30, 09:15, 23:59:59, 00:00}</code>. <strong><span class="math inline">\(L(r)\)</span> não contém</strong>: <code>{25:00, 12:61, 9:30, 14:30:, 15:10:99}</code>.</p>
<p>Esses exemplos arranham apenas a superfície, mas demonstram a imensa versatilidade das expressões regulares. Elas formam uma ponte poderosa entre a teoria formal das linguagens e a resolução de problemas práticos e onipresentes no desenvolvimento de software.</p>
</section>
</section>
<section id="sec-ex-regex5" class="level3" data-number="3.4.8">
<h3 data-number="3.4.8" class="anchored" data-anchor-id="sec-ex-regex5"><span class="header-section-number">3.4.8</span> Exercícios 8</h3>
<ol type="1">
<li>Projete expressões regulares para tokens de uma linguagem de programação simples:
<ol type="a">
<li>Palavras-chave: <span class="math inline">\(\{\text{if}, \text{then}, \text{else}, \text{while}, \text{do}\}\)</span>;</li>
<li>Números inteiros (incluindo negativos);</li>
<li>Comentários de linha iniciados por <span class="math inline">\(//\)</span>;</li>
<li>Operadores relacionais: <span class="math inline">\(\{&lt;, &gt;, &lt;=, &gt;=, ==, !=\}\)</span>.</li>
</ol></li>
<li>Construa expressões regulares para validar:
<ol type="a">
<li>Telefone celular: <span class="math inline">\((11) 99999-9999\)</span>;</li>
<li>RG: <span class="math inline">\(99.999.999-9\)</span>;</li>
<li>CNPJ: <span class="math inline">\(99.999.999/9999-99\)</span>;</li>
<li>CEP: <span class="math inline">\(99999-999\)</span> ou <span class="math inline">\(99.999-999\)</span>.</li>
</ol></li>
<li>Projete expressões para encontrar:
<ol type="a">
<li>Endereços de email em um texto;</li>
<li>Valores monetários no formato <span class="math inline">\(R\$ 99,99\)</span>;</li>
<li>Datas em formatos variados: <span class="math inline">\(dd/mm/aaaa\)</span>, <span class="math inline">\(dd-mm-aaaa\)</span>, <span class="math inline">\(dd.mm.aaaa\)</span>;</li>
<li>Números de cartão de crédito (formato <span class="math inline">\(9999-9999-9999-9999\)</span>).</li>
</ol></li>
<li>Identifique e corrija os erros nas seguintes expressões:
<ol type="a">
<li>Para validar email: <span class="math inline">\([a-z]+@[a-z]+.[a-z]+\)</span> (problema: ponto literal);</li>
<li>Para números decimais: <span class="math inline">\([0-9]*.[0-9]*\)</span> (problema: pontos opcionais);</li>
<li>Para identificadores: <span class="math inline">\([a-zA-Z][a-zA-Z0-9]?\)</span> (problema: comprimento mínimo).</li>
</ol></li>
<li>Para cada expressão, proponha uma versão otimizada:
<ol type="a">
<li><span class="math inline">\((abc|abd|abe)\)</span> → <span class="math inline">\(ab(c|d|e)\)</span>;</li>
<li><span class="math inline">\([0-9][0-9][0-9][0-9]\)</span> → <span class="math inline">\([0-9]\{4\}\)</span>;</li>
<li><span class="math inline">\((a^*b^*|b^*a^*)\)</span> → <span class="math inline">\((a|b)^*\)</span> (verifique se são realmente equivalentes);</li>
<li>Analise qual versão seria mais eficiente em uma implementação real.</li>
</ol></li>
</ol>
</section>
</section>
<section id="o-lugar-das-linguagens-regulares-poder-e-limitações" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="o-lugar-das-linguagens-regulares-poder-e-limitações"><span class="header-section-number">3.5</span> O Lugar das Linguagens Regulares: Poder e Limitações</h2>
<p>Após testemunharmos a versatilidade das expressões regulares em aplicações práticas, uma questão natural emerge: será que elas são capazes de descrever <em>qualquer</em> padrão ou linguagem que possamos imaginar? A resposta, embora surpreendente para alguns, é não. As expressões regulares ocupam um lugar específico e bem definido no universo das linguagens formais.</p>
<p>Para compreender essa especificidade, recorremos à <strong>Hierarquia de Chomsky</strong>, um sistema de classificação proposto pelo linguista <a href="https://en.wikipedia.org/wiki/Noam_Chomsky">Noam Chomsky</a> que organiza as linguagens formais em níveis de complexidade crescente. Neste framework, as expressões regulares definem o primeiro e mais fundamental degrau: a classe das <strong>Linguagens Regulares</strong>.</p>
<p>A aventureira leitora depois de entender as expressões regulares pode explorar as propriedades que definem o poder desta classe de linguagens e, igualmente importante, as fronteiras que revelam suas limitações.</p>
<section id="a-essência-do-poder-simplicidade-e-previsibilidade" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="a-essência-do-poder-simplicidade-e-previsibilidade"><span class="header-section-number">3.5.1</span> A Essência do Poder: Simplicidade e Previsibilidade</h3>
<p>O poder das Linguagens Regulares reside em sua simplicidade e previsibilidade. Esse poder é o resultado de um conjunto de propriedades matemáticas e uma correspondência fundamental com um tipo específico de máquina teórica: o Autômato Finito. Vamos explorar essas propriedades que definem o que torna as Linguagens Regulares tão úteis e amplamente aplicáveis.</p>
<p>A curiosa leitora deve saber que existe uma associação clássica entre as Linguagens Regulares e os Autômatos Finitos. De fato, a propriedade mais importante de uma Linguagem Regular é que ela pode ser reconhecida por um Autômato Finito. Um Autômato Finito, como vimos antes no Capítulo <a href="01-lexico.html" class="quarto-xref"><span>Chapter 2</span></a>, é uma máquina teórica com uma quantidade <em>finita</em> de memória, representada por seus estados. A máquina lê uma <em>string</em> de entrada, um símbolo por vez, e sem poder voltar atrás, decide se a <em>string</em> pertence ou não à linguagem. A incapacidade de armazenar uma quantidade ilimitada de informações é a característica que define, limita e, ao mesmo tempo, determina o poder das Linguagens Regulares. Veremos Autômatos Finitos mais detalhadamente no Capítulo <a href="02-lexico.html" class="quarto-xref"><span>Chapter 4</span></a>.</p>
</section>
<section id="propriedades-fundamentais-das-linguagens-regulares" class="level3" data-number="3.5.2">
<h3 data-number="3.5.2" class="anchored" data-anchor-id="propriedades-fundamentais-das-linguagens-regulares"><span class="header-section-number">3.5.2</span> Propriedades Fundamentais das Linguagens Regulares</h3>
<p>A utilidade prática das linguagens regulares não se limita à sua capacidade de descrever padrões, mas também se baseia em um conjunto de garantias matemáticas. Duas propriedades centrais neste contexto são:</p>
<ol type="1">
<li><p><strong>Fechamento sob Operações</strong>: a classe das Linguagens Regulares é fechada sob todas as operações que vimos: <strong>união</strong>, <strong>concatenação</strong>, <strong>fechamento de Kleene</strong>, e também sob <strong>interseção</strong> e <strong>complemento</strong>. Isso significa que se combinarmos Linguagens Regulares usando essas operações, o resultado será <em>sempre</em> outra Linguagem Regular. Essa propriedade é de grande valor prático, pois garante que podemos construir sistemas de reconhecimento complexos a partir de componentes simples com a certeza de que o todo permanecerá computacionalmente tratável.</p></li>
<li><p><strong>Decidibilidade</strong>: Para as Linguagens Regulares, questões fundamentais são sempre <em>decidíveis</em>, ou seja, existe um algoritmo que pode respondê-las em um tempo finito. Podemos sempre construir um programa para determinar, por exemplo:</p>
<ol type="a">
<li>Se uma <em>string</em> <span class="math inline">\(w\)</span> pertence à linguagem <span class="math inline">\(L(r)\)</span>;</li>
<li>Se a linguagem <span class="math inline">\(L(r)\)</span> é vazia;</li>
<li>Se duas expressões, <span class="math inline">\(r\)</span> e <span class="math inline">\(s\)</span>, são equivalentes (<span class="math inline">\(L(r) = L(s)\)</span>).</li>
</ol></li>
</ol>
<p>A previsibilidade e a eficiência dos algoritmos associados às Linguagens Regulares são características que as destacam em comparação com outras classes de linguagens mais complexas, como as Linguagens Livres de Contexto ou as Linguagens Sensíveis ao Contexto.</p>
</section>
<section id="as-fronteiras-do-mundo-regular-o-limite-da-memória" class="level3" data-number="3.5.3">
<h3 data-number="3.5.3" class="anchored" data-anchor-id="as-fronteiras-do-mundo-regular-o-limite-da-memória"><span class="header-section-number">3.5.3</span> As Fronteiras do Mundo Regular: O Limite da Memória</h3>
<p>A principal limitação das Linguagens Regulares está diretamente ligada à memória finita dos autômatos. Tarefas que exigem <em>contar</em> ou <em>lembrar</em> uma quantidade arbitrária e ilimitada de informações estão além de seu alcance. Para reconhecer linguagens que envolvem contagem ou correspondência simétrica, a máquina precisaria de uma memória que pudesse crescer conforme o tamanho da entrada. Como um autômato finito tem um número fixo de estados, ele não consegue realizar essa tarefa.</p>
<p><strong>Exemplos Clássicos de Linguagens Não-Regulares</strong>:</p>
<ol type="1">
<li><p><strong><span class="math inline">\(L = \{a^n b^n \mid n \geq 0\}\)</span></strong>: Para verificar se uma <em>string</em> pertence a esta linguagem (por exemplo, <code>aaabbb</code>), uma máquina precisaria contar todos os <span class="math inline">\(a\)</span>’s e depois garantir que o número de <span class="math inline">\(b\)</span>’s é exatamente o mesmo. Como <span class="math inline">\(n\)</span> pode ser qualquer número, a contagem exige uma memória potencialmente infinita.</p></li>
<li><p><strong>Palíndromos (<span class="math inline">\(L = \{w \mid w = w^R\}\)</span>)</strong>: Para reconhecer um palíndromo como <code>abccba</code>, a máquina teria que memorizar a primeira metade da <em>string</em> (<code>abc</code>) para compará-la com a segunda metade (<code>cba</code>). Novamente, o comprimento da <em>string</em> é ilimitado, exigindo memória ilimitada.</p></li>
<li><p><strong>Parênteses Balanceados</strong>: A linguagem das expressões com parênteses corretamente aninhados, como <code>((()))</code>, exige uma estrutura de <em>pilha</em> para lembrar quantos parênteses foram abertos e ainda não foram fechados. Esta é uma forma de memória mais poderosa do que a disponível para um autômato finito.</p></li>
</ol>
</section>
<section id="o-lema-do-bombeamento-uma-ferramenta-de-prova" class="level3" data-number="3.5.4">
<h3 data-number="3.5.4" class="anchored" data-anchor-id="o-lema-do-bombeamento-uma-ferramenta-de-prova"><span class="header-section-number">3.5.4</span> O Lema do Bombeamento: Uma Ferramenta de Prova</h3>
<p>Para provar formalmente que uma linguagem <em>não</em> é regular, utilizamos uma ferramenta poderosa chamada <strong>Lema do Bombeamento</strong> (<em>Pumping Lemma</em>). Em vez de ser uma fórmula, é melhor compreendido como uma propriedade que toda Linguagem Regular deve satisfazer. Se conseguirmos mostrar que uma linguagem viola essa propriedade, então provamos que ela não pode ser regular.</p>
<p>A sua intuição é a seguinte:</p>
<p>Se uma linguagem <span class="math inline">\(L\)</span> é regular, então ela é aceita por um autômato finito com um número fixo de estados, digamos, <span class="math inline">\(p\)</span>. Agora, considere uma <em>string</em> <span class="math inline">\(w\)</span> em <span class="math inline">\(L\)</span> que seja suficientemente longa (especificamente, com comprimento <span class="math inline">\(|w| \geq p\)</span>). Como a <em>string</em> tem mais símbolos do que o autômato tem estados, o Princípio da Casa dos Pombos nos garante que o autômato <strong>necessariamente revisitará</strong> pelo menos um de seus estados enquanto lê a <em>string</em>. Isso significa que o caminho do autômato ao ler <span class="math inline">\(w\)</span> contém um <strong>ciclo</strong>. Podemos, então, dividir a <em>string</em> <span class="math inline">\(w\)</span> em três partes, <span class="math inline">\(w = xyz\)</span>:</p>
<ul>
<li><code>$x$</code>: a parte da <em>string</em> lida antes do ciclo começar;</li>
<li><code>$y$</code>: a parte da <em>string</em> lida durante o ciclo. É uma condição fundamental do lema que esta parte <strong>não pode ser vazia</strong> (<span class="math inline">\(|y| &gt; 0\)</span>);</li>
<li><code>$z$</code>: o restante da <em>string</em>, lida após o ciclo.</li>
</ul>
<p>O lema afirma que, como <span class="math inline">\(y\)</span> corresponde a um ciclo, essa porção pode ser <em>bombeada</em>: podemos percorrê-la zero vezes (removendo <span class="math inline">\(y\)</span>), uma vez (a <em>string</em> original), ou múltiplas vezes. Todas as <em>strings</em> resultantes, da forma <span class="math inline">\(xy^iz\)</span> para qualquer <span class="math inline">\(i \geq 0\)</span>, ainda devem ser aceitas pela máquina e, portanto, devem pertencer à linguagem <span class="math inline">\(L\)</span>.</p>
<p>Para provar que uma linguagem não é regular, usamos esta propriedade para criar uma contradição: encontramos pelo menos uma <em>string</em> longa na linguagem onde o <em>bombeamento</em> de sua parte cíclica a <em>quebra</em>, gerando uma <em>string</em> que <strong>não</strong> pertence à linguagem. Se isso for possível, a linguagem viola o lema e, portanto, não é regular.</p>
</section>
<section id="exemplo-do-lema-do-bombeamento" class="level3" data-number="3.5.5">
<h3 data-number="3.5.5" class="anchored" data-anchor-id="exemplo-do-lema-do-bombeamento"><span class="header-section-number">3.5.5</span> Exemplo do Lema do Bombeamento</h3>
<p>Vamos usar o Lema do Bombeamento para provar formalmente que a linguagem <span class="math inline">\(L = \{a^n b^n \mid n \geq 0\}\)</span>, uma sequência de <span class="math inline">\(a\)</span>’s seguida pelo mesmo número de <span class="math inline">\(b\)</span>’s, não é regular. A prova segue um roteiro de contradição cujo passo a passo a atenta leitora pode ver a seguir:</p>
<ol type="1">
<li><strong>Assunção Inicial (para Contradição)</strong>: assumimos que <span class="math inline">\(L\)</span> <strong>é</strong> uma linguagem regular.</li>
<li><strong>Aplicação do Lema</strong>: se <span class="math inline">\(L\)</span> é regular, então o Lema do Bombeamento deve se aplicar. Isso significa que existe uma constante, o <em>comprimento de bombeamento</em> <span class="math inline">\(p\)</span>, para a linguagem <span class="math inline">\(L\)</span>.</li>
<li><strong>Escolha da String</strong>: escolhemos uma <em>string</em> <span class="math inline">\(w\)</span> que pertence a <span class="math inline">\(L\)</span> e que seja longa o suficiente, ou seja, <span class="math inline">\(|w| \geq p\)</span>. A escolha mais estratégica é <span class="math inline">\(w = a^p b^p\)</span>. Esta <em>string</em> claramente pertence a <span class="math inline">\(L\)</span> (pois o número de <span class="math inline">\(a\)</span>’s é igual ao de <span class="math inline">\(b\)</span>’s) e seu comprimento é <span class="math inline">\(2p\)</span>, que é maior ou igual a <span class="math inline">\(p\)</span>.</li>
<li><strong>Divisão da String</strong>: de acordo com o lema, <span class="math inline">\(w\)</span> pode ser dividida em três partes, <span class="math inline">\(w=xyz\)</span>, que devem satisfazer as seguintes condições:
<ol type="a">
<li><span class="math inline">\(|y| &gt; 0\)</span>;</li>
<li><span class="math inline">\(|xy| \leq p\)</span>;</li>
<li><span class="math inline">\(xy^iz \in L\)</span> para todo <span class="math inline">\(i \geq 0\)</span>.</li>
</ol></li>
<li><strong>Análise da Parte Bombeável (<span class="math inline">\(y\)</span>)</strong>: a condição <span class="math inline">\(|xy| \leq p\)</span> é a chave. Como nossa <em>string</em> é <span class="math inline">\(w = \underbrace{a a \ldots a}_{p \text{ vezes}} \underbrace{b b \ldots b}_{p \text{ vezes}}\)</span>, a parte <span class="math inline">\(xy\)</span> (com no máximo <span class="math inline">\(p\)</span> caracteres) deve estar inteiramente contida no bloco inicial de <span class="math inline">\(a\)</span>’s. Além disso, como <span class="math inline">\(|y| &gt; 0\)</span>, a <em>string</em> <span class="math inline">\(y\)</span> deve conter pelo menos um <span class="math inline">\(a\)</span>. Portanto, <span class="math inline">\(y\)</span> é da forma <span class="math inline">\(y=a^k\)</span> para algum <span class="math inline">\(k\)</span> onde <span class="math inline">\(1 \leq k \leq p\)</span>.</li>
<li><strong>O Bombeamento (A Contradição)</strong>: o lema afirma que qualquer <em>string</em> bombeada <span class="math inline">\(xy^iz\)</span> também deve pertencer a <span class="math inline">\(L\)</span>. Vamos testar para <span class="math inline">\(i=2\)</span>:
<ol type="a">
<li>A nova <em>string</em> é <span class="math inline">\(w' = xy^2z\)</span>.</li>
<li>Como <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> e <span class="math inline">\(z\)</span> juntos formavam <span class="math inline">\(a^p b^p\)</span>, e <span class="math inline">\(y\)</span> era <span class="math inline">\(a^k\)</span>, a nova <em>string</em> <span class="math inline">\(w'\)</span> terá <span class="math inline">\(k\)</span> <span class="math inline">\(a\)</span>’s a mais que a original.</li>
<li>Portanto, <span class="math inline">\(w' = a^{p+k} b^p\)</span>.</li>
<li>Como sabemos que <span class="math inline">\(k \geq 1\)</span>, o número de <span class="math inline">\(a\)</span>’s (<span class="math inline">\(p+k\)</span>) não é mais igual ao número de <span class="math inline">\(b\)</span>’s (<span class="math inline">\(p\)</span>). Logo, a <em>string</em> <span class="math inline">\(w' = a^{p+k} b^p\)</span> <strong>não pertence</strong> a <span class="math inline">\(L\)</span>.</li>
</ol></li>
<li><strong>Conclusão</strong>: chegamos a uma contradição. Nossa suposição inicial de que <span class="math inline">\(L\)</span> era regular nos levou, através do Lema do Bombeamento, à conclusão de que uma <em>string</em> gerada pelo bombeamento (<span class="math inline">\(w'\)</span>) deveria estar em <span class="math inline">\(L\)</span>, mas mostramos que ela viola a definição de <span class="math inline">\(L\)</span>. Portanto, a suposição inicial estava errada. A linguagem <span class="math inline">\(L = \{a^n b^n \mid n \geq 0\}\)</span> não é regular.</li>
</ol>
<section id="por-que-o-lema-do-bombeamento-é-importante" class="level4" data-number="3.5.5.1">
<h4 data-number="3.5.5.1" class="anchored" data-anchor-id="por-que-o-lema-do-bombeamento-é-importante"><span class="header-section-number">3.5.5.1</span> Por que o Lema do Bombeamento é Importante?</h4>
<p>O Lema do Bombeamento é uma ferramenta diagnóstica fundamental na teoria da computação. Sua importância não está em descrever o que as linguagens regulares <em>são</em>, mas sim em fornecer um método rigoroso para provar o que elas <em>não são</em>. [cite_start]Ele formaliza a noção de que autômatos finitos possuem <em>memória finita</em>. A existência de um ciclo bombeável é a consequência direta dessa memória finita; qualquer tarefa que exija contagem ou memória ilimitada, como garantir que o número de <span class="math inline">\(a\)</span>’s é igual ao de <span class="math inline">\(b\)</span>’s, irá <em>quebrar</em> sob o bombeamento. Na prática, isso permite aos cientistas da computação e engenheiros de software classificar problemas, entendendo quando uma ferramenta simples (como uma expressão regular) é insuficiente e quando uma abordagem mais poderosa (como um analisador sintático para gramáticas livres de contexto) é necessária.</p>
</section>
</section>
</section>
<section id="exercícios-desafiadores" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="exercícios-desafiadores"><span class="header-section-number">3.6</span> Exercícios Desafiadores</h2>
<section id="exercício-1" class="level3" data-number="3.6.1">
<h3 data-number="3.6.1" class="anchored" data-anchor-id="exercício-1"><span class="header-section-number">3.6.1</span> Exercício 1:</h3>
<p>Seja <span class="math inline">\(\Sigma = \{a, b, c\}\)</span> e considere a linguagem <span class="math inline">\(L = \{w \in \Sigma^* \mid |w|_a + 2|w|_b = |w|_c\}\)</span>, onde <span class="math inline">\(|w|_x\)</span> denota o número de ocorrências do símbolo <span class="math inline">\(x\)</span> na <em>string</em> <span class="math inline">\(w\)</span>.</p>
<ol type="a">
<li>Determine se <span class="math inline">\(L\)</span> é uma linguagem regular. Justifique sua resposta.</li>
<li>Se <span class="math inline">\(L\)</span> não for regular, use o Lema do Bombeamento para prová-lo formalmente.</li>
<li>Construa uma expressão regular para a linguagem <span class="math inline">\(L' = \{w \in \{a,b\}^* \mid |w|_a \leq 3\}\)</span>.</li>
</ol>
<p><strong>Solução</strong>:</p>
<ol type="1">
<li><p>A linguagem <span class="math inline">\(L\)</span> <strong>não é regular</strong>. A condição <span class="math inline">\(|w|_a + 2|w|_b = |w|_c\)</span> estabelece uma relação aritmética que requer contagem precisa dos símbolos, algo que excede a capacidade de memória finita dos autômatos finitos.</p></li>
<li><p><strong>Prova usando o Lema do Bombeamento</strong>:</p></li>
</ol>
<p>Assumimos por contradição que <span class="math inline">\(L\)</span> é regular. Então existe uma constante <span class="math inline">\(p\)</span> tal que qualquer <em>string</em> <span class="math inline">\(w \in L\)</span> com <span class="math inline">\(|w| \geq p\)</span> pode ser dividida como <span class="math inline">\(w = xyz\)</span> satisfazendo: a. <span class="math inline">\(|y| &gt; 0\)</span>; b. <span class="math inline">\(|xy| \leq p\)</span>; c.&nbsp;<span class="math inline">\(xy^iz \in L\)</span> para todo <span class="math inline">\(i \geq 0\)</span>.</p>
<p>Escolhemos <span class="math inline">\(w = a^p c^p \in L\)</span> (pois <span class="math inline">\(p + 2 \cdot 0 = p\)</span>). Como <span class="math inline">\(|xy| \leq p\)</span> e <span class="math inline">\(w\)</span> começa com <span class="math inline">\(p\)</span> símbolos <span class="math inline">\(a\)</span>, temos que <span class="math inline">\(y = a^k\)</span> para algum <span class="math inline">\(1 \leq k \leq p\)</span>.</p>
<p>Para <span class="math inline">\(i = 2\)</span>: <span class="math inline">\(w' = xy^2z = a^{p+k}c^p\)</span></p>
<p>Na <em>string</em> <span class="math inline">\(w'\)</span>: <span class="math inline">\(|w'|_a = p + k\)</span>, <span class="math inline">\(|w'|_b = 0\)</span>, <span class="math inline">\(|w'|_c = p\)</span></p>
<p>A condição requer: <span class="math inline">\((p + k) + 2 \cdot 0 = p\)</span>, ou seja, <span class="math inline">\(p + k = p\)</span>, logo <span class="math inline">\(k = 0\)</span>.</p>
<p>Mas isso contradiz <span class="math inline">\(|y| &gt; 0\)</span>, que implica <span class="math inline">\(k \geq 1\)</span>.</p>
<p>Portanto, <span class="math inline">\(L\)</span> não é regular.</p>
<ol start="3" type="1">
<li>Para <span class="math inline">\(L' = \{w \in \{a,b\}^* \mid |w|_a \leq 3\}\)</span>:</li>
</ol>
<p><span class="math display">\[L' = b^* \cup b^*ab^* \cup b^*ab^*ab^* \cup b^*ab^*ab^*ab^*\]</span></p>
<p>Forma mais concisa: <span class="math inline">\(L' = b^*(\epsilon \cup ab^* \cup ab^*ab^* \cup ab^*ab^*ab^*)\)</span></p>
</section>
</section>
<section id="exercício-2" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="exercício-2"><span class="header-section-number">3.7</span> Exercício 2:</h2>
<p>Considere as expressões regulares sobre <span class="math inline">\(\Sigma = \{0, 1\}\)</span>:</p>
<ul>
<li><span class="math inline">\(r_1 = (01)^*0(10)^*\)</span></li>
<li><span class="math inline">\(r_2 = 0(10)^* \cup (01)^*0\)</span></li>
</ul>
<ol type="a">
<li>Determine se <span class="math inline">\(r_1 \equiv r_2\)</span> construindo <em>strings</em> específicas que testem a equivalência.</li>
<li>Construa uma expressão regular equivalente mais simples.</li>
<li>Determine <span class="math inline">\(|L(r_1) \cap \{w \in \{0,1\}^* \mid |w| = 5\}|\)</span>.</li>
</ol>
<p><strong>Solução Letra a</strong>:</p>
<ol type="1">
<li><p><strong>Teste de equivalência por exemplos</strong>:</p>
<p><span class="math inline">\(L(r_1) = L((01)^*0(10)^*)\)</span> gera <em>strings</em> que:</p>
<ol type="a">
<li>Começam com zero ou mais pares <span class="math inline">\(01\)</span>;</li>
<li>Têm um <span class="math inline">\(0\)</span> central obrigatório;</li>
<li>Terminam com zero ou mais pares <span class="math inline">\(10\)</span>.</li>
</ol>
<p><span class="math inline">\(L(r_2) = L(0(10)^* \cup (01)^*0)\)</span> gera <em>strings</em> que:</p>
<ol type="a">
<li>Ou começam com <span class="math inline">\(0\)</span> seguido de pares <span class="math inline">\(10\)</span>;</li>
<li>Ou começam com pares <span class="math inline">\(01\)</span> e terminam com <span class="math inline">\(0\)</span>.</li>
</ol></li>
<li><p><strong>Teste com <em>strings</em> específicas</strong>:</p>
<ol type="a">
<li><em>string</em> <span class="math inline">\(010\)</span>: Em <span class="math inline">\(r_1\)</span>: <span class="math inline">\((01)^1 \cdot 0 \cdot (10)^0 = 010\)</span>. Ok!</li>
<li><em>string</em> <span class="math inline">\(010\)</span>: Em <span class="math inline">\(r_2\)</span>: <span class="math inline">\((01)^1 \cdot 0 = 010\)</span>. Ok!</li>
<li><em>string</em> <span class="math inline">\(0\)</span>: Em ambas. Ok!</li>
<li><em>string</em> <span class="math inline">\(01010\)</span>: Em <span class="math inline">\(r_1\)</span>: <span class="math inline">\((01)^1 \cdot 0 \cdot (10)^1 = 01010\)</span>. Ok!</li>
<li><em>string</em> <span class="math inline">\(01010\)</span>: Em <span class="math inline">\(r_2\)</span>: <span class="math inline">\((01)^2 \cdot 0 = 01010\)</span>. Ok!</li>
</ol></li>
<li><p><strong>Por análise estrutural</strong>, <span class="math inline">\(r_1 \equiv r_2\)</span>.</p></li>
</ol>
<p><strong>Solução Letra b</strong>:</p>
<p>A expressão <span class="math inline">\(r_2 = 0(10)^* \cup (01)^*0\)</span> é, de fato, a forma simplificada de <span class="math inline">\(r_1\)</span>. A afirmação pode ser mais detalhada da seguinte forma:</p>
<ol type="1">
<li><strong>Simplificação Estrutural</strong>:
<ol type="a">
<li>A expressão original, <span class="math inline">\(r_1 = (01)^*0(10)^*\)</span>, descreve a linguagem através de uma concatenação de três partes. Isso exige que qualquer <em>string</em> da linguagem seja mentalmente dividida em um prefixo de <span class="math inline">\((01)^*\)</span>, um <span class="math inline">\(0\)</span> central e um sufixo de <span class="math inline">\((10)^*\)</span>.</li>
<li>A expressão <span class="math inline">\(r_2\)</span>, já comprovada como equivalente na letra (a), descreve a mesma linguagem como a união de dois padrões mais diretos. Essa forma é frequentemente considerada mais simples, pois representa a linguagem como <em>strings que pertencem ao padrão A <strong>OU</strong> ao padrão B</em>, o que pode ser mais fácil de analisar e implementar.</li>
</ol></li>
<li><strong>Análise de Minimalidade</strong>:
<ol type="a">
<li>A expressão <span class="math inline">\(r_2\)</span> é considerada minimal na prática. A linguagem consiste em <em>strings</em> que começam e terminam com <span class="math inline">\(0\)</span> e têm <span class="math inline">\(0\)</span>s e <span class="math inline">\(1\)</span>s alternados no interior. Existem duas maneiras naturais de gerar tais strings:
<ul>
<li>Começando com um <span class="math inline">\(0\)</span> e adicionando pares de <span class="math inline">\(10\)</span> à direita (padrão <span class="math inline">\(0(10)^*\)</span>).</li>
<li>Terminando com um <span class="math inline">\(0\)</span> e adicionando pares de <span class="math inline">\(01\)</span> à esquerda (padrão <span class="math inline">\((01)^*0\)</span>).</li>
</ul></li>
<li>A união em <span class="math inline">\(r_2\)</span> captura perfeitamente essas duas perspectivas geradoras. Tentar unir os dois padrões em uma única expressão sem o operador de união (<span class="math inline">\(\cup\)</span>) muito provavelmente resultaria em uma expressão mais longa, complexa e menos intuitiva.</li>
</ol></li>
<li><strong>Conclusão</strong>:pPortanto, embora a prova formal de minimalidade de uma expressão regular seja um problema complexo (geralmente envolvendo autômatos finitos), a expressão <span class="math inline">\(r_2 = 0(10)^* \cup (01)^*0\)</span> é a representação equivalente mais simples e canônica de <span class="math inline">\(r_1\)</span>.</li>
</ol>
<p><strong>Solução Letra c</strong>:</p>
<p>Contagem para <span class="math inline">\(|w| = 5\)</span>:</p>
<p>Strings de <span class="math inline">\(L(r_1)\)</span> têm comprimento ímpar (todas começam e terminam com <span class="math inline">\(0\)</span>, com pares no meio).</p>
<p>Para comprimento 5: a. Caso <span class="math inline">\(0(10)^*\)</span>: <span class="math inline">\(0\)</span> seguido de <span class="math inline">\((10)^k\)</span> onde <span class="math inline">\(1 + 2k = 5\)</span>, logo <span class="math inline">\(k = 2\)</span>: <span class="math inline">\(01010\)</span>. Ok! b. Caso <span class="math inline">\((01)^*0\)</span>: <span class="math inline">\((01)^k\)</span> seguido de <span class="math inline">\(0\)</span> onde <span class="math inline">\(2k + 1 = 5\)</span>, logo <span class="math inline">\(k = 2\)</span>: <span class="math inline">\(01010\)</span>. Ok!</p>
<p>Portanto: <span class="math inline">\(|L(r_1) \cap \{w \in \{0,1\}^* \mid |w| = 5\}| = 1\)</span></p>
</section>
<section id="exercício-3" class="level2" data-number="3.8">
<h2 data-number="3.8" class="anchored" data-anchor-id="exercício-3"><span class="header-section-number">3.8</span> Exercício 3:</h2>
<p>Seja <span class="math inline">\(\Sigma\)</span> o alfabeto contendo dígitos de 0 a 9 e os símbolos ‘(’, ‘)’, ‘-’, e o espaço ’ ’. Defina as seguintes expressões para conjuntos de dígitos: 1. <span class="math inline">\(D = (0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)\)</span>; 2. <span class="math inline">\(D_{nz} = (1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)\)</span>; 3. <span class="math inline">\(D_{fixo} = (2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8)\)</span>.</p>
<p>Com base nessas definições, considere a linguagem <span class="math inline">\(L_{tel}\)</span> de números de telefone brasileiros.</p>
<ol type="a">
<li>Construa expressões regulares separadas para os componentes da linguagem: o DDD e o Número do telefone.</li>
<li>Combine as expressões da letra (a) para construir a expressão regular final para a linguagem <span class="math inline">\(L_{tel}\)</span> completa.</li>
<li>Demonstre que a <em>string</em> <span class="math inline">\((11) 99999-9999\)</span> pertence a <span class="math inline">\(L_{tel}\)</span> mostrando sua derivação a partir da expressão final.</li>
</ol>
<p><strong>Solução Letra a</strong>:</p>
<ol type="1">
<li><p><strong>Componente DDD (<span class="math inline">\(r_{ddd}\)</span>)</strong>:</p>
<ol type="a">
<li>O DDD consiste em dois dígitos, o primeiro não podendo ser zero. A base é <span class="math inline">\(D_{nz}D\)</span>;</li>
<li>Ele pode ter dois formatos: com parênteses ou sem, ambos seguidos por um espaço opcional;</li>
<li>Expressão para o formato com parênteses: <span class="math inline">\(\( D_{nz} D \) (\epsilon \cup \text{ })\)</span>;</li>
<li>Expressão para o formato sem parênteses: <span class="math inline">\(D_{nz} D (\epsilon \cup \text{ })\)</span>;</li>
<li>A expressão completa para o DDD é a união dos dois formatos:</li>
</ol>
<p><span class="math display">\[r_{ddd} = (\( D_{nz} D \) (\epsilon \cup \text{ })) \cup (D_{nz} D (\epsilon \cup \text{ }))\]</span></p></li>
<li><p><strong>Componente Número (<span class="math inline">\(r_{num}\)</span>)</strong>:</p>
<ol type="a">
<li>O número pode ser de celular (9 dígitos começando com 9) ou fixo (8 dígitos começando com 2-8). Ambos podem ter um hífen opcional;</li>
<li>Expressão para celular: <span class="math inline">\(9 D^4 (\epsilon \cup -) D^4\)</span>;</li>
<li>Expressão para fixo: <span class="math inline">\(D_{fixo} D^3 (\epsilon \cup -) D^4\)</span>;</li>
<li>A expressão completa para o número é a união dos dois tipos.</li>
</ol>
<p><span class="math display">\[r_{num} = (9 D^4 (\epsilon \cup -) D^4) \cup (D_{fixo} D^3 (\epsilon \cup -) D^4)\]</span></p></li>
</ol>
<p><strong>Solução Letra b</strong>:</p>
<p>A expressão regular final <span class="math inline">\(r_{tel}\)</span> é a concatenação do componente DDD com o componente Número.</p>
<ol type="1">
<li><p><strong>Expressão Final</strong>: <span class="math display">\[r_{tel} = r_{ddd} \cdot r_{num}\]</span></p></li>
<li><p><strong>Substituindo as definições da letra (a)</strong>:</p>
<p><span class="math display">\[r_{tel} = [(\( D_{nz} D \) (\epsilon \cup \text{ })) \cup (D_{nz} D (\epsilon \cup \text{ }))] \cdot [(9 D^4 (\epsilon \cup -) D^4) \cup (D_{fixo} D^3 (\epsilon \cup -) D^4)]\]</span></p></li>
</ol>
<p><strong>Solução Letra c</strong>:</p>
<p>Vamos demonstrar que a <em>string</em> <span class="math inline">\(w = (11) 99999-9999\)</span> pertence a <span class="math inline">\(L(r_{tel})\)</span>.</p>
<ol type="1">
<li><strong>Divisão da String</strong>: Podemos dividir <span class="math inline">\(w\)</span> em duas partes, <span class="math inline">\(w_{ddd}\)</span> e <span class="math inline">\(w_{num}\)</span>, onde:
<ul>
<li><span class="math inline">\(w_{ddd} = (11)\text{ }\)</span> (inclui o espaço);</li>
<li><span class="math inline">\(w_{num} = 99999-9999\)</span>;</li>
</ul></li>
<li><strong>Verificação do Componente DDD</strong>: A substring <span class="math inline">\(w_{ddd}\)</span> deve pertencer a <span class="math inline">\(L(r_{ddd})\)</span>. Ela corresponde ao primeiro termo da união em <span class="math inline">\(r_{ddd}\)</span>:
<ul>
<li><span class="math inline">\(\( D_{nz} D \) (\epsilon \cup \text{ })\)</span>;</li>
<li><span class="math inline">\(\(\)</span> corresponde ao símbolo literal <span class="math inline">\((\)</span>;</li>
<li><span class="math inline">\(1\)</span> pertence a <span class="math inline">\(L(D_{nz})\)</span> pois <span class="math inline">\(1 \in \{1,2,3,4,5,6,7,8,9\}\)</span>;</li>
<li><span class="math inline">\(1\)</span> pertence a <span class="math inline">\(L(D)\)</span> pois <span class="math inline">\(1 \in \{0,1,2,3,4,5,6,7,8,9\}\)</span>;</li>
<li><span class="math inline">\(\)\)</span> corresponde ao símbolo literal <span class="math inline">\()\)</span>;</li>
<li>O espaço pertence a <span class="math inline">\(L(\epsilon \cup \text{ })\)</span>;</li>
<li>Portanto, <span class="math inline">\(w_{ddd} \in L(r_{ddd})\)</span>. Ok!</li>
</ul></li>
<li><strong>Verificação do Componente Número</strong>: A substring <span class="math inline">\(w_{num}\)</span> deve pertencer a <span class="math inline">\(L(r_{num})\)</span>. Ela corresponde ao primeiro termo da união (celular) em <span class="math inline">\(r_{num}\)</span>:
<ul>
<li><span class="math inline">\(9 D^4 (\epsilon \cup -) D^4\)</span>;</li>
<li>O primeiro <span class="math inline">\(9\)</span> corresponde ao símbolo literal <span class="math inline">\(9\)</span>;</li>
<li><span class="math inline">\(9999\)</span> pertence a <span class="math inline">\(L(D^4) = L(D \cdot D \cdot D \cdot D)\)</span>;</li>
<li><span class="math inline">\(-\)</span> pertence a <span class="math inline">\(L(\epsilon \cup -)\)</span>;</li>
<li><span class="math inline">\(9999\)</span> pertence a <span class="math inline">\(L(D^4)\)</span>;</li>
<li>Portanto, <span class="math inline">\(w_{num} \in L(r_{num})\)</span>. Ok!</li>
</ul></li>
<li><strong>Conclusão</strong>: como <span class="math inline">\(w = w_{ddd} \cdot w_{num}\)</span> e ambas as partes são geradas pelas respectivas subexpressões de <span class="math inline">\(r_{tel}\)</span>, pela definição de concatenação de linguagens, temos que <span class="math inline">\(w \in L(r_{tel})\)</span>.</li>
</ol>
<section id="exercício-4" class="level3" data-number="3.8.1">
<h3 data-number="3.8.1" class="anchored" data-anchor-id="exercício-4"><span class="header-section-number">3.8.1</span> Exercício 4:</h3>
<p>Seja <span class="math inline">\(\Sigma = \{a, b\}\)</span> e considere as seguintes linguagens: - <span class="math inline">\(L_1 = \{a^nb^m \mid n \geq m \geq 0\}\)</span> - <span class="math inline">\(L_2 = \{a^mb^n \mid n \geq m \geq 0\}\)</span></p>
<ol type="a">
<li>Analise se <span class="math inline">\(L_1\)</span> e <span class="math inline">\(L_2\)</span> são linguagens regulares usando o Lema do Bombeamento.</li>
<li>Determine as linguagens resultantes das operações <span class="math inline">\(L_1 \cap L_2\)</span>, <span class="math inline">\(L_1 \cup L_2\)</span>, e <span class="math inline">\(L_1 \cdot L_2\)</span>, e classifique cada uma quanto à regularidade.</li>
<li>Construa uma expressão regular para <span class="math inline">\(L_3 = \{a^nb^n \mid n \geq 0\} \cup \{a^mb^m \mid m \geq 0\}\)</span> ou prove que não existe.</li>
</ol>
<p><strong>Solução Letra a</strong>:</p>
<ol type="1">
<li><p><strong>Análise de <span class="math inline">\(L_1 = \{a^nb^m \mid n \geq m \geq 0\}\)</span></strong></p>
<p><strong>Caracterização da linguagem</strong>: <span class="math inline">\(L_1\)</span> contém <em>strings</em> onde o número de <span class="math inline">\(a\)</span>’s é maior ou igual ao número de <span class="math inline">\(b\)</span>’s. Exemplos: <span class="math inline">\(\{\epsilon, a, aa, ab, aaa, aab, aaab, \ldots\}\)</span>.</p>
<p><strong>Aplicação do Lema do Bombeamento</strong>:</p>
<p><strong>Passo 1 - Hipótese</strong>: Assumimos por contradição que <span class="math inline">\(L_1\)</span> é regular.</p>
<p><strong>Passo 2 - Constante de bombeamento</strong>: Se <span class="math inline">\(L_1\)</span> é regular, então existe uma constante <span class="math inline">\(p &gt; 0\)</span> tal que qualquer <em>string</em> <span class="math inline">\(w \in L_1\)</span> com <span class="math inline">\(|w| \geq p\)</span> pode ser dividida como <span class="math inline">\(w = xyz\)</span> satisfazendo:</p>
<ul>
<li><span class="math inline">\(|y| &gt; 0\)</span>;</li>
<li><span class="math inline">\(|xy| \leq p\)</span>;</li>
<li><span class="math inline">\(xy^iz \in L_1\)</span> para todo <span class="math inline">\(i \geq 0\)</span>.</li>
</ul>
<p><strong>Passo 3 - Escolha da string</strong>: Escolhemos <span class="math inline">\(w = a^pb^p \in L_1\)</span> (válida pois <span class="math inline">\(p \geq p \geq 0\)</span>).</p>
<p><strong>Passo 4 - Análise da divisão</strong>: Como <span class="math inline">\(|xy| \leq p\)</span> e <span class="math inline">\(w\)</span> inicia com <span class="math inline">\(p\)</span> símbolos <span class="math inline">\(a\)</span> seguidos de <span class="math inline">\(p\)</span> símbolos <span class="math inline">\(b\)</span>, a substring <span class="math inline">\(xy\)</span> está inteiramente contida no bloco inicial de <span class="math inline">\(a\)</span>’s. Portanto, <span class="math inline">\(y = a^k\)</span> para algum <span class="math inline">\(k\)</span> com <span class="math inline">\(1 \leq k \leq p\)</span>.</p>
<p><strong>Passo 5 - Teste do bombeamento</strong>: Consideramos <span class="math inline">\(i = 2\)</span>: <span class="math display">\[xy^2z = a^{p+k}b^p\]</span></p>
<p><strong>Passo 6 - Verificação da condição</strong>: Para que <span class="math inline">\(xy^2z \in L_1\)</span>, devemos ter: <span class="math display">\[\text{número de } a\text{'s} \geq \text{número de } b\text{'s}\]</span> <span class="math display">\[p + k \geq p\]</span> <span class="math display">\[k \geq 0\]</span></p>
<p>Como <span class="math inline">\(k \geq 1\)</span> (pois <span class="math inline">\(|y| &gt; 0\)</span>), a condição <span class="math inline">\(k \geq 0\)</span> é sempre satisfeita.</p>
<p><strong>Passo 7 - Teste com <span class="math inline">\(i = 0\)</span></strong>: Consideramos <span class="math inline">\(i = 0\)</span>: <span class="math display">\[xy^0z = xz = a^{p-k}b^p\]</span></p>
<p>Para que <span class="math inline">\(xz \in L_1\)</span>, devemos ter: <span class="math display">\[p - k \geq p\]</span> <span class="math display">\[-k \geq 0\]</span> <span class="math display">\[k \leq 0\]</span></p>
<p><strong>Passo 8 - Contradição</strong>: Temos <span class="math inline">\(k \geq 1\)</span> (de <span class="math inline">\(|y| &gt; 0\)</span>) e <span class="math inline">\(k \leq 0\)</span> (da condição de bombeamento), o que é uma contradição.</p>
<p><strong>Conclusão</strong>: <span class="math inline">\(L_1\)</span> não é regular.</p></li>
<li><p><strong>Análise de <span class="math inline">\(L_2 = \{a^mb^n \mid n \geq m \geq 0\}\)</span></strong></p>
<p><strong>Caracterização da linguagem</strong>: <span class="math inline">\(L_2\)</span> contém <em>strings</em> onde o número de <span class="math inline">\(b\)</span>’s é maior ou igual ao número de <span class="math inline">\(a\)</span>’s. Exemplos: <span class="math inline">\(\{\epsilon, b, a, bb, ab, bbb, abb, abbb, \ldots\}\)</span>.</p>
<p><strong>Aplicação do Lema do Bombeamento</strong>:</p>
<p><strong>Passos 1-4</strong>: Idênticos à análise de <span class="math inline">\(L_1\)</span>, escolhendo <span class="math inline">\(w = a^pb^p \in L_2\)</span>.</p>
<p><strong>Passo 5 - Teste do bombeamento com <span class="math inline">\(i = 2\)</span></strong>: <span class="math display">\[xy^2z = a^{p+k}b^p\]</span></p>
<p><strong>Passo 6 - Verificação da condição</strong>: Para que <span class="math inline">\(xy^2z \in L_2\)</span>, devemos ter: <span class="math display">\[\text{número de } b\text{'s} \geq \text{número de } a\text{'s}\]</span> <span class="math display">\[p \geq p + k\]</span> <span class="math display">\[0 \geq k\]</span> <span class="math display">\[k \leq 0\]</span></p>
<p><strong>Passo 7 - Contradição</strong>: Temos <span class="math inline">\(k \geq 1\)</span> (de <span class="math inline">\(|y| &gt; 0\)</span>) e <span class="math inline">\(k \leq 0\)</span> (da condição), o que é uma contradição.</p>
<p><strong>Conclusão</strong>: <span class="math inline">\(L_2\)</span> não é regular.</p></li>
</ol>
<p><strong>Solução Letra b</strong>:</p>
<ol type="1">
<li><p><strong>Análise de <span class="math inline">\(L_1 \cap L_2\)</span></strong></p>
<p><strong>Determinação da interseção</strong>: <span class="math display">\[L_1 \cap L_2 = \{a^nb^m \mid n \geq m \geq 0\} \cap \{a^mb^n \mid n \geq m \geq 0\}\]</span></p>
<p>Para uma <em>string</em> <span class="math inline">\(a^rb^s\)</span> pertencer à interseção, deve satisfazer simultaneamente:</p>
<ul>
<li><span class="math inline">\(r \geq s\)</span> (condição de <span class="math inline">\(L_1\)</span>)</li>
<li><span class="math inline">\(s \geq r\)</span> (condição de <span class="math inline">\(L_2\)</span>)</li>
</ul>
<p>Isso implica <span class="math inline">\(r = s\)</span>, portanto: <span class="math display">\[L_1 \cap L_2 = \{a^nb^n \mid n \geq 0\}\]</span></p>
<p><strong>Análise de regularidade</strong>: Esta é a linguagem clássica de balanceamento, que não é regular. Pode ser provada usando o Lema do Bombeamento com a <em>string</em> <span class="math inline">\(a^pb^p\)</span>.</p></li>
<li><p><strong>Análise de <span class="math inline">\(L_1 \cup L_2\)</span></strong></p>
<p><strong>Determinação da união</strong>: <span class="math display">\[L_1 \cup L_2 = \{a^nb^m \mid n \geq m \geq 0\} \cup \{a^mb^n \mid n \geq m \geq 0\}\]</span></p>
<p><strong>Análise de regularidade</strong>: Como <span class="math inline">\(L_1 \subseteq L_1 \cup L_2\)</span> e <span class="math inline">\(L_1\)</span> não é regular, se <span class="math inline">\(L_1 \cup L_2\)</span> fosse regular, então pela propriedade de fechamento das linguagens regulares sob interseção com linguagens regulares, poderíamos construir <span class="math inline">\(L_1\)</span> como uma interseção envolvendo <span class="math inline">\(L_1 \cup L_2\)</span>. Isso criaria uma contradição.</p>
<p><strong>Conclusão</strong>: <span class="math inline">\(L_1 \cup L_2\)</span> não é regular.</p></li>
<li><p><strong>Análise de <span class="math inline">\(L_1 \cdot L_2\)</span></strong></p>
<p><strong>Caracterização da concatenação</strong>: <span class="math display">\[L_1 \cdot L_2 = \{uv \mid u \in L_1 \text{ e } v \in L_2\}\]</span></p>
<p><strong>Análise de regularidade</strong>: A concatenação de duas linguagens não-regulares não é necessariamente não-regular. No entanto, neste caso específico, podemos mostrar que <span class="math inline">\(L_1 \cdot L_2\)</span> contém como subset a linguagem <span class="math inline">\(\{a^na^nb^nb^n \mid n \geq 0\} = \{a^{2n}b^{2n} \mid n \geq 0\}\)</span>, que é uma variação da linguagem de balanceamento e não é regular.</p>
<p><strong>Conclusão</strong>: <span class="math inline">\(L_1 \cdot L_2\)</span> não é regular.</p></li>
</ol>
<p><strong>Solução Letra c</strong>:</p>
<ol type="1">
<li><p><strong>Análise de <span class="math inline">\(L_3 = \{a^nb^n \mid n \geq 0\} \cup \{a^mb^m \mid m \geq 0\}\)</span></strong></p>
<p><strong>Simplificação da linguagem</strong>: <span class="math display">\[L_3 = \{a^nb^n \mid n \geq 0\} \cup \{a^mb^m \mid m \geq 0\} = \{a^kb^k \mid k \geq 0\}\]</span></p></li>
</ol>
<p>Ambos os conjuntos na união representam a mesma linguagem (apenas com variáveis diferentes).</p>
<p><strong>Análise de regularidade</strong>: A linguagem <span class="math inline">\(L_3 = \{a^kb^k \mid k \geq 0\}\)</span> é a linguagem clássica de <em>strings</em> balanceadas, que sabemos não ser regular.</p>
<p><strong>Aplicação do Lema do Bombeamento para <span class="math inline">\(L_3\)</span></strong>:</p>
<p>Assumindo que <span class="math inline">\(L_3\)</span> é regular, seja <span class="math inline">\(p\)</span> a constante de bombeamento. Escolhemos <span class="math inline">\(w = a^pb^p \in L_3\)</span>.</p>
<p>Para qualquer divisão <span class="math inline">\(w = xyz\)</span> com <span class="math inline">\(|xy| \leq p\)</span> e <span class="math inline">\(|y| &gt; 0\)</span>, temos <span class="math inline">\(y = a^k\)</span> com <span class="math inline">\(k \geq 1\)</span>.</p>
<p>Para <span class="math inline">\(i = 2\)</span>: <span class="math inline">\(xy^2z = a^{p+k}b^p\)</span>. Como <span class="math inline">\(p + k \neq p\)</span>, esta <em>string</em> não pertence a <span class="math inline">\(L_3\)</span>.</p>
<p>Isso contradiz o Lema do Bombeamento.</p>
<p><strong>Conclusão</strong>: <span class="math inline">\(L_3\)</span> não é regular, portanto <strong>não existe</strong> expressão regular para <span class="math inline">\(L_3\)</span>.</p>
</section>
<section id="exercício-5" class="level3" data-number="3.8.2">
<h3 data-number="3.8.2" class="anchored" data-anchor-id="exercício-5"><span class="header-section-number">3.8.2</span> Exercício 5</h3>
<p>Seja <span class="math inline">\(\Sigma\)</span> o alfabeto ASCII estendido. Defina os seguintes conjuntos de símbolos: a. <span class="math inline">\(L = (a \cup b \cup c \cup \ldots \cup z \cup A \cup B \cup C \cup \ldots \cup Z)\)</span> (letras); b. <span class="math inline">\(D = (0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)\)</span> (dígitos); c.&nbsp;<span class="math inline">\(D_{nz} = (1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)\)</span> (dígitos não-zero); d.&nbsp;<span class="math inline">\(S = (+ \cup - \cup * \cup / \cup = \cup &lt; \cup &gt; \cup !)\)</span> (símbolos de operadores).</p>
<p>Projete um analisador léxico para uma linguagem que suporte identificadores, números (inteiros, decimais, científicos), operadores aritméticos e relacionais, e comentários.</p>
<ol type="a">
<li>Construa expressões regulares sistemáticas para cada categoria de token.</li>
<li>Analise os conflitos de ambiguidade entre as categorias.</li>
<li>Estabeleça uma hierarquia de precedência para resolver os conflitos.</li>
</ol>
<p><strong>Solução Letra a</strong>:</p>
<section id="categoria-identificadores-r_id" class="level4" data-number="3.8.2.1">
<h4 data-number="3.8.2.1" class="anchored" data-anchor-id="categoria-identificadores-r_id"><span class="header-section-number">3.8.2.1</span> 1. Categoria: Identificadores (<span class="math inline">\(r_{id}\)</span>)</h4>
<p><strong>Especificação</strong>: Identificadores começam com letra ou underscore, seguidos de letras, dígitos ou underscores.</p>
<p><strong>Construção sistemática</strong>: 1. Símbolos iniciais válidos: <span class="math inline">\(S_{ini} = L \cup \{\_\}\)</span>; 2. Símbolos de continuação: <span class="math inline">\(S_{cont} = L \cup D \cup \{\_\}\)</span>; 3. Expressão para identificadores:</p>
<p><span class="math display">\[r_{id} = S_{ini} \cdot S_{cont}^*\]</span></p>
<p><strong>Expandindo as definições</strong>: <span class="math display">\[r_{id} = (L \cup \{\_\}) \cdot (L \cup D \cup \{\_\})^*\]</span></p>
</section>
<section id="categoria-números-r_num" class="level4" data-number="3.8.2.2">
<h4 data-number="3.8.2.2" class="anchored" data-anchor-id="categoria-números-r_num"><span class="header-section-number">3.8.2.2</span> 2. Categoria: Números (<span class="math inline">\(r_{num}\)</span>)</h4>
<p><strong>Subcategoria 2.1 - Números Inteiros (<span class="math inline">\(r_{int}\)</span>)</strong>: 1. Zero isolado: <span class="math inline">\(0\)</span>; 2. Números positivos: <span class="math inline">\(D_{nz} \cdot D^*\)</span>; 3. Números com sinal: <span class="math inline">\((+ \cup - \cup \epsilon) \cdot (0 \cup (D_{nz} \cdot D^*))\)</span>.</p>
<p><span class="math display">\[r_{int} = (+ \cup - \cup \epsilon) \cdot (0 \cup (D_{nz} \cdot D^*))\]</span></p>
<p><strong>Subcategoria 2.2 - Números Decimais (<span class="math inline">\(r_{dec}\)</span>)</strong>: - Parte inteira obrigatória, ponto, parte fracionária obrigatória:</p>
<p><span class="math display">\[r_{dec} = r_{int} \cdot \{.\} \cdot D \cdot D^*\]</span></p>
<p><strong>Subcategoria 2.3 - Notação Científica (<span class="math inline">\(r_{sci}\)</span>)</strong>: - Base (inteiro ou decimal), indicador científico, expoente:</p>
<p><span class="math display">\[r_{sci} = (r_{int} \cup r_{dec}) \cdot (e \cup E) \cdot (+ \cup - \cup \epsilon) \cdot D \cdot D^*\]</span></p>
<p><strong>Expressão completa para números</strong>: <span class="math display">\[r_{num} = r_{sci} \cup r_{dec} \cup r_{int}\]</span></p>
</section>
<section id="categoria-operadores-r_op" class="level4" data-number="3.8.2.3">
<h4 data-number="3.8.2.3" class="anchored" data-anchor-id="categoria-operadores-r_op"><span class="header-section-number">3.8.2.3</span> 3. Categoria: Operadores (<span class="math inline">\(r_{op}\)</span>)</h4>
<p><strong>Subcategoria 3.1 - Operadores Simples (<span class="math inline">\(r_{op\_simples}\)</span>)</strong>: <span class="math display">\[r_{op\_simples} = + \cup - \cup * \cup / \cup = \cup &lt; \cup &gt;\]</span></p>
<p><strong>Subcategoria 3.2 - Operadores Compostos (<span class="math inline">\(r_{op\_comp}\)</span>)</strong>:</p>
<ol type="1">
<li>Incremento/Decremento: <span class="math inline">\((+ \cdot +) \cup (- \cdot -)\)</span>;</li>
<li>Igualdade/Desigualdade: <span class="math inline">\((= \cdot =) \cup (! \cdot =)\)</span>;</li>
<li>Relacionais compostos: <span class="math inline">\((&lt; \cdot =) \cup (&gt; \cdot =)\)</span>.</li>
</ol>
<p><span class="math display">\[r_{op\_comp} = (+ \cdot +) \cup (- \cdot -) \cup (= \cdot =) \cup (! \cdot =) \cup (&lt; \cdot =) \cup (&gt; \cdot =)\]</span></p>
<p><strong>Expressão completa para operadores</strong>: <span class="math display">\[r_{op} = r_{op\_comp} \cup r_{op\_simples}\]</span></p>
</section>
<section id="categoria-comentários-r_com" class="level4" data-number="3.8.2.4">
<h4 data-number="3.8.2.4" class="anchored" data-anchor-id="categoria-comentários-r_com"><span class="header-section-number">3.8.2.4</span> 4. Categoria: Comentários (<span class="math inline">\(r_{com}\)</span>)</h4>
<p><strong>Subcategoria 4.1 - Comentários de Linha (<span class="math inline">\(r_{com\_linha}\)</span>)</strong>: 1. Sequência <code>//</code> seguida de qualquer caractere até quebra de linha:</p>
<p><span class="math display">\[r_{com\_linha} = / \cdot / \cdot \Sigma_{texto}^* \cdot \text{EOL}\]</span></p>
<p>onde <span class="math inline">\(\Sigma_{texto}\)</span> representa todos os caracteres exceto quebra de linha.</p>
<p><strong>Subcategoria 4.2 - Comentários de Bloco (<span class="math inline">\(r_{com\_bloco}\)</span>)</strong>: 1. Sequência <code>/*</code> seguida de qualquer texto até <code>*/</code>:</p>
<p><span class="math display">\[r_{com\_bloco} = / \cdot * \cdot \Sigma_{qualquer}^* \cdot * \cdot /\]</span></p>
<p>onde <span class="math inline">\(\Sigma_{qualquer}\)</span> representa qualquer caractere, mas com restrição de não formar <code>*/</code> prematuramente.</p>
<p><strong>Expressão completa para comentários</strong>: <span class="math display">\[r_{com} = r_{com\_linha} \cup r_{com\_bloco}\]</span></p>
<p><strong>Solução Letra b</strong>:</p>
</section>
<section id="análise-de-conflitos-de-ambiguidade" class="level4" data-number="3.8.2.5">
<h4 data-number="3.8.2.5" class="anchored" data-anchor-id="análise-de-conflitos-de-ambiguidade"><span class="header-section-number">3.8.2.5</span> Análise de Conflitos de Ambiguidade</h4>
<ol type="1">
<li><p><strong>Conflito 1 - Identificadores vs Palavras-chave</strong>: palavras reservadas como <code>if</code>, <code>while</code>, <code>for</code> são sintaticamente válidas como identificadores.</p>
<ul>
<li><strong>Exemplo</strong>: A <em>string</em> <code>if</code> satisfaz <span class="math inline">\(r_{id} = (L \cup \{\_\}) \cdot (L \cup D \cup \{\_\})^*\)</span></li>
<li><strong>Impacto</strong>: O analisador não pode distinguir entre palavra-chave e identificador apenas pela forma</li>
</ul></li>
<li><p><strong>Conflito 2 - Operadores Compostos vs Sequência de Operadores Simples</strong>: sequências como <code>++</code> podem ser interpretadas como operador composto ou dois operadores <code>+</code>.</p>
<p><strong>Exemplo</strong>: A <em>string</em> <code>++</code> satisfaz tanto <span class="math inline">\(r_{op\_comp}\)</span> quanto <span class="math inline">\(r_{op\_simples} \cdot r_{op\_simples}\)</span> <strong>Implicação</strong>: Ambiguidade na tokenização que afeta a análise sintática</p></li>
<li><p><strong>Conflito 3 - Números Decimais vs Operador Ponto</strong>: se existir operador ponto (<code>.</code>), pode conflitar com números decimais.</p></li>
</ol>
<p><strong>Exemplo</strong>: <code>1.5</code> pode ser interpretado como número decimal ou <code>1</code> seguido de <code>.</code> seguido de <code>5</code> <strong>Contexto</strong>: Especialmente problemático em linguagens com notação de acesso a membros</p>
<ol start="4" type="1">
<li><strong>Conflito 4 - Comentários vs Operadores de Divisão</strong>: o símbolo <code>/</code> inicia tanto comentários quanto operação de divisão</li>
</ol>
<p><strong>Exemplo</strong>: A sequência <code>/</code> pode ser início de <code>//</code>, <code>/*</code> ou operador de divisão <strong>Complexidade</strong>: Requer lookahead para decidir a interpretação</p>
<ol start="5" type="1">
<li><strong>Conflito 5 - Sinais vs Operadores vs Números com Sinal</strong>: os símbolos <code>+</code> e <code>-</code> podem ser operadores binários, unários, ou parte de números.</li>
</ol>
<p><strong>Exemplo</strong>: <code>-5</code> pode ser número negativo ou operador <code>-</code> seguido de número <code>5</code> <strong>Dependência</strong>: Resolução depende do contexto sintático</p>
<p><strong>Solução Letra c</strong>:</p>
</section>
<section id="hierarquia-de-precedência-para-resolução-de-conflitos" class="level4" data-number="3.8.2.6">
<h4 data-number="3.8.2.6" class="anchored" data-anchor-id="hierarquia-de-precedência-para-resolução-de-conflitos"><span class="header-section-number">3.8.2.6</span> Hierarquia de Precedência para Resolução de Conflitos</h4>
<ol type="1">
<li><strong>Nível 1 (Maior Precedência): Comentários</strong></li>
</ol>
<ul>
<li><strong>Regra</strong>: Reconhecer <code>//</code> e <code>/*</code> antes de qualquer outra análise</li>
<li><strong>Justificativa</strong>: Comentários alteram fundamentalmente o processamento (podem “comentar” outros tokens)</li>
<li><strong>Implementação</strong>: Scanner deve verificar comentários primeiro em cada posição</li>
</ul>
<ol start="2" type="1">
<li><strong>Nível 2: Palavras-chave Reservadas</strong></li>
</ol>
<ul>
<li><strong>Regra</strong>: Lista finita de palavras reservadas tem precedência sobre <span class="math inline">\(r_{id}\)</span></li>
<li><strong>Método</strong>: Lookup table de palavras-chave após reconhecer padrão de identificador</li>
<li><strong>Algoritmo</strong>:
<ol type="1">
<li>Aplicar <span class="math inline">\(r_{id}\)</span> para reconhecer padrão</li>
<li>Consultar tabela de palavras reservadas</li>
<li>Se encontrada, classificar como palavra-chave; senão, como identificador</li>
</ol></li>
</ul>
<ol start="3" type="1">
<li><strong>Nível 3: Números (Regra do Maior Match)</strong></li>
</ol>
<ul>
<li><strong>Regra</strong>: Sempre consumir a maior sequência válida como número</li>
<li><strong>Ordem de tentativa</strong>: <span class="math inline">\(r_{sci} \succ r_{dec} \succ r_{int}\)</span></li>
<li><strong>Exemplo</strong>: <code>1.5e-3</code> deve ser reconhecido como um token científico, não como três tokens separados</li>
</ul>
<ol start="4" type="1">
<li><strong>Nível 4: Operadores Compostos (Regra do Maior Match)</strong></li>
</ol>
<ul>
<li><strong>Regra</strong>: Operadores compostos têm precedência sobre sequências de operadores simples</li>
<li><strong>Exemplo</strong>: <code>++</code> é reconhecido como incremento, não como dois operadores <code>+</code></li>
<li><strong>Implementação</strong>: Verificar padrões compostos antes dos simples</li>
</ul>
<ol start="5" type="1">
<li><strong>Nível 5: Operadores Simples</strong></li>
</ol>
<ul>
<li><strong>Regra</strong>: Reconhecer operadores individuais</li>
<li><strong>Resolução de ambiguidade</strong>: Dependente do contexto sintático (análise posterior)</li>
</ul>
<p><strong>Algoritmo de Tokenização</strong>:</p>
<p>A seguir a esforçada leitora pode ver um pseudocódigo de um dos possíveis algoritmos de <em>tokenização</em> que implementa a hierarquia de precedência conforme definido neste exercício:</p>
<pre class="pseudocode"><code>Para cada posição no texto fonte:
   1. Ignorar espaços em branco
   2. Se match(r_com): retornar TOKEN_COMENTARIO
   3. Se match(r_num): retornar TOKEN_NUMERO
   4. Se match(r_id):
      4.1. Se é palavra_reservada: retornar TOKEN_PALAVRA_CHAVE
      4.2. Senão: retornar TOKEN_IDENTIFICADOR
   5. Se match(r_op_comp): retornar TOKEN_OPERADOR_COMPOSTO
   6. Se match(r_op_simples): retornar TOKEN_OPERADOR_SIMPLES
   7. Senão: erro léxico</code></pre>
<p><strong>Considerações Especiais</strong>:</p>
<ol type="1">
<li><p><strong>Lookahead Necessário</strong>:</p>
<ul>
<li>Comentários: Verificar <code>/</code> seguido de <code>/</code> ou <code>*</code>;</li>
<li>Operadores: Verificar <code>+</code> seguido de <code>+</code>, <code>=</code> seguido de <code>=</code>, etc.;</li>
<li>Números científicos: Verificar <code>e</code>/<code>E</code> em contexto numérico.</li>
</ul></li>
<li><p><strong>Tratamento de Contexto</strong>:</p>
<ul>
<li>Sinais unários vs binários: Resolver na fase de análise sintática;</li>
<li>Números negativos: Tratar como operador unário aplicado a número positivo.</li>
</ul></li>
</ol>
</section>
<section id="em-c-23" class="level4" data-number="3.8.2.7">
<h4 data-number="3.8.2.7" class="anchored" data-anchor-id="em-c-23"><span class="header-section-number">3.8.2.7</span> Em C++ 23</h4>
<p>O código a seguir contém uma implementação do analisador léxico definido neste problema em C++23, usando as características desta linguagem para simplificar a implementação:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string_view&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;expected&gt;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ranges&gt;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;concepts&gt;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;optional&gt;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Definição dos tipos de token seguindo nossa hierarquia</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> TokenType <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    COMENTARIO<span class="op">,</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    PALAVRA_CHAVE<span class="op">,</span> </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    NUMERO<span class="op">,</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    IDENTIFICADOR<span class="op">,</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    OPERADOR_COMPOSTO<span class="op">,</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    OPERADOR_SIMPLES<span class="op">,</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    UNKNOWN<span class="op">,</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    END_OF_INPUT</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co">// Estrutura do token</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    TokenType type<span class="op">;</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string value<span class="op">;</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Token: </span><span class="sc">{}</span><span class="st"> | Valor: '</span><span class="sc">{}</span><span class="st">'"</span><span class="op">,</span> to_string<span class="op">(</span>type<span class="op">),</span> value<span class="op">);</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="co">// Conversão de TokenType para string</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string to_string<span class="op">(</span>TokenType type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> TokenType<span class="op">::</span>COMENTARIO<span class="op">:</span> <span class="cf">return</span> <span class="st">"COMENTARIO"</span><span class="op">;</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> TokenType<span class="op">::</span>PALAVRA_CHAVE<span class="op">:</span> <span class="cf">return</span> <span class="st">"PALAVRA_CHAVE"</span><span class="op">;</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> TokenType<span class="op">::</span>NUMERO<span class="op">:</span> <span class="cf">return</span> <span class="st">"NUMERO"</span><span class="op">;</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> TokenType<span class="op">::</span>IDENTIFICADOR<span class="op">:</span> <span class="cf">return</span> <span class="st">"IDENTIFICADOR"</span><span class="op">;</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> TokenType<span class="op">::</span>OPERADOR_COMPOSTO<span class="op">:</span> <span class="cf">return</span> <span class="st">"OPERADOR_COMPOSTO"</span><span class="op">;</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> TokenType<span class="op">::</span>OPERADOR_SIMPLES<span class="op">:</span> <span class="cf">return</span> <span class="st">"OPERADOR_SIMPLES"</span><span class="op">;</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> TokenType<span class="op">::</span>UNKNOWN<span class="op">:</span> <span class="cf">return</span> <span class="st">"UNKNOWN"</span><span class="op">;</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> TokenType<span class="op">::</span>END_OF_INPUT<span class="op">:</span> <span class="cf">return</span> <span class="st">"END_OF_INPUT"</span><span class="op">;</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"INVALID"</span><span class="op">;</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a><span class="co">// Conceitos para classificação de caracteres (conjuntos L, D, etc.)</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> Character <span class="op">=</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>T<span class="op">,</span> <span class="dt">char</span><span class="op">&gt;;</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CharacterClassifier <span class="op">{</span></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Conjunto L = (a ∪ b ∪ ... ∪ z ∪ A ∪ B ∪ ... ∪ Z)</span></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> isLetter<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>c <span class="op">&gt;=</span> <span class="ch">'a'</span> <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> <span class="ch">'z'</span><span class="op">)</span> <span class="op">||</span> <span class="op">(</span>c <span class="op">&gt;=</span> <span class="ch">'A'</span> <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> <span class="ch">'Z'</span><span class="op">);</span></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Conjunto D = (0 ∪ 1 ∪ 2 ∪ ... ∪ 9)</span></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> isDigit<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> c <span class="op">&gt;=</span> <span class="ch">'0'</span> <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> <span class="ch">'9'</span><span class="op">;</span></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Conjunto D_nz = (1 ∪ 2 ∪ ... ∪ 9)</span></span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> isNonZeroDigit<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> c <span class="op">&gt;=</span> <span class="ch">'1'</span> <span class="op">&amp;&amp;</span> c <span class="op">&lt;=</span> <span class="ch">'9'</span><span class="op">;</span></span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Conjunto S_ini = L ∪ {_}</span></span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> isIdentifierStart<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> isLetter<span class="op">(</span>c<span class="op">)</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'_'</span><span class="op">;</span></span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Conjunto S_cont = L ∪ D ∪ {_}</span></span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> isIdentifierContinuation<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> isLetter<span class="op">(</span>c<span class="op">)</span> <span class="op">||</span> isDigit<span class="op">(</span>c<span class="op">)</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'_'</span><span class="op">;</span></span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> isWhitespace<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> c <span class="op">==</span> <span class="ch">' '</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'</span><span class="sc">\t</span><span class="ch">'</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'</span><span class="sc">\r</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> isOperatorSymbol<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> c <span class="op">==</span> <span class="ch">'+'</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'-'</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'*'</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'/'</span> <span class="op">||</span> </span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a>               c <span class="op">==</span> <span class="ch">'='</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'&lt;'</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'&gt;'</span> <span class="op">||</span> c <span class="op">==</span> <span class="ch">'!'</span><span class="op">;</span></span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LexicalAnalyzer <span class="op">{</span></span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string_view input<span class="op">;</span></span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> position <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Palavras-chave reservadas (Nível 2 da hierarquia)</span></span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_set<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> keywords <span class="op">=</span> <span class="op">{</span></span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a>        <span class="st">"if"</span><span class="op">,</span> <span class="st">"else"</span><span class="op">,</span> <span class="st">"while"</span><span class="op">,</span> <span class="st">"for"</span><span class="op">,</span> <span class="st">"int"</span><span class="op">,</span> <span class="st">"float"</span><span class="op">,</span> <span class="st">"double"</span><span class="op">,</span></span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>        <span class="st">"char"</span><span class="op">,</span> <span class="st">"void"</span><span class="op">,</span> <span class="st">"return"</span><span class="op">,</span> <span class="st">"break"</span><span class="op">,</span> <span class="st">"continue"</span><span class="op">,</span> <span class="st">"true"</span><span class="op">,</span> <span class="st">"false"</span></span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> LexicalAnalyzer<span class="op">(</span><span class="bu">std::</span>string_view text<span class="op">)</span> <span class="op">:</span> input<span class="op">(</span>text<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Método principal de tokenização seguindo nossa hierarquia</span></span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>expected<span class="op">&lt;</span>Token<span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> nextToken<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>        skipWhitespace<span class="op">();</span></span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>position <span class="op">&gt;=</span> input<span class="op">.</span>length<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Token<span class="op">{</span>TokenType<span class="op">::</span>END_OF_INPUT<span class="op">,</span> <span class="st">""</span><span class="op">};</span></span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Nível 1: Comentários (maior precedência)</span></span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> comment <span class="op">=</span> tryParseComment<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span>comment<span class="op">;</span></span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Nível 3: Números (regra do maior match)</span></span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> number <span class="op">=</span> tryParseNumber<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span>number<span class="op">;</span></span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Nível 2: Identificadores (depois verificamos se é palavra-chave)</span></span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> identifier <span class="op">=</span> tryParseIdentifier<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span>identifier<span class="op">;</span></span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Nível 4: Operadores compostos (regra do maior match)</span></span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> compoundOp <span class="op">=</span> tryParseCompoundOperator<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span>compoundOp<span class="op">;</span></span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Nível 5: Operadores simples</span></span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> simpleOp <span class="op">=</span> tryParseSimpleOperator<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span>simpleOp<span class="op">;</span></span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Erro léxico</span></span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>unexpected<span class="op">(</span><span class="bu">std::</span>format<span class="op">(</span><span class="st">"Caractere inválido '</span><span class="sc">{}</span><span class="st">' na posição </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> </span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a>                                         input<span class="op">[</span>position<span class="op">],</span> position<span class="op">));</span></span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> skipWhitespace<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>position <span class="op">&lt;</span> input<span class="op">.</span>length<span class="op">()</span> <span class="op">&amp;&amp;</span> CharacterClassifier<span class="op">::</span>isWhitespace<span class="op">(</span>input<span class="op">[</span>position<span class="op">]))</span> <span class="op">{</span></span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a>            position<span class="op">++;</span></span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> peek<span class="op">(</span><span class="dt">size_t</span> offset <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> pos <span class="op">=</span> position <span class="op">+</span> offset<span class="op">;</span></span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pos <span class="op">&lt;</span> input<span class="op">.</span>length<span class="op">()</span> <span class="op">?</span> input<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="ch">'</span><span class="sc">\0</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Nível 1: r_com = r_com_linha ∪ r_com_bloco</span></span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Token<span class="op">&gt;</span> tryParseComment<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>peek<span class="op">()</span> <span class="op">!=</span> <span class="ch">'/'</span><span class="op">)</span> <span class="cf">return</span> <span class="bu">std::</span>nullopt<span class="op">;</span></span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a>        <span class="co">// r_com_linha = / · / · Σ_texto* · EOL</span></span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>peek<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">'/'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a>            <span class="dt">size_t</span> start <span class="op">=</span> position<span class="op">;</span></span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a>            position <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Consome "//"</span></span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Consome até o final da linha</span></span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(</span>position <span class="op">&lt;</span> input<span class="op">.</span>length<span class="op">()</span> <span class="op">&amp;&amp;</span> input<span class="op">[</span>position<span class="op">]</span> <span class="op">!=</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a>                position<span class="op">++;</span></span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>position <span class="op">&lt;</span> input<span class="op">.</span>length<span class="op">())</span> position<span class="op">++;</span> <span class="co">// Consome '\n'</span></span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Token<span class="op">{</span>TokenType<span class="op">::</span>COMENTARIO<span class="op">,</span> </span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">std::</span>string<span class="op">(</span>input<span class="op">.</span>substr<span class="op">(</span>start<span class="op">,</span> position <span class="op">-</span> start<span class="op">))};</span></span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>        <span class="co">// r_com_bloco = / · * · Σ_qualquer* · * · /</span></span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>peek<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">'*'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a>            <span class="dt">size_t</span> start <span class="op">=</span> position<span class="op">;</span></span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a>            position <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Consome "/*"</span></span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Procura por "*/"</span></span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(</span>position <span class="op">&lt;</span> input<span class="op">.</span>length<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>input<span class="op">[</span>position<span class="op">]</span> <span class="op">==</span> <span class="ch">'*'</span> <span class="op">&amp;&amp;</span> input<span class="op">[</span>position <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="ch">'/'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a>                    position <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Consome "*/"</span></span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> Token<span class="op">{</span>TokenType<span class="op">::</span>COMENTARIO<span class="op">,</span></span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a>                                <span class="bu">std::</span>string<span class="op">(</span>input<span class="op">.</span>substr<span class="op">(</span>start<span class="op">,</span> position <span class="op">-</span> start<span class="op">))};</span></span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a>                position<span class="op">++;</span></span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Comentário não fechado - erro</span></span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>nullopt<span class="op">;</span></span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>nullopt<span class="op">;</span></span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Nível 3: r_num = r_sci ∪ r_dec ∪ r_int</span></span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Token<span class="op">&gt;</span> tryParseNumber<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>CharacterClassifier<span class="op">::</span>isDigit<span class="op">(</span>peek<span class="op">())</span> <span class="op">&amp;&amp;</span> </span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a>            peek<span class="op">()</span> <span class="op">!=</span> <span class="ch">'+'</span> <span class="op">&amp;&amp;</span> peek<span class="op">()</span> <span class="op">!=</span> <span class="ch">'-'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>nullopt<span class="op">;</span></span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> start <span class="op">=</span> position<span class="op">;</span></span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Consome sinal opcional</span></span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>peek<span class="op">()</span> <span class="op">==</span> <span class="ch">'+'</span> <span class="op">||</span> peek<span class="op">()</span> <span class="op">==</span> <span class="ch">'-'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a>            position<span class="op">++;</span></span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a>        <span class="co">// r_int = (+ ∪ - ∪ ε) · (0 ∪ (D_nz · D*))</span></span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>parseIntegerPart<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a>            position <span class="op">=</span> start<span class="op">;</span></span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>nullopt<span class="op">;</span></span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Tenta parte decimal: r_dec = r_int · {.} · D · D*</span></span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> hasDecimal <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>peek<span class="op">()</span> <span class="op">==</span> <span class="ch">'.'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a>            <span class="dt">size_t</span> dotPos <span class="op">=</span> position<span class="op">;</span></span>
<span id="cb3-220"><a href="#cb3-220" aria-hidden="true" tabindex="-1"></a>            position<span class="op">++;</span> <span class="co">// Consome '.'</span></span>
<span id="cb3-221"><a href="#cb3-221" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-222"><a href="#cb3-222" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>CharacterClassifier<span class="op">::</span>isDigit<span class="op">(</span>peek<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb3-223"><a href="#cb3-223" aria-hidden="true" tabindex="-1"></a>                hasDecimal <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-224"><a href="#cb3-224" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Consome dígitos após o ponto</span></span>
<span id="cb3-225"><a href="#cb3-225" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> <span class="op">(</span>CharacterClassifier<span class="op">::</span>isDigit<span class="op">(</span>peek<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb3-226"><a href="#cb3-226" aria-hidden="true" tabindex="-1"></a>                    position<span class="op">++;</span></span>
<span id="cb3-227"><a href="#cb3-227" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-228"><a href="#cb3-228" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-229"><a href="#cb3-229" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Não é número decimal, volta atrás</span></span>
<span id="cb3-230"><a href="#cb3-230" aria-hidden="true" tabindex="-1"></a>                position <span class="op">=</span> dotPos<span class="op">;</span></span>
<span id="cb3-231"><a href="#cb3-231" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-232"><a href="#cb3-232" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-233"><a href="#cb3-233" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-234"><a href="#cb3-234" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Tenta notação científica: r_sci = (r_int ∪ r_dec) · (e ∪ E) · (+ ∪ - ∪ ε) · D · D*</span></span>
<span id="cb3-235"><a href="#cb3-235" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>peek<span class="op">()</span> <span class="op">==</span> <span class="ch">'e'</span> <span class="op">||</span> peek<span class="op">()</span> <span class="op">==</span> <span class="ch">'E'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-236"><a href="#cb3-236" aria-hidden="true" tabindex="-1"></a>            <span class="dt">size_t</span> expPos <span class="op">=</span> position<span class="op">;</span></span>
<span id="cb3-237"><a href="#cb3-237" aria-hidden="true" tabindex="-1"></a>            position<span class="op">++;</span> <span class="co">// Consome 'e' ou 'E'</span></span>
<span id="cb3-238"><a href="#cb3-238" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-239"><a href="#cb3-239" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Sinal opcional no expoente</span></span>
<span id="cb3-240"><a href="#cb3-240" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>peek<span class="op">()</span> <span class="op">==</span> <span class="ch">'+'</span> <span class="op">||</span> peek<span class="op">()</span> <span class="op">==</span> <span class="ch">'-'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-241"><a href="#cb3-241" aria-hidden="true" tabindex="-1"></a>                position<span class="op">++;</span></span>
<span id="cb3-242"><a href="#cb3-242" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-243"><a href="#cb3-243" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-244"><a href="#cb3-244" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Deve ter pelo menos um dígito no expoente</span></span>
<span id="cb3-245"><a href="#cb3-245" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>CharacterClassifier<span class="op">::</span>isDigit<span class="op">(</span>peek<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb3-246"><a href="#cb3-246" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> <span class="op">(</span>CharacterClassifier<span class="op">::</span>isDigit<span class="op">(</span>peek<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb3-247"><a href="#cb3-247" aria-hidden="true" tabindex="-1"></a>                    position<span class="op">++;</span></span>
<span id="cb3-248"><a href="#cb3-248" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-249"><a href="#cb3-249" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-250"><a href="#cb3-250" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Notação científica inválida</span></span>
<span id="cb3-251"><a href="#cb3-251" aria-hidden="true" tabindex="-1"></a>                position <span class="op">=</span> expPos<span class="op">;</span></span>
<span id="cb3-252"><a href="#cb3-252" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-253"><a href="#cb3-253" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-254"><a href="#cb3-254" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-255"><a href="#cb3-255" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Token<span class="op">{</span>TokenType<span class="op">::</span>NUMERO<span class="op">,</span> </span>
<span id="cb3-256"><a href="#cb3-256" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>string<span class="op">(</span>input<span class="op">.</span>substr<span class="op">(</span>start<span class="op">,</span> position <span class="op">-</span> start<span class="op">))};</span></span>
<span id="cb3-257"><a href="#cb3-257" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-258"><a href="#cb3-258" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-259"><a href="#cb3-259" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> parseIntegerPart<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-260"><a href="#cb3-260" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>peek<span class="op">()</span> <span class="op">==</span> <span class="ch">'0'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-261"><a href="#cb3-261" aria-hidden="true" tabindex="-1"></a>            position<span class="op">++;</span></span>
<span id="cb3-262"><a href="#cb3-262" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-263"><a href="#cb3-263" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-264"><a href="#cb3-264" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-265"><a href="#cb3-265" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>CharacterClassifier<span class="op">::</span>isNonZeroDigit<span class="op">(</span>peek<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb3-266"><a href="#cb3-266" aria-hidden="true" tabindex="-1"></a>            position<span class="op">++;</span></span>
<span id="cb3-267"><a href="#cb3-267" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(</span>CharacterClassifier<span class="op">::</span>isDigit<span class="op">(</span>peek<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb3-268"><a href="#cb3-268" aria-hidden="true" tabindex="-1"></a>                position<span class="op">++;</span></span>
<span id="cb3-269"><a href="#cb3-269" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-270"><a href="#cb3-270" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-271"><a href="#cb3-271" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-272"><a href="#cb3-272" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-273"><a href="#cb3-273" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb3-274"><a href="#cb3-274" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-275"><a href="#cb3-275" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-276"><a href="#cb3-276" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Nível 2: r_id = (L ∪ {_}) · (L ∪ D ∪ {_})*</span></span>
<span id="cb3-277"><a href="#cb3-277" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Token<span class="op">&gt;</span> tryParseIdentifier<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-278"><a href="#cb3-278" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>CharacterClassifier<span class="op">::</span>isIdentifierStart<span class="op">(</span>peek<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb3-279"><a href="#cb3-279" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>nullopt<span class="op">;</span></span>
<span id="cb3-280"><a href="#cb3-280" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-281"><a href="#cb3-281" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-282"><a href="#cb3-282" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> start <span class="op">=</span> position<span class="op">;</span></span>
<span id="cb3-283"><a href="#cb3-283" aria-hidden="true" tabindex="-1"></a>        position<span class="op">++;</span> <span class="co">// Consome primeiro caractere</span></span>
<span id="cb3-284"><a href="#cb3-284" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-285"><a href="#cb3-285" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Consome caracteres de continuação</span></span>
<span id="cb3-286"><a href="#cb3-286" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>CharacterClassifier<span class="op">::</span>isIdentifierContinuation<span class="op">(</span>peek<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb3-287"><a href="#cb3-287" aria-hidden="true" tabindex="-1"></a>            position<span class="op">++;</span></span>
<span id="cb3-288"><a href="#cb3-288" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-289"><a href="#cb3-289" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-290"><a href="#cb3-290" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string value<span class="op">(</span>input<span class="op">.</span>substr<span class="op">(</span>start<span class="op">,</span> position <span class="op">-</span> start<span class="op">));</span></span>
<span id="cb3-291"><a href="#cb3-291" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-292"><a href="#cb3-292" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Verifica se é palavra-chave (Nível 2 da hierarquia)</span></span>
<span id="cb3-293"><a href="#cb3-293" aria-hidden="true" tabindex="-1"></a>        TokenType type <span class="op">=</span> keywords<span class="op">.</span>contains<span class="op">(</span>value<span class="op">)</span> <span class="op">?</span> </span>
<span id="cb3-294"><a href="#cb3-294" aria-hidden="true" tabindex="-1"></a>                        TokenType<span class="op">::</span>PALAVRA_CHAVE <span class="op">:</span> TokenType<span class="op">::</span>IDENTIFICADOR<span class="op">;</span></span>
<span id="cb3-295"><a href="#cb3-295" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-296"><a href="#cb3-296" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Token<span class="op">{</span>type<span class="op">,</span> value<span class="op">};</span></span>
<span id="cb3-297"><a href="#cb3-297" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-298"><a href="#cb3-298" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-299"><a href="#cb3-299" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Nível 4: r_op_comp = (+ · +) ∪ (- · -) ∪ (= · =) ∪ (! · =) ∪ (&lt; · =) ∪ (&gt; · =)</span></span>
<span id="cb3-300"><a href="#cb3-300" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Token<span class="op">&gt;</span> tryParseCompoundOperator<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-301"><a href="#cb3-301" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> first <span class="op">=</span> peek<span class="op">();</span></span>
<span id="cb3-302"><a href="#cb3-302" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> second <span class="op">=</span> peek<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb3-303"><a href="#cb3-303" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-304"><a href="#cb3-304" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>first <span class="op">==</span> <span class="ch">'+'</span> <span class="op">&amp;&amp;</span> second <span class="op">==</span> <span class="ch">'+'</span><span class="op">)</span> <span class="op">||</span></span>
<span id="cb3-305"><a href="#cb3-305" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>first <span class="op">==</span> <span class="ch">'-'</span> <span class="op">&amp;&amp;</span> second <span class="op">==</span> <span class="ch">'-'</span><span class="op">)</span> <span class="op">||</span></span>
<span id="cb3-306"><a href="#cb3-306" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>first <span class="op">==</span> <span class="ch">'='</span> <span class="op">&amp;&amp;</span> second <span class="op">==</span> <span class="ch">'='</span><span class="op">)</span> <span class="op">||</span></span>
<span id="cb3-307"><a href="#cb3-307" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>first <span class="op">==</span> <span class="ch">'!'</span> <span class="op">&amp;&amp;</span> second <span class="op">==</span> <span class="ch">'='</span><span class="op">)</span> <span class="op">||</span></span>
<span id="cb3-308"><a href="#cb3-308" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>first <span class="op">==</span> <span class="ch">'&lt;'</span> <span class="op">&amp;&amp;</span> second <span class="op">==</span> <span class="ch">'='</span><span class="op">)</span> <span class="op">||</span></span>
<span id="cb3-309"><a href="#cb3-309" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>first <span class="op">==</span> <span class="ch">'&gt;'</span> <span class="op">&amp;&amp;</span> second <span class="op">==</span> <span class="ch">'='</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb3-310"><a href="#cb3-310" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-311"><a href="#cb3-311" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>string value<span class="op">{</span>first<span class="op">,</span> second<span class="op">};</span></span>
<span id="cb3-312"><a href="#cb3-312" aria-hidden="true" tabindex="-1"></a>            position <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb3-313"><a href="#cb3-313" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Token<span class="op">{</span>TokenType<span class="op">::</span>OPERADOR_COMPOSTO<span class="op">,</span> value<span class="op">};</span></span>
<span id="cb3-314"><a href="#cb3-314" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-315"><a href="#cb3-315" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-316"><a href="#cb3-316" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>nullopt<span class="op">;</span></span>
<span id="cb3-317"><a href="#cb3-317" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-318"><a href="#cb3-318" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-319"><a href="#cb3-319" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Nível 5: r_op_simples = + ∪ - ∪ * ∪ / ∪ = ∪ &lt; ∪ &gt;</span></span>
<span id="cb3-320"><a href="#cb3-320" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Token<span class="op">&gt;</span> tryParseSimpleOperator<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-321"><a href="#cb3-321" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> c <span class="op">=</span> peek<span class="op">();</span></span>
<span id="cb3-322"><a href="#cb3-322" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-323"><a href="#cb3-323" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>CharacterClassifier<span class="op">::</span>isOperatorSymbol<span class="op">(</span>c<span class="op">))</span> <span class="op">{</span></span>
<span id="cb3-324"><a href="#cb3-324" aria-hidden="true" tabindex="-1"></a>            position<span class="op">++;</span></span>
<span id="cb3-325"><a href="#cb3-325" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Token<span class="op">{</span>TokenType<span class="op">::</span>OPERADOR_SIMPLES<span class="op">,</span> <span class="bu">std::</span>string<span class="op">(</span><span class="dv">1</span><span class="op">,</span> c<span class="op">)};</span></span>
<span id="cb3-326"><a href="#cb3-326" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-327"><a href="#cb3-327" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-328"><a href="#cb3-328" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>nullopt<span class="op">;</span></span>
<span id="cb3-329"><a href="#cb3-329" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-330"><a href="#cb3-330" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-331"><a href="#cb3-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-332"><a href="#cb3-332" aria-hidden="true" tabindex="-1"></a><span class="co">// Função para processar uma linha de entrada</span></span>
<span id="cb3-333"><a href="#cb3-333" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> processLine<span class="op">(</span><span class="bu">std::</span>string_view line<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-334"><a href="#cb3-334" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">=== Analisando: '</span><span class="sc">{}</span><span class="st">' ==="</span><span class="op">,</span> line<span class="op">);</span></span>
<span id="cb3-335"><a href="#cb3-335" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-336"><a href="#cb3-336" aria-hidden="true" tabindex="-1"></a>    LexicalAnalyzer analyzer<span class="op">(</span>line<span class="op">);</span></span>
<span id="cb3-337"><a href="#cb3-337" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-338"><a href="#cb3-338" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-339"><a href="#cb3-339" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> result <span class="op">=</span> analyzer<span class="op">.</span>nextToken<span class="op">();</span></span>
<span id="cb3-340"><a href="#cb3-340" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-341"><a href="#cb3-341" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>result<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-342"><a href="#cb3-342" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"ERRO: </span><span class="sc">{}</span><span class="st">"</span><span class="op">,</span> result<span class="op">.</span>error<span class="op">());</span></span>
<span id="cb3-343"><a href="#cb3-343" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-344"><a href="#cb3-344" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-345"><a href="#cb3-345" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-346"><a href="#cb3-346" aria-hidden="true" tabindex="-1"></a>        Token token <span class="op">=</span> <span class="op">*</span>result<span class="op">;</span></span>
<span id="cb3-347"><a href="#cb3-347" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-348"><a href="#cb3-348" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>token<span class="op">.</span>type <span class="op">==</span> TokenType<span class="op">::</span>END_OF_INPUT<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-349"><a href="#cb3-349" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>println<span class="op">(</span><span class="st">"=== Fim da análise ==="</span><span class="op">);</span></span>
<span id="cb3-350"><a href="#cb3-350" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-351"><a href="#cb3-351" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-352"><a href="#cb3-352" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-353"><a href="#cb3-353" aria-hidden="true" tabindex="-1"></a>        token<span class="op">.</span>print<span class="op">();</span></span>
<span id="cb3-354"><a href="#cb3-354" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-355"><a href="#cb3-355" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-356"><a href="#cb3-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-357"><a href="#cb3-357" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-358"><a href="#cb3-358" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>println<span class="op">(</span><span class="st">"=== Analisador Léxico C++23 ==="</span><span class="op">);</span></span>
<span id="cb3-359"><a href="#cb3-359" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>println<span class="op">(</span><span class="st">"Digite expressões linha por linha (Ctrl+C para sair):"</span><span class="op">);</span></span>
<span id="cb3-360"><a href="#cb3-360" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>println<span class="op">();</span></span>
<span id="cb3-361"><a href="#cb3-361" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-362"><a href="#cb3-362" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string line<span class="op">;</span></span>
<span id="cb3-363"><a href="#cb3-363" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>getline<span class="op">(</span><span class="bu">std::</span>cin<span class="op">,</span> line<span class="op">))</span> <span class="op">{</span></span>
<span id="cb3-364"><a href="#cb3-364" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>line<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-365"><a href="#cb3-365" aria-hidden="true" tabindex="-1"></a>            processLine<span class="op">(</span>line<span class="op">);</span></span>
<span id="cb3-366"><a href="#cb3-366" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-367"><a href="#cb3-367" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>println<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">Digite a próxima expressão:"</span><span class="op">);</span></span>
<span id="cb3-368"><a href="#cb3-368" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-369"><a href="#cb3-369" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-370"><a href="#cb3-370" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-371"><a href="#cb3-371" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Para usar:</p>
<pre class="shell"><code>Digite: int x = 42;</code></pre>
<p>Neste caso a saída deve ser:</p>
<pre class="shell"><code>Token: PALAVRA_CHAVE | Valor: 'int'
Token: IDENTIFICADOR | Valor: 'x'
Token: OPERADOR_SIMPLES | Valor: '='
Token: NUMERO | Valor: '42'</code></pre>
</section>
</section>
</section>
<section id="exercício-6-classes-de-equivalência" class="level2" data-number="3.9">
<h2 data-number="3.9" class="anchored" data-anchor-id="exercício-6-classes-de-equivalência"><span class="header-section-number">3.9</span> Exercício 6: Classes de Equivalência</h2>
<p>Considere a linguagem <span class="math inline">\(L = \{w \in \{0,1\}^* \mid w \text{ contém um número par de } 0\text{'s e um número ímpar de } 1\text{'s}\}\)</span>.</p>
<ol type="a">
<li>Determine quantas classes de equivalência existem na relação de Myhill-Nerode para <span class="math inline">\(L\)</span> (ver <a href="apend1.html" class="quarto-xref"><span>Chapter 9</span></a>).</li>
<li>Construa o autômato finito correspondente.</li>
</ol>
<p><strong>Solução Letra a</strong></p>
<ol type="1">
<li><strong>Classes de equivalência</strong>: precisamos rastrear paridades de 0’s e 1’s:</li>
</ol>
<ol type="a">
<li><span class="math inline">\(q_{00}\)</span>: par de 0’s, par de 1’s;</li>
<li><span class="math inline">\(q_{01}\)</span>: par de 0’s, ímpar de 1’s ← <strong>estado de aceitação</strong>;</li>
<li><span class="math inline">\(q_{10}\)</span>: ímpar de 0’s, par de 1’s;</li>
<li><span class="math inline">\(q_{11}\)</span>: ímpar de 0’s, ímpar de 1’s.</li>
</ol>
<p><strong>Total: 4 classes de equivalência</strong></p>
<p><strong>Solução Letra b: Autômato Finito</strong>:</p>
<p>Estados: {q00, q01, q10, q11} Estado inicial: q00 Estado final: {q01}</p>
<table class="table">
<thead>
<tr class="header">
<th>Estado</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>→q00</td>
<td>q10</td>
<td>q01</td>
</tr>
<tr class="even">
<td>*q01</td>
<td>q11</td>
<td>q00</td>
</tr>
<tr class="odd">
<td>q10</td>
<td>q00</td>
<td>q11</td>
</tr>
<tr class="even">
<td>q11</td>
<td>q01</td>
<td>q10</td>
</tr>
</tbody>
</table>
<p>Legenda: <code>→</code> Estado inicial; <code>*</code> Estado final.</p>
<section id="exercício-7-lema-do-bombeamento" class="level3" data-number="3.9.1">
<h3 data-number="3.9.1" class="anchored" data-anchor-id="exercício-7-lema-do-bombeamento"><span class="header-section-number">3.9.1</span> Exercício 7: Lema do Bombeamento</h3>
<p>Considere a linguagem <span class="math inline">\(L = \{0^i1^j0^k \mid i, j, k \geq 1 \text{ e } i + k = j\}\)</span>.</p>
<ol type="a">
<li>Prove que <span class="math inline">\(L\)</span> não é regular usando o Lema do Bombeamento.</li>
<li>Identifique qual propriedade específica de <span class="math inline">\(L\)</span> viola a capacidade dos autômatos finitos.</li>
<li>Construa uma linguagem regular <span class="math inline">\(L'\)</span> que seja o “mais próxima possível” de <span class="math inline">\(L\)</span>.</li>
</ol>
<p><strong>Solução letra a</strong>:</p>
<ol type="1">
<li><strong>Prova usando Lema do Bombeamento</strong>:</li>
</ol>
<p>Assumimos que <span class="math inline">\(L\)</span> é regular. Seja <span class="math inline">\(p\)</span> a constante do bombeamento.</p>
<p>Escolhemos <span class="math inline">\(w = 0^p1^{2p}0^p \in L\)</span> (pois <span class="math inline">\(p + p = 2p\)</span>).</p>
<p>Como <span class="math inline">\(|w| = 4p \geq p\)</span>, podemos dividir <span class="math inline">\(w = xyz\)</span> onde: - <span class="math inline">\(|y| &gt; 0\)</span> - <span class="math inline">\(|xy| \leq p\)</span><br>
- <span class="math inline">\(xy^iz \in L\)</span> para todo <span class="math inline">\(i \geq 0\)</span></p>
<p>Como <span class="math inline">\(|xy| \leq p\)</span> e <span class="math inline">\(w\)</span> começa com <span class="math inline">\(p\)</span> zeros, temos <span class="math inline">\(y = 0^m\)</span> para algum <span class="math inline">\(1 \leq m \leq p\)</span>.</p>
<p>Para <span class="math inline">\(i = 2\)</span>: <span class="math inline">\(w' = xy^2z = 0^{p+m}1^{2p}0^p\)</span></p>
<p>Na <em>string</em> <span class="math inline">\(w'\)</span>: - Número de 0’s iniciais: <span class="math inline">\(p + m\)</span> - Número de 1’s: <span class="math inline">\(2p\)</span><br>
- Número de 0’s finais: <span class="math inline">\(p\)</span></p>
<p>A condição <span class="math inline">\(i + k = j\)</span> requer: <span class="math inline">\((p + m) + p = 2p\)</span>, ou seja, <span class="math inline">\(2p + m = 2p\)</span>, logo <span class="math inline">\(m = 0\)</span>.</p>
<p>Mas isso contradiz <span class="math inline">\(|y| &gt; 0\)</span>, que implica <span class="math inline">\(m \geq 1\)</span>.</p>
<p>Portanto, <span class="math inline">\(L\)</span> não é regular.</p>
<p><strong>Solução Letra b</strong>:</p>
<p>A linguagem <span class="math inline">\(L\)</span> requer uma <strong>relação aritmética</strong> entre partes não-adjacentes da <em>string</em> (<span class="math inline">\(i + k = j\)</span>). Um autômato finito não pode “lembrar” o valor de <span class="math inline">\(i\)</span> para comparar com <span class="math inline">\(k\)</span> após processar toda a sequência de 1’s.</p>
<p><strong>Solução Letra c</strong>:</p>
<p><span class="math display">\[L' = 0^+1^+0^+\]</span></p>
<p>Esta linguagem captura a estrutura (0’s, depois 1’s, depois 0’s) sem a restrição aritmética.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./01-lexico.html" class="pagination-link" aria-label="Analisadores Léxicos">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Analisadores Léxicos</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./02-lexico.html" class="pagination-link" aria-label="Autômatos Finitos Determinísticos">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Autômatos Finitos Determinísticos</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/linguagens-formais/edit/main/01a-lexico.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linguagens-formais/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>