<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Linguagens Formais e Autômatos - 4&nbsp; Autômatos Finitos Determinísticos</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 1em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./parsers.html" rel="next">
<link href="./01a-lexico.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-lexico.html">Analisadores Léxicos</a></li><li class="breadcrumb-item"><a href="./02-lexico.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Autômatos Finitos Determinísticos</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Linguagens Formais e Autômatos</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/linguagens-formais" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Disciplina de Linguagens Formais</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Analisadores Léxicos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Analisadores Léxicos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01a-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Alfabetos, Linguagens e Strings: Fundamentos Matemáticos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-lexico.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Autômatos Finitos Determinísticos</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Analisadores Sintáticos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./parsers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Parsers LL(1): O Mundo da Análise Sintática</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./first-follow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Conjuntos FIRST e FOLLOW</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./tabela-derivacao.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Tabelas de Derivação (Análise) LL(1)</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Projeto da Disciplina</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fase1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Fase 1 - Projeto Prático</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apend1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Apêndice 1: A Relação de Myhill-Nerode</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sol-exercicios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Solução dos Exercícios</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referências</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#sec-definicao-formal" id="toc-sec-definicao-formal" class="nav-link active" data-scroll-target="#sec-definicao-formal"><span class="header-section-number">4.1</span> Definição Formal e Componentes</a>
  <ul class="collapse">
  <li><a href="#exercícios-1" id="toc-exercícios-1" class="nav-link" data-scroll-target="#exercícios-1"><span class="header-section-number">4.1.1</span> Exercícios 1</a></li>
  <li><a href="#sec-funcao-transicao-deterministica" id="toc-sec-funcao-transicao-deterministica" class="nav-link" data-scroll-target="#sec-funcao-transicao-deterministica"><span class="header-section-number">4.1.2</span> A Função de Transição Determinística</a></li>
  </ul></li>
  <li><a href="#representações-de-autômatos-finitos-determinísticos" id="toc-representações-de-autômatos-finitos-determinísticos" class="nav-link" data-scroll-target="#representações-de-autômatos-finitos-determinísticos"><span class="header-section-number">4.2</span> Representações de Autômatos Finitos Determinísticos</a>
  <ul class="collapse">
  <li><a href="#representação-tabular" id="toc-representação-tabular" class="nav-link" data-scroll-target="#representação-tabular"><span class="header-section-number">4.2.1</span> Representação Tabular</a></li>
  <li><a href="#representação-gráfica" id="toc-representação-gráfica" class="nav-link" data-scroll-target="#representação-gráfica"><span class="header-section-number">4.2.2</span> Representação Gráfica</a></li>
  <li><a href="#especificação-formal-do-exemplo" id="toc-especificação-formal-do-exemplo" class="nav-link" data-scroll-target="#especificação-formal-do-exemplo"><span class="header-section-number">4.2.3</span> Especificação Formal do Exemplo</a></li>
  <li><a href="#exercicios-3" id="toc-exercicios-3" class="nav-link" data-scroll-target="#exercicios-3"><span class="header-section-number">4.2.4</span> Exercícios 3</a></li>
  </ul></li>
  <li><a href="#computação-e-aceitação-de-strings" id="toc-computação-e-aceitação-de-strings" class="nav-link" data-scroll-target="#computação-e-aceitação-de-strings"><span class="header-section-number">4.3</span> Computação e Aceitação de <em>strings</em></a>
  <ul class="collapse">
  <li><a href="#exercicios-4" id="toc-exercicios-4" class="nav-link" data-scroll-target="#exercicios-4"><span class="header-section-number">4.3.1</span> Exercícios 4</a></li>
  </ul></li>
  <li><a href="#exemplos-práticos-de-autômatos-finitos-determinísticos" id="toc-exemplos-práticos-de-autômatos-finitos-determinísticos" class="nav-link" data-scroll-target="#exemplos-práticos-de-autômatos-finitos-determinísticos"><span class="header-section-number">4.4</span> Exemplos Práticos de Autômatos Finitos Determinísticos</a>
  <ul class="collapse">
  <li><a href="#exemplo-1-reconhecimento-de-números-binários-com-paridade-par" id="toc-exemplo-1-reconhecimento-de-números-binários-com-paridade-par" class="nav-link" data-scroll-target="#exemplo-1-reconhecimento-de-números-binários-com-paridade-par"><span class="header-section-number">4.4.1</span> Exemplo 1: Reconhecimento de Números Binários com Paridade Par</a></li>
  <li><a href="#exemplo-2-reconhecimento-da-senha-abre" id="toc-exemplo-2-reconhecimento-da-senha-abre" class="nav-link" data-scroll-target="#exemplo-2-reconhecimento-da-senha-abre"><span class="header-section-number">4.4.2</span> Exemplo 2: Reconhecimento da Senha <em>abre</em></a></li>
  <li><a href="#exemplo-3-reconhecimento-de-operadores-relacionais" id="toc-exemplo-3-reconhecimento-de-operadores-relacionais" class="nav-link" data-scroll-target="#exemplo-3-reconhecimento-de-operadores-relacionais"><span class="header-section-number">4.4.3</span> Exemplo 3: Reconhecimento de Operadores Relacionais</a></li>
  <li><a href="#exercicios-5" id="toc-exercicios-5" class="nav-link" data-scroll-target="#exercicios-5"><span class="header-section-number">4.4.4</span> Exercícios 5</a></li>
  </ul></li>
  <li><a href="#considerações-sobre-implementação-prática" id="toc-considerações-sobre-implementação-prática" class="nav-link" data-scroll-target="#considerações-sobre-implementação-prática"><span class="header-section-number">4.5</span> Considerações sobre Implementação Prática</a></li>
  <li><a href="#propriedades-matemáticas-dos-autômatos-finitos-determinísticos" id="toc-propriedades-matemáticas-dos-autômatos-finitos-determinísticos" class="nav-link" data-scroll-target="#propriedades-matemáticas-dos-autômatos-finitos-determinísticos"><span class="header-section-number">4.6</span> Propriedades Matemáticas dos Autômatos Finitos Determinísticos</a>
  <ul class="collapse">
  <li><a href="#propriedades-de-fechamento" id="toc-propriedades-de-fechamento" class="nav-link" data-scroll-target="#propriedades-de-fechamento"><span class="header-section-number">4.6.1</span> Propriedades de Fechamento</a></li>
  <li><a href="#implicações-práticas-das-propriedades-de-fechamento" id="toc-implicações-práticas-das-propriedades-de-fechamento" class="nav-link" data-scroll-target="#implicações-práticas-das-propriedades-de-fechamento"><span class="header-section-number">4.6.2</span> Implicações Práticas das Propriedades de Fechamento</a></li>
  <li><a href="#Exercicios-9" id="toc-Exercicios-9" class="nav-link" data-scroll-target="#Exercicios-9"><span class="header-section-number">4.6.3</span> Exercícios 9</a></li>
  <li><a href="#sec-myhill-nerode" id="toc-sec-myhill-nerode" class="nav-link" data-scroll-target="#sec-myhill-nerode"><span class="header-section-number">4.6.4</span> A Relação de Myhill-Nerode</a></li>
  <li><a href="#equivalência-entre-modelos" id="toc-equivalência-entre-modelos" class="nav-link" data-scroll-target="#equivalência-entre-modelos"><span class="header-section-number">4.6.5</span> Equivalência entre Modelos</a></li>
  <li><a href="#teste-de-equivalência-entre-autômatos-finitos-determinísticos" id="toc-teste-de-equivalência-entre-autômatos-finitos-determinísticos" class="nav-link" data-scroll-target="#teste-de-equivalência-entre-autômatos-finitos-determinísticos"><span class="header-section-number">4.6.6</span> Teste de Equivalência entre Autômatos Finitos Determinísticos</a></li>
  <li><a href="#implicações-práticas-das-propriedades" id="toc-implicações-práticas-das-propriedades" class="nav-link" data-scroll-target="#implicações-práticas-das-propriedades"><span class="header-section-number">4.6.7</span> Implicações Práticas das Propriedades</a></li>
  <li><a href="#Exercicios-10" id="toc-Exercicios-10" class="nav-link" data-scroll-target="#Exercicios-10"><span class="header-section-number">4.6.8</span> Exercícios 10</a></li>
  <li><a href="#limitações-dos-autômatos-finitos" id="toc-limitações-dos-autômatos-finitos" class="nav-link" data-scroll-target="#limitações-dos-autômatos-finitos"><span class="header-section-number">4.6.9</span> Limitações dos Autômatos Finitos</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/linguagens-formais/edit/main/02-lexico.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linguagens-formais/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-lexico.html">Analisadores Léxicos</a></li><li class="breadcrumb-item"><a href="./02-lexico.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Autômatos Finitos Determinísticos</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-aut-finitos-deterministicos" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Autômatos Finitos Determinísticos</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\02-expresso.html">Expresso</a>.</p>
</div>
</div>
<p>Como vimos no capítulo anterior, as <strong>Máquinas de Estados Finitos</strong> formam a base teórica para os analisadores léxicos. Entre os diferentes tipos de máquinas de estados, os <strong>Autômatos Finitos Determinísticos</strong> ocupam uma posição de especial importância na engenharia de compiladores, representando a forma mais eficiente e prática de implementar o reconhecimento de padrões léxicos.</p>
<p>Um Autômato Finito Determinístico é um modelo matemático preciso para representar sistemas que podem estar em um número finito de estados e que respondem a entradas de forma completamente previsível e unívoca. A palavra <em>determinístico</em> é fundamental aqui: para cada combinação de estado atual e símbolo de entrada, existe <strong>exatamente uma</strong> transição possível. Esta propriedade elimina qualquer ambiguidade no processo de reconhecimento, tornando os Autômatos Finitos Determinísticos ideais para implementações práticas como os analisadores léxicos.</p>
<p>A importância dos Autômatos Finitos Determinísticos na análise léxica não pode ser subestimada. Eles representam o produto final do processo de construção de analisadores léxicos: uma máquina de estados que pode processar um fluxo de caracteres em tempo linear, identificando <em>tokens</em> de forma eficiente e sem ambiguidades. Como veremos ao longo deste capítulo, a elegante leitora descobrirá que esta simplicidade aparente esconde uma poderosa capacidade de reconhecimento que fundamenta toda a primeira fase da compilação.</p>
<section id="sec-definicao-formal" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sec-definicao-formal"><span class="header-section-number">4.1</span> Definição Formal e Componentes</h2>
<p>Um Autômato Finito Determinístico é formalmente definido como uma 5-tupla matemática:</p>
<p><span class="math display">\[M = (Q, \Sigma, \delta, q_0, F)\]</span></p>
<p>na qual cada componente possui um papel específico e bem definido:</p>
<ul>
<li><span class="math inline">\(Q\)</span> é o conjunto finito de estados da máquina;</li>
<li><span class="math inline">\(\Sigma\)</span> é o alfabeto de entrada, um conjunto finito de símbolos;</li>
<li><span class="math inline">\(\delta\)</span> é a função de transição determinística;</li>
<li><span class="math inline">\(q_0\)</span> é o estado inicial único;</li>
<li><span class="math inline">\(F\)</span> é o conjunto de estados de aceitação (ou estados finais).</li>
</ul>
<p>É importante que a atenta leitora observe que esta definição impõe restrições matemáticas precisas:</p>
<p><span class="math display">\[q_0 \in Q \quad \text{e} \quad F \subseteq Q\]</span></p>
<p>Estas restrições garantem a consistência do modelo: o estado inicial deve necessariamente pertencer ao conjunto de estados, e todos os estados de aceitação devem ser estados válidos da máquina. Mais formalmente, um Autômato Finito Determinístico representa um sistema que, em qualquer momento, encontra-se em exatamente um estado do conjunto <span class="math inline">\(Q\)</span>, e que, ao receber um símbolo de entrada do alfabeto <span class="math inline">\(\Sigma\)</span>, transita deterministicamente para um novo estado, que pode, inclusive, ser o mesmo estado atual.</p>
<section id="exercícios-1" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="exercícios-1"><span class="header-section-number">4.1.1</span> Exercícios 1</h3>
<p><strong>1.</strong> Dado o Autômato Finito Determinístico <span class="math inline">\(M =(\{s_0,s_1,s_2,s_3\},\{a,b\},\delta,s_0,\{s_0,s_3\})\)</span>, identifique cada um dos cinco componentes da tupla com sua respectiva descrição.</p>
<p><strong>2.</strong> Um modelo foi definido como <span class="math inline">\(M =(Q,\Sigma,\delta,q_0,F)\)</span> onde <span class="math inline">\(Q=\{q_0,q_1\}\)</span>, <span class="math inline">\(\Sigma=\{0,1\}\)</span>, <span class="math inline">\(q_0=q_0\)</span>, e <span class="math inline">\(F=\{q_2\}\)</span>. Este modelo representa um Autômato Finito Determinístico válido? Justifique sua resposta com base nas restrições formais.</p>
<p><strong>3.</strong> Se um Autômato Finito Determinístico possui <span class="math inline">\(\mid Q \mid=3\)</span> estados e um alfabeto com <span class="math inline">\(\mid \Sigma \mid=4\)</span> símbolos, qual é o número exato de pares no domínio da função de transição <span class="math inline">\(\delta\)</span>?</p>
<p><strong>4.</strong> É possível que o conjunto de estados de aceitação <span class="math inline">\(F\)</span> seja igual ao conjunto de todos os estados <span class="math inline">\(Q\)</span>? Se sim, o que isso significaria sobre a linguagem reconhecida pelo autômato?</p>
<p><strong>5.</strong> É possível que o estado inicial <span class="math inline">\(q_0\)</span> também seja um estado de aceitação, ou seja, q_0inF? Se sim, o que isso implica sobre a aceitação da <em>string</em> vazia, epsilon?</p>
</section>
<section id="sec-funcao-transicao-deterministica" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="sec-funcao-transicao-deterministica"><span class="header-section-number">4.1.2</span> A Função de Transição Determinística</h3>
<p>O coração de um Autômato Finito Determinístico reside na sua <strong>função de transição</strong> <span class="math inline">\(\delta\)</span>, que captura completamente o comportamento da máquina. Esta função é definida matematicamente como:</p>
<p><span class="math display">\[\delta : Q \times \Sigma \rightarrow Q\]</span></p>
<p>A função de transição <span class="math inline">\(\delta\)</span> possui uma propriedade fundamental que a distingue de modelos não-determinísticos: para cada par <span class="math inline">\((q, a)\)</span> no qual <span class="math inline">\(q \in Q\)</span> e <span class="math inline">\(a \in \Sigma\)</span>, existe <strong>exatamente um</strong> estado de destino. Esta unicidade elimina qualquer ambiguidade no processo de computação e permite que a máquina seja simulada de forma eficiente em tempo linear.</p>
<p>A definição matemática da função de transição <span class="math inline">\(\delta : Q \times \Sigma \rightarrow Q\)</span> implica que ela deve ser uma <strong>função total</strong>, ou seja, deve haver exatamente uma transição definida para cada par de estado e símbolo de entrada. Um Autômato Finito Determinístico que cumpre essa exigência é chamado de <strong>completo</strong>.</p>
<p>Na prática, muitos autômatos possuem combinações de estado e símbolo que quebram a lógica do padrão que está sendo reconhecido. Por exemplo, em um autômato que reconhece a palavra “treco”, o que acontece se ele estiver no estado inicial e ler a letra ‘z’?</p>
<p>Para tratar esses casos e manter a função de transição total, introduz-se um <strong>estado de erro</strong>, também conhecido como <em>estado poço</em> ou <em>sumidouro</em>. Este é um estado especial não-final do qual não há escapatória: toda transição a partir do estado de erro aponta para ele mesmo.</p>
<p><span class="math display">\[
\forall a \in \Sigma, \quad \delta(q_{\text{erro}}, a) = q_{\text{erro}}
\]</span></p>
<p>Dessa forma, qualquer sequência de entrada que desvie do padrão desejado é permanentemente capturada pelo estado de erro, garantindo que a <em>string</em> seja rejeitada. Por uma questão de clareza visual, muitos diagramas de transição omitem o estado de erro e as setas que levam a ele, mas é importante saber que, para um autômato ser formalmente completo, essas transições implícitas devem existir.</p>
<p>A característica determinística da função de transição tem implicações profundas para a implementação prática. Em um Autômato Finito Determinístico, não há <em>escolhas</em> a serem feitas durante a execução: dado o estado atual e o símbolo de entrada, o próximo estado é inequivocamente determinado. Esta propriedade permite implementações extremamente eficientes, nas quais cada símbolo de entrada requer apenas uma consulta à tabela de transições, tipicamente implementada como um array bidimensional, ou uma operação equivalente.</p>
<p>O domínio da função <span class="math inline">\(\delta\)</span> é o produto cartesiano <span class="math inline">\(Q \times \Sigma\)</span>, que representa o conjunto de todas as combinações possíveis de estado atual e símbolo de entrada. Para uma máquina com cardinalidade <span class="math inline">\(\mid Q \mid = n\)</span> estados e um alfabeto com cardinalidade <span class="math inline">\(\mid \Sigma \mid = k\)</span> símbolos, existem exatamente <span class="math inline">\(n \times k\)</span> transições possíveis, e cada uma deve estar definida para que o autômato seja completo e funcional.</p>
<section id="exercicios-2" class="level4" data-number="4.1.2.1">
<h4 data-number="4.1.2.1" class="anchored" data-anchor-id="exercicios-2"><span class="header-section-number">4.1.2.1</span> Exercícios 2</h4>
<p><strong>1.</strong> Considere um Autômato Finito Determinístico que reconhece identificadores que começam com ‘l’ (letra) e são seguidos por ‘d’ (dígito). O alfabeto é <span class="math inline">\(\Sigma=l,d\)</span>. As transições definidas são <span class="math inline">\(\delta(q_0,l)=q_1\)</span> e <span class="math inline">\(\delta(q_1,d)=q_1\)</span>. O estado de aceitação é <span class="math inline">\(F=q_1\)</span>. Este autômato é <strong>completo</strong>? Se não, adicione um estado de erro <span class="math inline">\(q_e\)</span> e liste todas as transições que faltam para completá-lo.</p>
<p><strong>2.</strong> Explique com suas próprias palavras por que a propriedade determinística (para cada par <span class="math inline">\((q,a)\)</span>, existe <strong>exatamente um</strong> estado de destino) é importante para a eficiência da implementação de um analisador léxico.</p>
<p><strong>3.</strong> Um estado de erro (ou poço) pode ser um estado de aceitação? Justifique sua resposta com base na função de um estado de erro.</p>
<p><strong>4.</strong> Se um Autômato Finito Determinístico completo não possui um estado de erro explicitamente desenhado em seu diagrama, o que se assume sobre as transições não mostradas?</p>
<p><strong>5.</strong> Dada a definição <span class="math inline">\(\delta:Q \times \Sigma \rightarrow Q\)</span>, se a máquina está no estado <span class="math inline">\(q_i\)</span> e lê um símbolo <span class="math inline">\(a \in \Sigma\)</span>, é possível que ela permaneça no mesmo estado, ou seja, <span class="math inline">\(\delta(q_i,a)=q_i\)</span>? Dê um exemplo prático.</p>
</section>
</section>
</section>
<section id="representações-de-autômatos-finitos-determinísticos" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="representações-de-autômatos-finitos-determinísticos"><span class="header-section-number">4.2</span> Representações de Autômatos Finitos Determinísticos</h2>
<p>Os Autômatos Finitos Determinísticos podem ser representados de diversas formas, cada uma adequada a diferentes contextos e propósitos. As três representações mais comuns são a <strong>algébrica</strong>, a <strong>tabular</strong> e a <strong>gráfica</strong>. Cada representação oferece vantagens específicas: a forma algébrica é precisa e compacta para definições formais, a tabela de transições é eficiente para implementação computacional, e o diagrama de transições oferece intuição visual sobre o comportamento da máquina.</p>
<section id="representação-tabular" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="representação-tabular"><span class="header-section-number">4.2.1</span> Representação Tabular</h3>
<p>A <strong>tabela de transições</strong> constitui uma das formas mais práticas e amplamente utilizadas para representar Autômatos Finitos Determinísticos, especialmente em implementações computacionais. Esta representação organiza a função de transição <span class="math inline">\(\delta\)</span> em uma matriz bidimensional, na qual as linhas correspondem aos estados e as colunas aos símbolos do alfabeto.</p>
<p>A <a href="#tbl-Automato" class="quarto-xref">Table&nbsp;<span>4.1</span></a> ilustra um exemplo de tabela de transições para um Autômato Finito Determinístico:</p>
<div id="tbl-Automato" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-Automato-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.1: Exemplo de tabela de transições para um Autômato Finito Determinístico que aceita <em>strings</em> que contenham pelo menos um ‘0’ seguido, em algum momento, por pelo menos um ‘1’.
</figcaption>
<div aria-describedby="tbl-Automato-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">Estado &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</th>
<th style="text-align: left;">0 &nbsp; &nbsp;</th>
<th style="text-align: left;">1 &nbsp; &nbsp;</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\rightarrow q_0\)</span></td>
<td style="text-align: left;"><span class="math inline">\(q_2\)</span></td>
<td style="text-align: left;"><span class="math inline">\(q_0\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(*q_1\)</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td style="text-align: left;"><span class="math inline">\(q_1\)</span></td>
<td style="text-align: left;"><span class="math inline">\(q_1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(q_2\)</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td style="text-align: left;"><span class="math inline">\(q_2\)</span></td>
<td style="text-align: left;"><span class="math inline">\(q_1\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Na <a href="#tbl-Automato" class="quarto-xref">Table&nbsp;<span>4.1</span></a>, as convenções notacionais seguem o padrão estabelecido na literatura de teoria da computação:</p>
<ul>
<li>Os <strong>estados</strong> estão listados na primeira coluna, cada um representando um elemento do conjunto <span class="math inline">\(Q\)</span>;</li>
<li>As <strong>colunas subsequentes</strong> representam os símbolos do alfabeto <span class="math inline">\(\Sigma = \{0, 1\}\)</span>;</li>
<li>As <strong>células da tabela</strong> contêm os estados de destino, definindo completamente a função <span class="math inline">\(\delta\)</span>;</li>
<li>A <strong>seta</strong> <span class="math inline">\(\rightarrow\)</span> identifica o estado inicial <span class="math inline">\(q_0\)</span>;</li>
<li>O <strong>asterisco</strong> <span class="math inline">\(*\)</span> marca os estados de aceitação, neste caso, o conjunto <span class="math inline">\(F = \{q_1\}\)</span>.</li>
</ul>
<p>Esta representação tabular possui vantagens computacionais significativas. A implementação de um Autômato Finito Determinístico baseada em tabela permite acesso em tempo constante <span class="math inline">\(O(1)\)</span> para cada transição, resultando em uma complexidade total de <span class="math inline">\(O(n)\)</span> para processar uma <em>string</em> de entrada de comprimento <span class="math inline">\(n\)</span>. Além disso, a estrutura tabular mapeia-se naturalmente para arrays bidimensionais na maioria das linguagens de programação.</p>
</section>
<section id="representação-gráfica" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="representação-gráfica"><span class="header-section-number">4.2.2</span> Representação Gráfica</h3>
<p>A representação gráfica, conhecida como <strong>diagrama de transições</strong>, oferece uma visualização intuitiva do comportamento dinâmico do Autômato Finito Determinístico. Nesta representação, a máquina é modelada como um grafo direcionado, no qual os vértices representam estados e as arestas rotuladas representam transições.</p>
<p>A <a href="#fig-Automato" class="quarto-xref">Figure&nbsp;<span>4.1</span></a> apresenta o diagrama de transições correspondente à tabela <a href="#tbl-Automato" class="quarto-xref">Table&nbsp;<span>4.1</span></a>:</p>
<div id="fig-Automato" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Automato-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/dia1.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Automato-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.1: Diagrama de transições de um Autômato Finito Determinístico que aceita <em>strings</em> que contenham pelo menos um ‘0’ seguido, em algum momento, por pelo menos um ‘1’.
</figcaption>
</figure>
</div>
<p>No diagrama da <a href="#fig-Automato" class="quarto-xref">Figure&nbsp;<span>4.1</span></a>, as convenções visuais estabelecem uma linguagem gráfica precisa:</p>
<ul>
<li>Os <strong>círculos</strong> representam os estados do conjunto <span class="math inline">\(Q\)</span>;</li>
<li>As <strong>setas direcionadas</strong> representam as transições, codificando a função <span class="math inline">\(\delta\)</span>;</li>
<li>Os <strong>rótulos nas setas</strong> indicam os símbolos de entrada que causam as transições;</li>
<li>O <strong>estado inicial</strong> é identificado por uma seta sem origem, <em>vinda do nada</em>;</li>
<li>Os <strong>estados de aceitação</strong> são representados por círculos duplos, destacando visualmente sua função especial.</li>
</ul>
<p>A representação gráfica é particularmente valiosa para compreender o comportamento global da máquina e para visualizar caminhos de computação. Para a atenta leitora, o diagrama torna evidente que qualquer quantidade de ‘1’s iniciais será ignorada no estado <span class="math inline">\(q_0\)</span>. A máquina só avança ao ler um ’0’, transicionando para o estado <span class="math inline">\(q_2\)</span>. A partir daí, qualquer ‘1’ lido leva ao estado de aceitação <span class="math inline">\(q_1\)</span>, enquanto mais ’0’s mantêm a máquina em <span class="math inline">\(q_2\)</span>. Esta visualização facilita a compreensão do fluxo de estados e das condições de aceitação.</p>
</section>
<section id="especificação-formal-do-exemplo" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="especificação-formal-do-exemplo"><span class="header-section-number">4.2.3</span> Especificação Formal do Exemplo</h3>
<p>Para o Autômato Finito Determinístico ilustrado na <a href="#tbl-Automato" class="quarto-xref">Table&nbsp;<span>4.1</span></a> e na <a href="#fig-Automato" class="quarto-xref">Figure&nbsp;<span>4.1</span></a>, um autômato que aceita <em>strings</em> contendo um ‘0’ seguido em algum momento por um ‘1’ será dada pela 5-tupla <span class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span> definida como:</p>
<ul>
<li><strong>Conjunto de Estados (<span class="math inline">\(Q\)</span>)</strong>: <span class="math inline">\(Q = \{q_0, q_1, q_2\}\)</span>;</li>
<li><strong>Alfabeto (<span class="math inline">\(\Sigma\)</span>)</strong>: <span class="math inline">\(\Sigma = \{0, 1\}\)</span>;</li>
<li><strong>Estado Inicial (<span class="math inline">\(q_0\)</span>)</strong>: o estado inicial é <span class="math inline">\(q_0\)</span>;</li>
<li><strong>Conjunto de Estados de Aceitação (<span class="math inline">\(F\)</span>)</strong>: <span class="math inline">\(F = \{q_1\}\)</span>;</li>
<li><strong>Função de Transição (<span class="math inline">\(\delta\)</span>)</strong>:
<ul>
<li><span class="math inline">\(\delta(q_0, 0) = q_2\)</span></li>
<li><span class="math inline">\(\delta(q_0, 1) = q_0\)</span></li>
<li><span class="math inline">\(\delta(q_1, 0) = q_1\)</span></li>
<li><span class="math inline">\(\delta(q_1, 1) = q_1\)</span></li>
<li><span class="math inline">\(\delta(q_2, 0) = q_2\)</span></li>
<li><span class="math inline">\(\delta(q_2, 1) = q_1\)</span></li>
</ul></li>
</ul>
<p>Esta especificação formal define completamente o comportamento do autômato, incluindo seus estados, alfabeto, estado inicial, estados de aceitação e a função de transição. A atenta leitora notará que esta definição é suficiente para implementar ou simular o autômato em qualquer sistema computacional.</p>
</section>
<section id="exercicios-3" class="level3" data-number="4.2.4">
<h3 data-number="4.2.4" class="anchored" data-anchor-id="exercicios-3"><span class="header-section-number">4.2.4</span> Exercícios 3</h3>
<p><strong>1.</strong> Desenhe o diagrama de transições para o Autômato Finito Determinístico descrito pela seguinte tabela. Use as convenções gráficas para o estado inicial e os estados de aceitação.</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: left;">Estado</th>
<th style="text-align: left;">0</th>
<th style="text-align: left;">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">q_A</td>
<td style="text-align: left;">q_B</td>
<td style="text-align: left;">q_A</td>
</tr>
<tr class="even">
<td style="text-align: left;">q_B</td>
<td style="text-align: left;">q_B</td>
<td style="text-align: left;">q_C</td>
</tr>
<tr class="odd">
<td style="text-align: left;">*q_C</td>
<td style="text-align: left;">q_B</td>
<td style="text-align: left;">q_A</td>
</tr>
</tbody>
</table>
<p><strong>2.</strong> Para o diagrama de transições abaixo, que reconhece <em>strings</em> em a,b com um número par de ’a’s e um número par de ’b’s, forneça a especificação formal completa (a 5-tupla).</p>
<p><strong>3.</strong> Converta a especificação formal do Exemplo 2 da seção “Exemplos Práticos” (reconhecimento da senha <em>abre</em>) em uma tabela de transições completa, incluindo o estado de erro e todas as transições para ele. Considere o alfabeto =a,b,r,e,x, onde ‘x’ representa qualquer outro caractere.</p>
<p><strong>4.</strong> Qual representação (tabular, gráfica ou formal) você considera mais útil para depurar o comportamento de um autômato? E para implementá-lo em um programa? Justifique.</p>
<p><strong>5.</strong> Considere a tabela de transições da questão 3.1. Modifique-a para que o autômato passe a aceitar <em>strings</em> que terminam com “010” em vez de “01”.</p>
</section>
</section>
<section id="computação-e-aceitação-de-strings" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="computação-e-aceitação-de-strings"><span class="header-section-number">4.3</span> Computação e Aceitação de <em>strings</em></h2>
<p>O processo de <strong>computação</strong> em um Autômato Finito Determinístico segue um algoritmo simples e elegante. Dada uma <em>string</em> de entrada <span class="math inline">\(w = a_1a_2...a_k\)</span> onde cada <span class="math inline">\(a_i \in \Sigma\)</span>, a máquina executa os seguintes passos:</p>
<ol type="1">
<li><strong>Inicialização</strong>: a máquina posiciona-se no estado inicial <span class="math inline">\(q_0\)</span>;</li>
<li><strong>Processamento sequencial</strong>: para cada símbolo <span class="math inline">\(a_i\)</span> da <em>string</em> de entrada, a máquina transita do estado atual <span class="math inline">\(q\)</span> para o estado <span class="math inline">\(\delta(q, a_i)\)</span>;</li>
<li><strong>Decisão de aceitação</strong>: após processar todos os símbolos, a <em>string</em> é <strong>aceita</strong> se, e somente se, o estado final atingido pertence ao conjunto <span class="math inline">\(F\)</span> de estados de aceitação.</li>
</ol>
<p>Formalmente, uma <em>string</em> <span class="math inline">\(w\)</span> é aceita pelo Autômato Finito Determinístico <span class="math inline">\(M\)</span> se existe uma sequência de estados <span class="math inline">\(r_0, r_1, ..., r_k\)</span> tal que:</p>
<ul>
<li><span class="math inline">\(r_0 = q_0\)</span> (inicia no estado inicial);</li>
<li><span class="math inline">\(\delta(r_i, a_{i+1}) = r_{i+1}\)</span> para <span class="math inline">\(i = 0, 1, ..., k-1\)</span> (cada transição é válida);</li>
<li><span class="math inline">\(r_k \in F\)</span> (termina em um estado de aceitação).</li>
</ul>
<p>Esta formalização matemática da computação em Autômatos Finitos Determinísticos fundamenta toda a teoria de Linguagens Regulares e serve como base para os algoritmos de análise léxica utilizados em compiladores modernos.</p>
<section id="exercicios-4" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="exercicios-4"><span class="header-section-number">4.3.1</span> Exercícios 4</h3>
<p><strong>1.</strong> Usando o autômato da questão 3.1, trace a computação para a <em>string</em> 01101 e determine se ela é aceita ou rejeitada.</p>
<p><strong>2.</strong> Para o autômato do Exemplo 3 (operadores relacionais), trace a computação para a <em>string</em> &lt;= e determine o resultado.</p>
<p><strong>3.</strong> Para o mesmo autômato de operadores relacionais, o que acontece ao processar a <em>string</em> !=? E a <em>string</em> =!?</p>
<p><strong>4.</strong> Uma <em>string</em> é aceita se a computação termina em um estado de aceitação. Se uma <em>string</em> passa por um estado de aceitação no meio de sua computação, mas não termina em um, ela é aceita? Justifique com base na definição formal de aceitação.</p>
<p><strong>5.</strong> Descreva uma <em>string</em> de comprimento 5 que é aceita pelo autômato da questão 3.2 e uma que é rejeitada. Mostre o caminho para ambas.</p>
</section>
</section>
<section id="exemplos-práticos-de-autômatos-finitos-determinísticos" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="exemplos-práticos-de-autômatos-finitos-determinísticos"><span class="header-section-number">4.4</span> Exemplos Práticos de Autômatos Finitos Determinísticos</h2>
<p>Para consolidar a compreensão dos conceitos apresentados, a dedicada leitora encontrará a seguir três exemplos práticos que demonstram a versatilidade e aplicabilidade dos Autômatos Finitos Determinísticos em diferentes contextos. Estes exemplos ilustram desde problemas matemáticos básicos, como verificação de paridade, até aplicações práticas em análise léxica, como reconhecimento de senhas e operadores relacionais.</p>
<section id="exemplo-1-reconhecimento-de-números-binários-com-paridade-par" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="exemplo-1-reconhecimento-de-números-binários-com-paridade-par"><span class="header-section-number">4.4.1</span> Exemplo 1: Reconhecimento de Números Binários com Paridade Par</h3>
<p>O primeiro exemplo aborda um problema clássico na teoria da computação: o reconhecimento de números binários que possuem uma quantidade par de bits ‘1’. Este problema ilustra elegantemente como um Autômato Finito Determinístico pode manter informações de estado sobre propriedades matemáticas da entrada processada.</p>
<p><strong>Definição do Problema</strong>: construir um Autômato Finito Determinístico que aceite todas as <em>strings</em> binárias (sobre o alfabeto <span class="math inline">\(\Sigma = \{0, 1\}\)</span>) que contenham um número par de símbolos ‘1’, incluindo zero ocorrências.</p>
<p><strong>Análise</strong>: O autômato deve <em>contar</em> o número de bits ‘1’ processados, distinguindo entre quantidades pares e ímpares. Como só precisamos da paridade (par ou ímpar), dois estados são suficientes para capturar toda a informação necessária.</p>
<p>Uma forma de construir este autômato é definir dois estados: um para quando o número de ‘1’s é par e outro para quando é ímpar. A transição entre esses estados ocorre sempre que um símbolo ’1’ é lido, enquanto os símbolos ‘0’ não afetam a paridade. Em geral, tentar desenhar o diagrama de transições melhora a compreensão do comportamento do autômato. Neste caso, o <a href="#fig-dia2" class="quarto-xref">Figure&nbsp;<span>4.2</span></a> ilustra o diagrama de transições correspondente:</p>
<div id="fig-dia2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-dia2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/dia2.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-dia2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.2: Diagrama de transições de um Autômato Finito Determinístico que aceita <em>strings</em> binárias com número par de símbolos ‘1’.
</figcaption>
</figure>
</div>
<p><strong>Especificação Formal</strong>:</p>
<ul>
<li><strong>Estados</strong>: <span class="math inline">\(Q = \{q_{\text{par}}, q_{\text{ímpar}}\}\)</span>;</li>
<li><strong>Alfabeto</strong>: <span class="math inline">\(\Sigma = \{0, 1\}\)</span>;</li>
<li><strong>Estado inicial</strong>: <span class="math inline">\(q_0 = q_{\text{par}}\)</span>, zero, nenhum ‘1’, é par;</li>
<li><strong>Estados de aceitação</strong>: <span class="math inline">\(F = \{q_{\text{par}}\}\)</span>;</li>
<li><strong>Função de transição</strong>: <span class="math inline">\(\delta\)</span> definida por:
<ul>
<li><span class="math inline">\(\delta(q_{\text{par}}, 0) = q_{\text{par}}\)</span>, zeros não alteram a paridade;</li>
<li><span class="math inline">\(\delta(q_{\text{par}}, 1) = q_{\text{ímpar}}\)</span>, primeiro ‘1’ torna ímpar;</li>
<li><span class="math inline">\(\delta(q_{\text{ímpar}}, 0) = q_{\text{ímpar}}\)</span>, zeros não alteram a paridade;</li>
<li><span class="math inline">\(\delta(q_{\text{ímpar}}, 1) = q_{\text{par}}\)</span>, segundo ‘1’ retorna ao par.</li>
</ul></li>
</ul>
<p>A <a href="#tbl-paridade" class="quarto-xref">Table&nbsp;<span>4.2</span></a> apresenta a tabela de transições correspondente:</p>
<div id="tbl-paridade" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-paridade-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.2: Tabela de transições para reconhecimento de números binários com paridade par.
</figcaption>
<div aria-describedby="tbl-paridade-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 43%">
<col style="width: 28%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Estado</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\rightarrow *q_{\text{par}}\)</span></td>
<td><span class="math inline">\(q_{\text{par}}\)</span></td>
<td><span class="math inline">\(q_{\text{ímpar}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(q_{\text{ímpar}}\)</span></td>
<td><span class="math inline">\(q_{\text{ímpar}}\)</span></td>
<td><span class="math inline">\(q_{\text{par}}\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Este autômato funciona como um contador módulo 2. O estado <span class="math inline">\(q_{\text{par}}\)</span> representa que um número par de ‘1’s foi processado, enquanto <span class="math inline">\(q_{\text{ímpar}}\)</span> indica um número ímpar. Os bits ’0’ são irrelevantes para a paridade e não causam mudanças de estado. Este é um exemplo perfeito de como um Autômato Finito Determinístico pode manter informações agregadas sobre a entrada sem necessidade de memória ilimitada. A definição <em>zero é par</em> pode ser vista como uma convenção prática. Quando temos apenas um zero não há ’1’s para contar. Por isso, o estado inicial (que representa a leitura de zero ’1’s) é também um estado de aceitação.</p>
</section>
<section id="exemplo-2-reconhecimento-da-senha-abre" class="level3" data-number="4.4.2">
<h3 data-number="4.4.2" class="anchored" data-anchor-id="exemplo-2-reconhecimento-da-senha-abre"><span class="header-section-number">4.4.2</span> Exemplo 2: Reconhecimento da Senha <em>abre</em></h3>
<p>O segundo exemplo demonstra como Autômatos Finitos Determinísticos podem ser utilizados para reconhecer sequências específicas de caracteres, como senhas ou palavras-chave em linguagens de programação. Este tipo de reconhecimento é fundamental em analisadores léxicos.</p>
<p><strong>Definição do Problema</strong>: construir um Autômato Finito Determinístico que aceite exatamente a <em>string</em> <em>abre</em> sobre o alfabeto das letras minúsculas.</p>
<p><strong>Análise</strong>: o autômato deve reconhecer a sequência exata de caracteres ‘a’, ‘b’, ‘r’, ‘e’. Qualquer desvio desta sequência deve levar a um estado de rejeição. Como a entrada deve ser exatamente <em>abre</em>, necessitamos de cinco estados: um inicial, três intermediários correspondentes aos prefixos <em>a</em>, <em>ab</em>, <em>abr</em>, e um final de aceitação que corresponda a <em>abre</em>.</p>
<p>Novamente, o diagrama de transições ajuda a visualizar o comportamento do autômato. A <a href="#fig-dia3" class="quarto-xref">Figure&nbsp;<span>4.3</span></a> ilustra o diagrama de transições correspondente:</p>
<div id="fig-dia3" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-dia3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/dia3.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-dia3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.3: Diagrama de transições de um Autômato Finito Determinístico que aceita a <em>string</em> <em>abre</em>.
</figcaption>
</figure>
</div>
<p>No diagrama da <a href="#fig-dia3" class="quarto-xref">Figure&nbsp;<span>4.3</span></a>, cada estado representa um prefixo da <em>string</em> <em>abre</em>. A transição entre os estados ocorre conforme os caracteres são lidos, e o autômato rejeita qualquer entrada que não siga a sequência exata representada no diagrama por <span class="math inline">\(x\)</span>. O estado final <span class="math inline">\(q_4\)</span> é o único estado de aceitação, indicando que a <em>string</em> completa foi reconhecida com sucesso.</p>
<p><strong>Especificação Formal</strong>:</p>
<ul>
<li><strong>Estados</strong>: <span class="math inline">\(Q = \{q_0, q_1, q_2, q_3, q_4, q_{\text{erro}}\}\)</span>.</li>
<li><strong>Alfabeto</strong>: <span class="math inline">\(\Sigma = \{a, b, c, ..., z\}\)</span> (letras minúsculas).</li>
<li><strong>Estado inicial</strong>: <span class="math inline">\(q_0\)</span>.</li>
<li><strong>Estados de aceitação</strong>: <span class="math inline">\(F = \{q_4\}\)</span>.</li>
<li><strong>Função de transição</strong>: <span class="math inline">\(\delta\)</span> definida por:
<ul>
<li><span class="math inline">\(\delta(q_0, a) = q_1\)</span>, <span class="math inline">\(\delta(q_0, x) = q_{\text{erro}}\)</span> para <span class="math inline">\(x \neq a\)</span>;</li>
<li><span class="math inline">\(\delta(q_1, b) = q_2\)</span>, <span class="math inline">\(\delta(q_1, x) = q_{\text{erro}}\)</span> para <span class="math inline">\(x \neq b\)</span>;</li>
<li><span class="math inline">\(\delta(q_2, r) = q_3\)</span>, <span class="math inline">\(\delta(q_2, x) = q_{\text{erro}}\)</span> para <span class="math inline">\(x \neq r\)</span>;</li>
<li><span class="math inline">\(\delta(q_3, e) = q_4\)</span>, <span class="math inline">\(\delta(q_3, x) = q_{\text{erro}}\)</span> para <span class="math inline">\(x \neq e\)</span>;</li>
<li><span class="math inline">\(\delta(q_4, x) = q_{\text{erro}}\)</span> para qualquer <span class="math inline">\(x \in \Sigma\)</span>;</li>
<li><span class="math inline">\(\delta(q_{\text{erro}}, x) = q_{\text{erro}}\)</span> para qualquer <span class="math inline">\(x \in \Sigma\)</span>.</li>
</ul></li>
</ul>
<p>A <a href="#tbl-senha" class="quarto-xref">Table&nbsp;<span>4.3</span></a> apresenta uma versão simplificada da tabela de transições:</p>
<div id="tbl-senha" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-senha-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.3: Tabela de transições para reconhecimento da senha <em>abre</em>.
</figcaption>
<div aria-describedby="tbl-senha-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Estado</th>
<th>a</th>
<th>b</th>
<th>r</th>
<th>e</th>
<th>outros</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\rightarrow q_0\)</span></td>
<td><span class="math inline">\(q_1\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(q_1\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_2\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(q_2\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_3\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(q_3\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_4\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="odd">
<td>*<span class="math inline">\(q_4\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
<section id="exemplo-3-reconhecimento-de-operadores-relacionais" class="level3" data-number="4.4.3">
<h3 data-number="4.4.3" class="anchored" data-anchor-id="exemplo-3-reconhecimento-de-operadores-relacionais"><span class="header-section-number">4.4.3</span> Exemplo 3: Reconhecimento de Operadores Relacionais</h3>
<p>O terceiro exemplo aborda um problema típico da análise léxica: o reconhecimento de operadores relacionais compostos. Este exemplo ilustra como tratar ambiguidades que surgem quando alguns <em>tokens</em> são prefixos de outros <span class="citation" data-cites="Aho2007Compilers">(<a href="referencias.html#ref-Aho2007Compilers" role="doc-biblioref">1</a>)</span>.</p>
<p><strong>Definição do Problema</strong>: Construir um Autômato Finito Determinístico que reconheça os operadores relacionais: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, e <code>!=</code>.</p>
<p><strong>Análise</strong>: Este problema apresenta desafios interessantes. Os operadores <code>&gt;</code> e <code>&lt;</code> são prefixos dos operadores <code>&gt;=</code> e <code>&lt;=</code>, respectivamente. Similarmente, <code>=</code> seria prefixo de <code>==</code>. O autômato deve implementar a regra da correspondência mais longa (<em>maximal munch</em>), continuando a ler enquanto uma correspondência mais longa for possível.</p>
<p>Nós discutimos a regra da correspondência mais longa na seção <a href="01-lexico.html#sec-analisador-lexico" class="quarto-xref"><span>Section 2.2</span></a> do capítulo anterior. Esta regra é fundamental para resolver ambiguidades de prefixos. O autômato deve ser capaz de distinguir entre os operadores simples e compostos, aceitando os mais longos quando possível.</p>
<p>Vamos ver como construir o autômato passo a passo, definindo estados que correspondem a cada prefixo dos operadores. O estado inicial <span class="math inline">\(q_0\)</span> inicia o reconhecimento, e os estados subsequentes são alcançados conforme os símbolos de entrada são lidos. A <a href="#fig-dia4" class="quarto-xref">Figure&nbsp;<span>4.4</span></a> ilustra o diagrama de transições correspondente:</p>
<div id="fig-dia4" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-dia4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src=".\images/dia4.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-dia4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.4: Diagrama de transições de um Autômato Finito Determinístico capaz de identificar os operadores relacionais ‘&lt;’, ‘&gt;’, ‘&lt;=’, ‘&gt;=’, ‘==’, ‘!=’.
</figcaption>
</figure>
</div>
<p><strong>Especificação Formal</strong>:</p>
<ul>
<li><p><strong>Estados</strong>: <span class="math inline">\(Q = \{q_0, q_&gt;, q_&lt;, q_=, q_!, q_{\geq}, q_{\leq}, q_{==}, q_{\neq}, q_{\text{erro}}\}\)</span> ;</p></li>
<li><p><strong>Alfabeto</strong>: <span class="math inline">\(\Sigma = \{&gt;, &lt;, =, !, \text{outros}\}\)</span> ;</p></li>
<li><p><strong>Estado inicial</strong>: <span class="math inline">\(q_0\)</span> ;</p></li>
<li><p><strong>Estados de aceitação</strong>: <span class="math inline">\(F = \{q_&gt;, q_&lt;, q_{\geq}, q_{\leq}, q_{==}, q_{\neq}\}\)</span>.</p></li>
</ul>
<p>A <a href="#tbl-operadores" class="quarto-xref">Table&nbsp;<span>4.4</span></a> apresenta a tabela de transições:</p>
<div id="tbl-operadores" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-operadores-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.4: Tabela de transições para reconhecimento de operadores relacionais.
</figcaption>
<div aria-describedby="tbl-operadores-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Estado</th>
<th>&gt;</th>
<th>&lt;</th>
<th>=</th>
<th>!</th>
<th>outros</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\rightarrow q_0\)</span></td>
<td><span class="math inline">\(*q_&gt;\)</span></td>
<td><span class="math inline">\(*q_&lt;\)</span></td>
<td><span class="math inline">\(q_=\)</span></td>
<td><span class="math inline">\(q_!\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(*q_&gt;\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\geq}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(*q_&lt;\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\leq}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(*q_=\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{==}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(*q_!\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\neq}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(*q_{\geq}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(*q_{\leq}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(*q_{==}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(*q_{\neq}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
<td><span class="math inline">\(q_{\text{erro}}\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Note que os estados <span class="math inline">\(q_&gt;\)</span> e <span class="math inline">\(q_&lt;\)</span> são marcados como estados de aceitação, permitindo que os operadores simples <code>&gt;</code> e <code>&lt;</code> sejam reconhecidos. Contudo, se a entrada continuar com <code>=</code>, o autômato transita para os estados de aceitação <span class="math inline">\(q_{\geq}\)</span> ou <span class="math inline">\(q_{\leq}\)</span>, implementando assim a regra da correspondência mais longa. Os estados <span class="math inline">\(q_=\)</span> e <span class="math inline">\(q_!\)</span> não são de aceitação porque <code>=</code> e <code>!</code> isolados não são operadores relacionais válidos neste contexto - apenas <code>==</code> e <code>!=</code> são aceitos.</p>
</section>
<section id="exercicios-5" class="level3" data-number="4.4.4">
<h3 data-number="4.4.4" class="anchored" data-anchor-id="exercicios-5"><span class="header-section-number">4.4.4</span> Exercícios 5</h3>
<p><strong>1.</strong> Projete o diagrama de transições de um Autômato Finito Determinístico sobre <span class="math inline">\(\Sigma=\{a,b\}\)</span> que aceite todas e somente as <em>strings</em> que contêm a substring <code>aba</code>.</p>
<p><strong>2.</strong> Projete o diagrama de transições de um Autômato Finito Determinístico sobre <span class="math inline">\(\Sigma=\{0,1\}\)</span> que aceite <em>strings</em> que representam números binários cujo valor é múltiplo de <span class="math inline">\(3\)</span>. (Dica: Mantenha o resto da divisão por <span class="math inline">\(3\)</span> como estado. <span class="math inline">\(v(w0)=2 \cdot v(w)\)</span> e <span class="math inline">\(v(w1)=2 \cdot v(w)+1\)</span>).</p>
<p><strong>3.</strong> Projete a tabela de transições de um Autômato Finito Determinístico que reconhece comentários de uma linha em uma linguagem de programação hipotética. Um comentário começa com <code>//</code> e vai até o final da linha (não nos preocuparemos com o final da linha). O alfabeto é <span class="math inline">\(\Sigma=\{/,c\}\)</span>, onde ‘c’ representa qualquer outro caractere.</p>
<p><strong>4.</strong> Desenhe o diagrama de um Autômato Finito Determinístico que aceite <em>strings</em> em <span class="math inline">\(\Sigma=\{a,b\}\)</span> que tenham comprimento ímpar e terminem com ‘a’.</p>
<p><strong>5.</strong> Projete um Autômato Finito Determinístico que aceite apenas as <em>strings</em> <code>cat</code> e <code>car</code> sobre o alfabeto <span class="math inline">\(\Sigma=\{c,a,t,r\}\)</span>.</p>
</section>
</section>
<section id="considerações-sobre-implementação-prática" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="considerações-sobre-implementação-prática"><span class="header-section-number">4.5</span> Considerações sobre Implementação Prática</h2>
<p>Estes três exemplos demonstram alguns aspectos importantes dos Autômatos Finitos Determinísticos na análise léxica:</p>
<ol type="1">
<li><p><strong>Manutenção de Estado</strong>: O exemplo da paridade mostra como informações agregadas podem ser mantidas em estados finitos.</p></li>
<li><p><strong>Reconhecimento de Sequências</strong>: O exemplo da senha ilustra o reconhecimento determinístico de <em>strings</em> específicas, fundamental para palavras-chave.</p></li>
<li><p><strong>Tratamento de Ambiguidades</strong>: O exemplo dos operadores demonstra como resolver conflitos de prefixos através da regra da correspondência mais longa.</p></li>
</ol>
<p>A atenta leitora observará que estes padrões são ubíquos na construção de analisadores léxicos em aplicações práticas, formando os blocos que definem o reconhecimento de identificadores, números, palavras-chave e operadores em linguagens de programação reais.</p>
</section>
<section id="propriedades-matemáticas-dos-autômatos-finitos-determinísticos" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="propriedades-matemáticas-dos-autômatos-finitos-determinísticos"><span class="header-section-number">4.6</span> Propriedades Matemáticas dos Autômatos Finitos Determinísticos</h2>
<p>Os Autômatos Finitos Determinísticos não são apenas modelos computacionais elegantes; eles formam uma estrutura algébrica rica, dotada de propriedades matemáticas que fundamentam sua aplicabilidade prática. A perspicaz leitora descobrirá que estas propriedades não apenas garantem a robustez teórica do modelo, mas também possibilitam otimizações e transformações essenciais para implementações eficientes.</p>
<section id="propriedades-de-fechamento" class="level3" data-number="4.6.1">
<h3 data-number="4.6.1" class="anchored" data-anchor-id="propriedades-de-fechamento"><span class="header-section-number">4.6.1</span> Propriedades de Fechamento</h3>
<p>Uma das características notáveis da classe dos Autômatos Finitos Determinísticos é que ela é <strong>fechada</strong> sob as operações fundamentais da teoria dos conjuntos. Isto significa que, ao combinarmos Autômatos Finitos Determinísticos usando estas operações, o resultado é sempre outro Autômato Finito Determinístico. Esta propriedade tem implicações profundas tanto teóricas quanto práticas, especialmente na construção de analisadores léxicos que precisam reconhecer múltiplos padrões simultaneamente.</p>
<p>Considere o seguinte cenário prático: um analisador léxico precisa reconhecer tanto identificadores válidos quanto palavras-chave reservadas. Em vez de construir um único autômato complexo que trate ambos os casos, seria elegante construir dois autômatos simples e depois combiná-los. As propriedades de fechamento garantem que tal composição sempre resulta em outro Autômato Finito Determinístico válido, permitindo uma abordagem modular e sistemática para problemas complexos de reconhecimento.</p>
<section id="fechamento-sob-união" class="level4" data-number="4.6.1.1">
<h4 data-number="4.6.1.1" class="anchored" data-anchor-id="fechamento-sob-união"><span class="header-section-number">4.6.1.1</span> Fechamento sob União</h4>
<p><strong>Teorema (Fechamento sob União)</strong>: Sejam <span class="math inline">\(M_1\)</span> e <span class="math inline">\(M_2\)</span> dois Autômatos Finitos Determinísticos que reconhecem as linguagens <span class="math inline">\(L_1\)</span> e <span class="math inline">\(L_2\)</span>, respectivamente. Então existe um Autômato Finito Determinístico <span class="math inline">\(M\)</span> que reconhece <span class="math inline">\(L_1 \cup L_2\)</span>.</p>
<p>A intuição por trás da construção da união é elegante: executamos ambos os autômatos <strong>simultaneamente</strong> sobre a mesma entrada, mantendo o estado atual de cada um em um par ordenado. A atenta leitora pode visualizar isto como duas máquinas trabalhando em paralelo, processando o mesmo fluxo de símbolos. Se ao menos uma delas aceitar a entrada, o autômato combinado também aceita.</p>
<p><strong>Construção Formal do Produto</strong>: Dados:</p>
<ul>
<li><span class="math inline">\(M_1 = (Q_1, \Sigma, \delta_1, q_{01}, F_1)\)</span>;</li>
<li><span class="math inline">\(M_2 = (Q_2, \Sigma, \delta_2, q_{02}, F_2)\)</span>.</li>
</ul>
<p>Construímos <span class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span> no qual:</p>
<ul>
<li><span class="math inline">\(Q = Q_1 \times Q_2\)</span> (produto cartesiano dos conjuntos de estados);</li>
<li><span class="math inline">\(q_0 = (q_{01}, q_{02})\)</span> (par dos estados iniciais);</li>
<li><span class="math inline">\(F = (F_1 \times Q_2) \cup (Q_1 \times F_2)\)</span> (aceita se pelo menos um dos autômatos aceita);</li>
<li><span class="math inline">\(\delta((q_1, q_2), a) = (\delta_1(q_1, a), \delta_2(q_2, a))\)</span> para todo <span class="math inline">\((q_1, q_2) \in Q\)</span> e <span class="math inline">\(a \in \Sigma\)</span>.</li>
</ul>
<p>Para entender esse processo, considere dois Autômatos Finitos Determinísticos sobre o alfabeto <span class="math inline">\(\Sigma = \{a, b\}\)</span>:</p>
<ol type="1">
<li><strong>Autômato <span class="math inline">\(M_1\)</span></strong>: Aceita <em>strings</em> que começam com ‘a’</li>
</ol>
<ul>
<li>Estados: <span class="math inline">\(Q_1 = \{s_0, s_{\text{aceita}}, s_{\text{rejeita}}\}\)</span></li>
<li>Estado inicial: <span class="math inline">\(s_0\)</span></li>
<li>Estados finais: <span class="math inline">\(F_1 = \{s_{\text{aceita}}\}\)</span></li>
<li>Transições:
<ul>
<li><span class="math inline">\(\delta_1(s_0, a) = s_{\text{aceita}}\)</span></li>
<li><span class="math inline">\(\delta_1(s_0, b) = s_{\text{rejeita}}\)</span></li>
<li><span class="math inline">\(\delta_1(s_{\text{aceita}}, x) = s_{\text{aceita}}\)</span> para <span class="math inline">\(x \in \{a,b\}\)</span></li>
<li><span class="math inline">\(\delta_1(s_{\text{rejeita}}, x) = s_{\text{rejeita}}\)</span> para <span class="math inline">\(x \in \{a,b\}\)</span></li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><strong>Autômato <span class="math inline">\(M_2\)</span></strong>: Aceita <em>strings</em> com número par de ’b’s</li>
</ol>
<ul>
<li>Estados: <span class="math inline">\(Q_2 = \{t_{\text{par}}, t_{\text{ímpar}}\}\)</span></li>
<li>Estado inicial: <span class="math inline">\(t_{\text{par}}\)</span></li>
<li>Estados finais: <span class="math inline">\(F_2 = \{t_{\text{par}}\}\)</span></li>
<li>Transições:
<ul>
<li><span class="math inline">\(\delta_2(t_{\text{par}}, a) = t_{\text{par}}\)</span>, <span class="math inline">\(\delta_2(t_{\text{par}}, b) = t_{\text{ímpar}}\)</span></li>
<li><span class="math inline">\(\delta_2(t_{\text{ímpar}}, a) = t_{\text{ímpar}}\)</span>, <span class="math inline">\(\delta_2(t_{\text{ímpar}}, b) = t_{\text{par}}\)</span></li>
</ul></li>
</ul>
<p>A construção do autômato união <span class="math inline">\(M = M_1 \cup M_2\)</span> resulta em:</p>
<p><strong>Estados</strong>: <span class="math inline">\(Q = Q_1 \times Q_2\)</span> possui <span class="math inline">\(\mid Q_1 \mid \times \mid Q_2 \mid = 3 \times 2 = 6\)</span> estados</p>
<p><strong>Estados de Aceitação</strong>: um estado <span class="math inline">\((s_i, t_j)\)</span> é final se <span class="math inline">\(s_i \in F_1\)</span> <strong>ou</strong> <span class="math inline">\(t_j \in F_2\)</span>. Analisando cada par, teremos:</p>
<ul>
<li><span class="math inline">\((s_0, t_{\text{par}})\)</span>: aceita (pois <span class="math inline">\(t_{\text{par}} \in F_2\)</span>);</li>
<li><span class="math inline">\((s_0, t_{\text{ímpar}})\)</span>: rejeita;</li>
<li><span class="math inline">\((s_{\text{aceita}}, t_{\text{par}})\)</span>: aceita (ambos aceitam);</li>
<li><span class="math inline">\((s_{\text{aceita}}, t_{\text{ímpar}})\)</span>: aceita (pois <span class="math inline">\(s_{\text{aceita}} \in F_1\)</span>);</li>
<li><span class="math inline">\((s_{\text{rejeita}}, t_{\text{par}})\)</span>: aceita (pois <span class="math inline">\(t_{\text{par}} \in F_2\)</span>);</li>
<li><span class="math inline">\((s_{\text{rejeita}}, t_{\text{ímpar}})\)</span>: rejeita.</li>
</ul>
<p>A <a href="#tbl-uniao-exemplo" class="quarto-xref">Table&nbsp;<span>4.5</span></a> apresenta a tabela de transições completa:</p>
<div id="tbl-uniao-exemplo" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-uniao-exemplo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.5: Tabela de transições para o autômato união <span class="math inline">\(M_1 \cup M_2\)</span>
</figcaption>
<div aria-describedby="tbl-uniao-exemplo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 57%">
<col style="width: 21%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th>Estado</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\rightarrow *(s_0, t_{\text{par}})\)</span></td>
<td><span class="math inline">\((s_{\text{aceita}}, t_{\text{par}})\)</span></td>
<td><span class="math inline">\((s_{\text{rejeita}}, t_{\text{ímpar}})\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\((s_0, t_{\text{ímpar}})\)</span></td>
<td><span class="math inline">\((s_{\text{aceita}}, t_{\text{ímpar}})\)</span></td>
<td><span class="math inline">\((s_{\text{rejeita}}, t_{\text{par}})\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(*(s_{\text{aceita}}, t_{\text{par}})\)</span></td>
<td><span class="math inline">\((s_{\text{aceita}}, t_{\text{par}})\)</span></td>
<td><span class="math inline">\((s_{\text{aceita}}, t_{\text{ímpar}})\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(*(s_{\text{aceita}}, t_{\text{ímpar}})\)</span></td>
<td><span class="math inline">\((s_{\text{aceita}}, t_{\text{ímpar}})\)</span></td>
<td><span class="math inline">\((s_{\text{aceita}}, t_{\text{par}})\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(*(s_{\text{rejeita}}, t_{\text{par}})\)</span></td>
<td><span class="math inline">\((s_{\text{rejeita}}, t_{\text{par}})\)</span></td>
<td><span class="math inline">\((s_{\text{rejeita}}, t_{\text{ímpar}})\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\((s_{\text{rejeita}}, t_{\text{ímpar}})\)</span></td>
<td><span class="math inline">\((s_{\text{rejeita}}, t_{\text{ímpar}})\)</span></td>
<td><span class="math inline">\((s_{\text{rejeita}}, t_{\text{par}})\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p><strong>Verificação</strong>: Testemos a <em>string</em> “ba”:</p>
<ul>
<li><span class="math inline">\((s_0, t_{\text{par}}) \xrightarrow{b} (s_{\text{rejeita}}, t_{\text{ímpar}}) \xrightarrow{a} (s_{\text{rejeita}}, t_{\text{ímpar}})\)</span>;</li>
<li>Estado final: <span class="math inline">\((s_{\text{rejeita}}, t_{\text{ímpar}})\)</span> não é de aceitação;</li>
<li><span class="math inline">\(M_1\)</span> rejeita (não começa com ‘a’), <span class="math inline">\(M_2\)</span> rejeita (número ímpar de ’b’s);</li>
<li>União rejeita corretamente.</li>
</ul>
<p>A matemática é ótima, contudo, a construção da união pode requerer um pouco de prática para ser compreendida completamente. Para treinar, vamos construir a união de dois autômatos simples, ainda sobre o alfabeto <span class="math inline">\(\Sigma = \{a, b\}\)</span>, com uma pequena alteração do exemplo anterior, para solidificar o processo algébrico. Considere os autômatos a seguir:</p>
<p><strong>Autômato <span class="math inline">\(M_1\)</span>: Aceita strings que começam com ‘a’</strong>: um autômato que reconhece a linguagem <span class="math inline">\(L_1 = \{a, aa, ab, aaa, aab, aba, aaaa, ...\}\)</span>. Algebricamente, teremos:</p>
<ul>
<li>Estados: <span class="math inline">\(Q_1 = \{s_0, s_1, s_2\}\)</span> nos quais:
<ul>
<li><span class="math inline">\(s_0\)</span>: estado inicial (ainda não leu nada);</li>
<li><span class="math inline">\(s_1\)</span>: leu ‘a’ como primeiro símbolo (aceita);</li>
<li><span class="math inline">\(s_2\)</span>: leu ‘b’ como primeiro símbolo (rejeita).</li>
</ul></li>
<li>Estado inicial: <span class="math inline">\(s_0\)</span>.</li>
<li>Estados finais: <span class="math inline">\(F_1 = \{s_1\}\)</span>.</li>
<li>Transições:
<ul>
<li><span class="math inline">\(\delta_1(s_0, a) = s_1\)</span> (primeiro símbolo é ‘a’ → aceita);</li>
<li><span class="math inline">\(\delta_1(s_0, b) = s_2\)</span> (primeiro símbolo é ‘b’ → rejeita);</li>
<li><span class="math inline">\(\delta_1(s_1, a) = s_1\)</span> (já aceitou, continua aceitando);</li>
<li><span class="math inline">\(\delta_1(s_1, b) = s_1\)</span> (já aceitou, continua aceitando);</li>
<li><span class="math inline">\(\delta_1(s_2, a) = s_2\)</span> (já rejeitou, continua rejeitando);</li>
<li><span class="math inline">\(\delta_1(s_2, b) = s_2\)</span> (já rejeitou, continua rejeitando);</li>
</ul></li>
</ul>
<p><strong>Autômato <span class="math inline">\(M_2\)</span>: Aceita strings com número ímpar de ’b’s</strong>: um autômato que reconhece a linguagem <span class="math inline">\(L_2 = \{b, ab, aab, aba, aaab, aababb, ...\}\)</span>. Que pode ser especificado como:</p>
<ul>
<li>Estados: <span class="math inline">\(Q_2 = \{t_0, t_1\}\)</span> onde:
<ul>
<li><span class="math inline">\(t_0\)</span>: número par de ’b’s (incluindo zero);</li>
<li><span class="math inline">\(t_1\)</span>: número ímpar de ’b’s.</li>
</ul></li>
<li>Estado inicial: <span class="math inline">\(t_0\)</span>.</li>
<li>Estados finais: <span class="math inline">\(F_2 = \{t_1\}\)</span>.</li>
<li>Transições:
<ul>
<li><span class="math inline">\(\delta_2(t_0, a) = t_0\)</span> (‘a’ não afeta a contagem de ’b’s);</li>
<li><span class="math inline">\(\delta_2(t_0, b) = t_1\)</span> (de par para ímpar);</li>
<li><span class="math inline">\(\delta_2(t_1, a) = t_1\)</span> (‘a’ não afeta a contagem);</li>
<li><span class="math inline">\(\delta_2(t_1, b) = t_0\)</span> (de ímpar para par).</li>
</ul></li>
</ul>
<p>Os autômatos <span class="math inline">\(M_1\)</span> e <span class="math inline">\(M_2\)</span> podem ser vistos, representados como diagramas de transição na <a href="#fig-uniao1" class="quarto-xref">Figure&nbsp;<span>4.5</span></a>.</p>
<div id="fig-uniao1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-uniao1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/uniao.webp" class="img-fluid figure-img"></p>
<figcaption>Diagrama de transição do autômato <span class="math inline">\(M_1\)</span> e <span class="math inline">\(M_2\)</span></figcaption>
</figure>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-uniao1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.5
</figcaption>
</figure>
</div>
<p>Para construir o autômato união <span class="math inline">\(M = M_1 \cup M_2\)</span>, a esforçada leitora deve seguir os seguintes passos:</p>
<p><strong>1. Passo 1: Criar o conjunto de estados</strong>: o conjunto de estados do autômato união será dado pelo o produto cartesiano <span class="math inline">\(Q = Q_1 \times Q_2\)</span>. Enumerando todos os pares possíveis teremos:</p>
<ul>
<li><span class="math inline">\((s_0, t_0)\)</span>: <span class="math inline">\(M_1\)</span> no estado inicial e <span class="math inline">\(M_2\)</span> com número par de ’b’s;</li>
<li><span class="math inline">\((s_0, t_1)\)</span>: <span class="math inline">\(M_1\)</span> no estado inicial e <span class="math inline">\(M_2\)</span> com número ímpar de ’b’s;</li>
<li><span class="math inline">\((s_1, t_0)\)</span>: <span class="math inline">\(M_1\)</span> aceitando (começou com ‘a’) e <span class="math inline">\(M_2\)</span> com número par de ’b’s;</li>
<li><span class="math inline">\((s_1, t_1)\)</span>: <span class="math inline">\(M_1\)</span> aceitando e <span class="math inline">\(M_2\)</span> com número ímpar de ’b’s;</li>
<li><span class="math inline">\((s_2, t_0)\)</span>: <span class="math inline">\(M_1\)</span> rejeitando (começou com ‘b’) e <span class="math inline">\(M_2\)</span> com número par de ’b’s;</li>
<li><span class="math inline">\((s_2, t_1)\)</span>: <span class="math inline">\(M_1\)</span> rejeitando e <span class="math inline">\(M_2\)</span> com número ímpar de ’b’s.</li>
</ul>
<p><strong>Total</strong>: <span class="math inline">\(6\)</span> estados <span class="math inline">\((3 \times 2 = 6)\)</span>.</p>
<p><strong>2. Passo 2: Determinar o estado inicial</strong>: o estado inicial é simplesmente o par dos estados iniciais:</p>
<ul>
<li><span class="math inline">\(q_0 = (s_0, t_0)\)</span></li>
</ul>
<p><strong>3. Passo 3: Determinar os estados finais</strong>: para a união, um estado é final se <strong>pelo menos um</strong> dos autômatos originais estaria em estado final. Para determinar os estados finais, verificamos quais pares <span class="math inline">\((s_i, t_j)\)</span> satisfazem a condição de aceitação. Para cada estado perguntamos:“<span class="math inline">\(M_1\)</span> aceita OU <span class="math inline">\(M_2\)</span> aceita?”</p>
<ul>
<li><span class="math inline">\((s_0, t_0)\)</span>: <span class="math inline">\(s_0 \notin F_1\)</span> e <span class="math inline">\(t_0 \notin F_2\)</span> → NÃO é final;</li>
<li><span class="math inline">\((s_0, t_1)\)</span>: <span class="math inline">\(s_0 \notin F_1\)</span> mas <span class="math inline">\(t_1 \in F_2\)</span> → É FINAL;</li>
<li><span class="math inline">\((s_1, t_0)\)</span>: <span class="math inline">\(s_1 \in F_1\)</span> mas <span class="math inline">\(t_0 \notin F_2\)</span> → É FINAL;</li>
<li><span class="math inline">\((s_1, t_1)\)</span>: <span class="math inline">\(s_1 \in F_1\)</span> e <span class="math inline">\(t_1 \in F_2\)</span> → É FINAL;</li>
<li><span class="math inline">\((s_2, t_0)\)</span>: <span class="math inline">\(s_2 \notin F_1\)</span> e <span class="math inline">\(t_0 \notin F_2\)</span> → NÃO é final;</li>
<li><span class="math inline">\((s_2, t_1)\)</span>: <span class="math inline">\(s_2 \notin F_1\)</span> mas <span class="math inline">\(t_1 \in F_2\)</span> → É FINAL.</li>
</ul>
<p>Assim, os Estados finais são: <span class="math inline">\(F = \{(s_0, t_1), (s_1, t_0), (s_1, t_1), (s_2, t_1)\}\)</span></p>
<p><strong>4. Passo 4: Construir a função de transição</strong>: para cada estado <span class="math inline">\((s_i, t_j)\)</span> e cada símbolo <span class="math inline">\(x \in \{a, b\}\)</span>, calculamos: <span class="math display">\[\delta((s_i, t_j), x) = (\delta_1(s_i, x), \delta_2(t_j, x))\]</span></p>
<p><strong>Transições com ‘a’:</strong></p>
<ul>
<li><span class="math inline">\(\delta((s_0, t_0), a) = (\delta_1(s_0, a), \delta_2(t_0, a)) = (s_1, t_0)\)</span>;</li>
<li><span class="math inline">\(\delta((s_0, t_1), a) = (\delta_1(s_0, a), \delta_2(t_1, a)) = (s_1, t_1)\)</span>;</li>
<li><span class="math inline">\(\delta((s_1, t_0), a) = (\delta_1(s_1, a), \delta_2(t_0, a)) = (s_1, t_0)\)</span>;</li>
<li><span class="math inline">\(\delta((s_1, t_1), a) = (\delta_1(s_1, a), \delta_2(t_1, a)) = (s_1, t_1)\)</span>;</li>
<li><span class="math inline">\(\delta((s_2, t_0), a) = (\delta_1(s_2, a), \delta_2(t_0, a)) = (s_2, t_0)\)</span>;</li>
<li><span class="math inline">\(\delta((s_2, t_1), a) = (\delta_1(s_2, a), \delta_2(t_1, a)) = (s_2, t_1)\)</span>.</li>
</ul>
<p><strong>Transições com ‘b’:</strong></p>
<ul>
<li><span class="math inline">\(\delta((s_0, t_0), b) = (\delta_1(s_0, b), \delta_2(t_0, b)) = (s_2, t_1)\)</span>;</li>
<li><span class="math inline">\(\delta((s_0, t_1), b) = (\delta_1(s_0, b), \delta_2(t_1, b)) = (s_2, t_0)\)</span>;</li>
<li><span class="math inline">\(\delta((s_1, t_0), b) = (\delta_1(s_1, b), \delta_2(t_0, b)) = (s_1, t_1)\)</span>;</li>
<li><span class="math inline">\(\delta((s_1, t_1), b) = (\delta_1(s_1, b), \delta_2(t_1, b)) = (s_1, t_0)\)</span>;</li>
<li><span class="math inline">\(\delta((s_2, t_0), b) = (\delta_1(s_2, b), \delta_2(t_0, b)) = (s_2, t_1)\)</span>;</li>
<li><span class="math inline">\(\delta((s_2, t_1), b) = (\delta_1(s_2, b), \delta_2(t_1, b)) = (s_2, t_0)\)</span>.</li>
</ul>
<p><strong>5. Passo 5: Construir a Tabela de Transições da União</strong>:</p>
<table class="table">
<thead>
<tr class="header">
<th>Estado</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>→(s₀,t₀)</td>
<td>(s₁,t₀)</td>
<td>(s₂,t₁)</td>
</tr>
<tr class="even">
<td>*(s₀,t₁)</td>
<td>(s₁,t₁)</td>
<td>(s₂,t₀)</td>
</tr>
<tr class="odd">
<td>*(s₁,t₀)</td>
<td>(s₁,t₀)</td>
<td>(s₁,t₁)</td>
</tr>
<tr class="even">
<td>*(s₁,t₁)</td>
<td>(s₁,t₁)</td>
<td>(s₁,t₀)</td>
</tr>
<tr class="odd">
<td>(s₂,t₀)</td>
<td>(s₂,t₀)</td>
<td>(s₂,t₁)</td>
</tr>
<tr class="even">
<td>*(s₂,t₁)</td>
<td>(s₂,t₁)</td>
<td>(s₂,t₀)</td>
</tr>
</tbody>
</table>
<p><strong>6. Passo 6: Depuração</strong>: vamos testar algumas strings para verificar que o autômato funciona corretamente:</p>
<ol type="a">
<li><strong>String <code>ab</code></strong> (começa com ‘a’ e tem um ‘b’, número ímpar de ’b’s):</li>
</ol>
<ul>
<li><span class="math inline">\((s_0,t_0) \xrightarrow{a} (s_1,t_0) \xrightarrow{b} (s_1,t_1)\)</span> ACEITA;</li>
<li><span class="math inline">\(M_1\)</span> aceita (começa com ‘a’);</li>
<li><span class="math inline">\(M_2\)</span> aceita (um ‘b’ = ímpar);</li>
<li>União aceita.</li>
</ul>
<ol start="2" type="a">
<li><strong>String <code>b</code></strong> (não começa com ‘a’ mas tem número ímpar de ’b’s):</li>
</ol>
<ul>
<li><span class="math inline">\((s_0,t_0) \xrightarrow{b} (s_2,t_1)\)</span> ACEITA;</li>
<li><span class="math inline">\(M_1\)</span> rejeita (começa com ‘b’);</li>
<li><span class="math inline">\(M_2\)</span> aceita (um ‘b’ = ímpar);</li>
<li>União aceita (pelo menos um aceita).</li>
</ul>
<ol start="3" type="a">
<li><strong>String <code>bb</code></strong> (não começa com ‘a’ e tem número par de ’b’s):</li>
</ol>
<ul>
<li><span class="math inline">\((s_0,t_0) \xrightarrow{b} (s_2,t_1) \xrightarrow{b} (s_2,t_0)\)</span> REJEITA;</li>
<li><span class="math inline">\(M_1\)</span> rejeita (começa com ‘b’);</li>
<li><span class="math inline">\(M_2\)</span> rejeita (dois ’b’s = par);</li>
<li>União rejeita (nenhum aceita).</li>
</ul>
<ol start="4" type="a">
<li><strong>String <code>aaa</code></strong> (começa com ‘a’ mas zero ’b’s):</li>
</ol>
<ul>
<li><span class="math inline">\((s_0,t_0) \xrightarrow{a} (s_1,t_0) \xrightarrow{a} (s_1,t_0) \xrightarrow{a} (s_1,t_0)\)</span> ACEITA;</li>
<li><span class="math inline">\(M_1\)</span> aceita (começa com ‘a’);</li>
<li><span class="math inline">\(M_2\)</span> rejeita (zero ’b’s = par);</li>
<li>União aceita (pelo menos um aceita).</li>
</ul>
<p>O autômato resultante da união entre <span class="math inline">\(M_1\)</span> e <span class="math inline">\(M_2\)</span> terá estados que representam todas as combinações possíveis de estados de <span class="math inline">\(M_1\)</span> e <span class="math inline">\(M_2\)</span> e pode ser visto na <a href="#fig-uniaoresultado1" class="quarto-xref">Figure&nbsp;<span>4.6</span></a>.</p>
<div id="fig-uniaoresultado1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-uniaoresultado1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/uniaoresultado1.webp" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-uniaoresultado1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.6
</figcaption>
</figure>
</div>
<p>A atenta leitora deve notar que a construção por produto cartesiano funciona como se estivéssemos executando ambos os autômatos simultaneamente em duas <em>trilhas</em> paralelas. A cada símbolo lido:</p>
<ol type="1">
<li><strong>Atualizamos ambas as trilhas</strong>: cada componente do par de estados evolui independentemente segundo sua própria função de transição;</li>
<li><strong>Mantemos a história completa</strong>: o estado <span class="math inline">\((s_i, t_j)\)</span> nos diz exatamente onde cada autômato original estaria após processar a entrada até aquele ponto;</li>
<li><strong>Decidimos aceitação com lógica OR</strong>: Para a união, basta que uma das trilhas aceite para o autômato combinado aceitar.</li>
</ol>
<p>Este algoritmo de construção em seis passos, com um passo específico para depuração, sempre funciona, servindo como evidência de que a classe das linguagens regulares é fechada sob união.</p>
<section id="exercicios-6" class="level5" data-number="4.6.1.1.1">
<h5 data-number="4.6.1.1.1" class="anchored" data-anchor-id="exercicios-6"><span class="header-section-number">4.6.1.1.1</span> Exercícios 6</h5>
<p><strong>1.</strong> Considere dois Autômatos Finitos Determinísticos sobre <span class="math inline">\(\Sigma=\{a,b\}\)</span>: <span class="math inline">\(M_1\)</span> aceita <em>strings</em> que contêm <code>aa</code> e <span class="math inline">\(M_2\)</span> aceita <em>strings</em> de comprimento ímpar. Quantos estados terá o autômato produto <span class="math inline">\(M = M_1 \cup M_2\)</span> se <span class="math inline">\(\mid Q_1 \mid = 3\)</span> e <span class="math inline">\(\mid Q_2 \mid = 2\)</span>?</p>
<p><strong>2.</strong> No autômato união, um estado <span class="math inline">\((p, q)\)</span> é de aceitação quando <span class="math inline">\(p \in F_1\)</span> ou <span class="math inline">\(q \in F_2\)</span>. Se modificássemos a condição para <span class="math inline">\(p \in F_1\)</span> <strong>e</strong> <span class="math inline">\(q \in F_2\)</span>, que operação estaríamos realizando?</p>
<p><strong>3.</strong> Construa a tabela de transições completa para a união de: <span class="math inline">\(M_1\)</span> que aceita apenas <code>a</code> e <span class="math inline">\(M_2\)</span> que aceita apenas <code>b</code>, sobre <span class="math inline">\(\Sigma = \{a, b\}\)</span>.</p>
<p><strong>4.</strong> Considere dois autômatos sobre <span class="math inline">\(\Sigma = \{0, 1\}\)</span>: <span class="math inline">\(M_1\)</span> aceita strings que terminam em ‘01’ e <span class="math inline">\(M_2\)</span> aceita strings com número par de ’1’s. Construa a tabela de transições para o autômato união <span class="math inline">\(M_1 \cup M_2\)</span>.</p>
<p><strong>5.</strong> Dados dois autômatos binários <span class="math inline">\(M_1\)</span> e <span class="math inline">\(M_2\)</span> onde <span class="math inline">\(M_1\)</span> aceita strings que começam com ‘1’ (2 estados) e <span class="math inline">\(M_2\)</span> aceita strings de comprimento par (2 estados). Construa o passo a passo completo para determinar o autômato união <span class="math inline">\(M_1 \cup M_2\)</span> sobre <span class="math inline">\(\Sigma = \{0, 1\}\)</span>.</p>
</section>
</section>
<section id="fechamento-sob-interseção" class="level4" data-number="4.6.1.2">
<h4 data-number="4.6.1.2" class="anchored" data-anchor-id="fechamento-sob-interseção"><span class="header-section-number">4.6.1.2</span> Fechamento sob Interseção</h4>
<p><strong>Teorema (Fechamento sob Interseção)</strong>: Sejam <span class="math inline">\(M_1\)</span> e <span class="math inline">\(M_2\)</span> dois Autômatos Finitos Determinísticos que reconhecem as linguagens <span class="math inline">\(L_1\)</span> e <span class="math inline">\(L_2\)</span>, respectivamente. Então existe um Autômato Finito Determinístico <span class="math inline">\(M\)</span> que reconhece <span class="math inline">\(L_1 \cap L_2\)</span>.</p>
<p>A elegante leitora notará que a construção da interseção é notavelmente similar à da união. A diferença crucial reside apenas na definição dos estados finais: enquanto a união implementa uma lógica <strong>OU</strong>, a interseção implementa uma lógica <strong>E</strong>.</p>
<p><strong>Construção Formal</strong>: Utilizamos a mesma estrutura de produto cartesiano, mas com:</p>
<p><span class="math display">\[F = F_1 \times F_2\]</span></p>
<p>Ou seja, um estado <span class="math inline">\((q_1, q_2)\)</span> é final se, e somente se, <strong>ambos</strong> <span class="math inline">\(q_1 \in F_1\)</span> <strong>e</strong> <span class="math inline">\(q_2 \in F_2\)</span>.</p>
<p>Vamos construir um exemplo mais elaborado para solidificar o entendimento da construção de interseção. Considere os autômatos <span class="math inline">\(M_1\)</span> e <span class="math inline">\(M_2\)</span> descritos a seguir:</p>
<p><strong>Autômato <span class="math inline">\(M_1\)</span></strong>: aceita <em>strings</em> que começam com ‘a’. A linguagem formal é:</p>
<p><span class="math display">\[ L_1 = \{ w \in \{a, b\}^* \mid w = a \cdot x \text{ para algum } x \in \{a, b\}^* \} \]</span></p>
<ul>
<li><strong>Estados</strong>: <span class="math inline">\(Q_1 = \{s_0, s_1, s_2\}\)</span> onde:
<ul>
<li><span class="math inline">\(s_0\)</span>: estado inicial (ainda não leu nada)</li>
<li><span class="math inline">\(s_1\)</span>: leu ‘a’ como primeiro símbolo (aceita)</li>
<li><span class="math inline">\(s_2\)</span>: leu ‘b’ como primeiro símbolo (rejeita)</li>
</ul></li>
<li><strong>Estado inicial</strong>: <span class="math inline">\(s_0\)</span></li>
<li><strong>Estados finais</strong>: <span class="math inline">\(F_1 = \{s_1\}\)</span></li>
<li><strong>Transições</strong>:
<ul>
<li><span class="math inline">\(\delta_1(s_0, a) = s_1\)</span>, <span class="math inline">\(\delta_1(s_0, b) = s_2\)</span></li>
<li><span class="math inline">\(\delta_1(s_1, a) = s_1\)</span>, <span class="math inline">\(\delta_1(s_1, b) = s_1\)</span></li>
<li><span class="math inline">\(\delta_1(s_2, a) = s_2\)</span>, <span class="math inline">\(\delta_1(s_2, b) = s_2\)</span></li>
</ul></li>
</ul>
<p><strong>Autômato <span class="math inline">\(M_2\)</span></strong>: aceita <em>strings</em> com número par de ’b’s. A linguagem formal é:</p>
<p><span class="math display">\[ L_2 = \{ w \in \{a, b\}^* \mid \#_b(w) \equiv 0 \pmod{2} \} \]</span></p>
<p>no qual <span class="math inline">\(\#_b(w)\)</span> denota o número de ’b’s na <em>string</em> <span class="math inline">\(w\)</span>.</p>
<ul>
<li><strong>Estados</strong>: <span class="math inline">\(Q_2 = \{t_{par}, t_{ímpar}\}\)</span> onde:
<ul>
<li><span class="math inline">\(t_{par}\)</span>: número par de ’b’s (incluindo zero)</li>
<li><span class="math inline">\(t_{ímpar}\)</span>: número ímpar de ’b’s</li>
</ul></li>
<li><strong>Estado inicial</strong>: <span class="math inline">\(t_{par}\)</span></li>
<li><strong>Estados finais</strong>: <span class="math inline">\(F_2 = \{t_{par}\}\)</span></li>
<li><strong>Transições</strong>:
<ul>
<li><span class="math inline">\(\delta_2(t_{par}, a) = t_{par}\)</span>, <span class="math inline">\(\delta_2(t_{par}, b) = t_{ímpar}\)</span></li>
<li><span class="math inline">\(\delta_2(t_{ímpar}, a) = t_{ímpar}\)</span>, <span class="math inline">\(\delta_2(t_{ímpar}, b) = t_{par}\)</span></li>
</ul></li>
</ul>
<p><strong>Passo a Passo para a Construção do Autômato Interseção</strong>:</p>
<p><strong>Passo 1: Estados</strong>: <span class="math inline">\(Q = Q_1 \times Q_2 = \{(s_0, t_{par}), (s_0, t_{ímpar}), (s_1, t_{par}), (s_1, t_{ímpar}), (s_2, t_{par}), (s_2, t_{ímpar})\}\)</span></p>
<p><strong>Passo 2: Estado inicial</strong>: <span class="math inline">\(q_0 = (s_0, t_{par})\)</span></p>
<p><strong>Passo 3: Estados finais</strong>: Para a interseção, um estado é final apenas se <strong>ambos</strong> os componentes estão em estados finais: - <span class="math inline">\(F = F_1 \times F_2 = \{s_1\} \times \{t_{par}\} = \{(s_1, t_{par})\}\)</span></p>
<p><strong>Passo 4: Tabela de Transições</strong>:</p>
<table class="table">
<thead>
<tr class="header">
<th>Estado</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\rightarrow (s_0, t_{par})\)</span></td>
<td><span class="math inline">\((s_1, t_{par})\)</span></td>
<td><span class="math inline">\((s_2, t_{ímpar})\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\((s_0, t_{ímpar})\)</span></td>
<td><span class="math inline">\((s_1, t_{ímpar})\)</span></td>
<td><span class="math inline">\((s_2, t_{par})\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(*(s_1, t_{par})\)</span></td>
<td><span class="math inline">\((s_1, t_{par})\)</span></td>
<td><span class="math inline">\((s_1, t_{ímpar})\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\((s_1, t_{ímpar})\)</span></td>
<td><span class="math inline">\((s_1, t_{ímpar})\)</span></td>
<td><span class="math inline">\((s_1, t_{par})\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\((s_2, t_{par})\)</span></td>
<td><span class="math inline">\((s_2, t_{par})\)</span></td>
<td><span class="math inline">\((s_2, t_{ímpar})\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\((s_2, t_{ímpar})\)</span></td>
<td><span class="math inline">\((s_2, t_{ímpar})\)</span></td>
<td><span class="math inline">\((s_2, t_{par})\)</span></td>
</tr>
</tbody>
</table>
<p><strong>Passo 5: Verificação</strong>: Vamos testar algumas <em>strings</em>:</p>
<p><strong>String “aa”</strong> (começa com ‘a’ e tem zero ‘b’s - par): - <span class="math inline">\((s_0, t_{par}) \xrightarrow{a} (s_1, t_{par}) \xrightarrow{a} (s_1, t_{par})\)</span> <strong>ACEITA</strong>; - <span class="math inline">\(M_1\)</span> aceita (começa com ’a’); - <span class="math inline">\(M_2\)</span> aceita (zero ’b’s = par); - Interseção aceita (ambos aceitam).</p>
<p><strong>String “ab”</strong> (começa com ‘a’ mas tem um ‘b’ - ímpar): - <span class="math inline">\((s_0, t_{par}) \xrightarrow{a} (s_1, t_{par}) \xrightarrow{b} (s_1, t_{ímpar})\)</span> <strong>REJEITA</strong>; - <span class="math inline">\(M_1\)</span> aceita (começa com ‘a’); - <span class="math inline">\(M_2\)</span> rejeita (um ‘b’ = ímpar); - Interseção rejeita (nem todos aceitam).</p>
<p><strong>String “abb”</strong> (começa com ‘a’ e tem dois ’b’s - par): - <span class="math inline">\((s_0, t_{par}) \xrightarrow{a} (s_1, t_{par}) \xrightarrow{b} (s_1, t_{ímpar}) \xrightarrow{b} (s_1, t_{par})\)</span> <strong>ACEITA</strong></p>
<p>O autômato da interseção aceita apenas <em>strings</em> que <strong>começam com ‘a’ E têm número par de ’b’s</strong>.</p>
<section id="exercicios-7" class="level5" data-number="4.6.1.2.1">
<h5 data-number="4.6.1.2.1" class="anchored" data-anchor-id="exercicios-7"><span class="header-section-number">4.6.1.2.1</span> Exercícios 7</h5>
<p><strong>1.</strong> Considere dois autômatos sobre <span class="math inline">\(\Sigma = \{0, 1\}\)</span>: - <span class="math inline">\(M_1\)</span> aceita strings que terminam em ‘10’ - <span class="math inline">\(M_2\)</span> aceita strings com número ímpar de ’0’s</p>
<p>Construa o conjunto de estados finais para <span class="math inline">\(M_1 \cap M_2\)</span> e determine a linguagem aceita pela interseção.</p>
<p><strong>2.</strong> É possível que <span class="math inline">\(L(M_1 \cup M_2) = L(M_1 \cap M_2)\)</span>? Em que condição isso ocorreria?</p>
<p><strong>3.</strong> Se <span class="math inline">\(F_1 = Q_1\)</span> (todos os estados de <span class="math inline">\(M_1\)</span> são finais), o que podemos afirmar sobre <span class="math inline">\(L(M_1 \cap M_2)\)</span> em relação a <span class="math inline">\(L(M_2)\)</span>?</p>
<p><strong>4.</strong> Considere <span class="math inline">\(M_1\)</span> que aceita strings terminadas em ‘ab’ e <span class="math inline">\(M_2\)</span> que aceita strings com número par de ’a’s. Construa o autômato interseção <span class="math inline">\(M_1 \cap M_2\)</span> e determine sua linguagem.</p>
<p><strong>5.</strong> Dados três autômatos <span class="math inline">\(M_1\)</span>, <span class="math inline">\(M_2\)</span> e <span class="math inline">\(M_3\)</span>, tal que:</p>
<ul>
<li><span class="math inline">\(M_1\)</span> aceita strings que começam com ‘a’ (3 estados)</li>
<li><span class="math inline">\(M_2\)</span> aceita strings de comprimento múltiplo de 3 (3 estados)<br>
</li>
<li><span class="math inline">\(M_3\)</span> aceita strings que contêm ‘bb’ (3 estados)</li>
</ul>
<p>Determine quantos estados teria <span class="math inline">\((M_1 \cup M_2) \cap M_3\)</span> e construa o passo a passo completo desta operação composta.</p>
</section>
</section>
<section id="fechamento-sob-complemento" class="level4" data-number="4.6.1.3">
<h4 data-number="4.6.1.3" class="anchored" data-anchor-id="fechamento-sob-complemento"><span class="header-section-number">4.6.1.3</span> Fechamento sob Complemento</h4>
<p><strong>Teorema (Fechamento sob Complemento)</strong>: Seja <span class="math inline">\(M\)</span> um Autômato Finito Determinístico que reconhece a linguagem <span class="math inline">\(L\)</span>. Então existe um Autômato Finito Determinístico <span class="math inline">\(M'\)</span> que reconhece <span class="math inline">\(\overline{L} = \Sigma^* - L\)</span>.</p>
<p>A construção do complemento é surpreendentemente elegante em sua simplicidade. Para a atenta leitora que acompanhou as construções anteriores, esta parecerá quase trivial: simplesmente invertemos quais estados são finais.</p>
<p><strong>Construção Formal</strong>: Dado <span class="math inline">\(M = (Q, \Sigma, \delta, q_0, F)\)</span>, construímos:</p>
<p><span class="math display">\[M' = (Q, \Sigma, \delta, q_0, Q - F)\]</span></p>
<p><strong>Condição Crítica</strong>: Esta construção requer que o autômato seja <strong>completo</strong>. Se não for, devemos primeiro adicionar um estado de erro <span class="math inline">\(q_{\text{erro}}\)</span> com:</p>
<p><span class="math display">\[\forall a \in \Sigma: \delta(q_{\text{erro}}, a) = q_{\text{erro}}\]</span></p>
<p><strong>Exemplo Ilustrativo</strong>: Complemento de “strings com número par de ’a’s”</p>
<p>Autômato original <span class="math inline">\(M\)</span>:</p>
<div id="tbl-complemento-original" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-complemento-original-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.6: Autômato que aceita número par de ’a’s
</figcaption>
<div aria-describedby="tbl-complemento-original-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<colgroup>
<col style="width: 57%">
<col style="width: 21%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th>Estado</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\rightarrow *q_{\text{par}}\)</span></td>
<td><span class="math inline">\(q_{\text{ímpar}}\)</span></td>
<td><span class="math inline">\(q_{\text{par}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(q_{\text{ímpar}}\)</span></td>
<td><span class="math inline">\(q_{\text{par}}\)</span></td>
<td><span class="math inline">\(q_{\text{ímpar}}\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Autômato complemento <span class="math inline">\(\overline{M}\)</span>:</p>
<div id="tbl-complemento-resultado" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-complemento-resultado-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4.7: Autômato que aceita número ímpar de ’a’s
</figcaption>
<div aria-describedby="tbl-complemento-resultado-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table">
<thead>
<tr class="header">
<th>Estado</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\rightarrow q_{\text{par}}\)</span></td>
<td><span class="math inline">\(q_{\text{ímpar}}\)</span></td>
<td><span class="math inline">\(q_{\text{par}}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(*q_{\text{ímpar}}\)</span></td>
<td><span class="math inline">\(q_{\text{par}}\)</span></td>
<td><span class="math inline">\(q_{\text{ímpar}}\)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>A perspicaz leitora observará que apenas trocamos os estados finais: <span class="math inline">\(F' = \{q_{\text{ímpar}}\}\)</span>.</p>
<p><strong>Propriedades Algébricas</strong>: O fechamento sob complemento, combinado com união e interseção, estabelece que as linguagens regulares formam uma <strong>álgebra booleana</strong>:</p>
<ol type="1">
<li><strong>Leis de De Morgan</strong>: <span class="math inline">\(\overline{L_1 \cup L_2} = \overline{L_1} \cap \overline{L_2}\)</span></li>
<li><strong>Dupla Negação</strong>: <span class="math inline">\(\overline{\overline{L}} = L\)</span></li>
<li><strong>Diferença</strong>: <span class="math inline">\(L_1 - L_2 = L_1 \cap \overline{L_2}\)</span></li>
</ol>
<section id="Exercicios-8" class="level5" data-number="4.6.1.3.1">
<h5 data-number="4.6.1.3.1" class="anchored" data-anchor-id="Exercicios-8"><span class="header-section-number">4.6.1.3.1</span> Exercícios 8</h5>
<p><strong>1.</strong> Considere o Autômato Finito Determinístico <span class="math inline">\(M\)</span> com <span class="math inline">\(Q = \{q_0, q_1\}\)</span>, <span class="math inline">\(F = \{q_0\}\)</span>, <span class="math inline">\(\delta(q_0, a) = q_1\)</span>, <span class="math inline">\(\delta(q_0, b) = q_0\)</span>, <span class="math inline">\(\delta(q_1, a) = q_0\)</span>, <span class="math inline">\(\delta(q_1, b) = q_1\)</span>. Construa a tabela de transições de <span class="math inline">\(\overline{M}\)</span>.</p>
<p><strong>2.</strong> Por que a completude é essencial para a construção do complemento? Dê um exemplo no qual a construção falharia sem completude.</p>
<p><strong>3.</strong> Prove usando as propriedades de fechamento que se <span class="math inline">\(L_1\)</span> e <span class="math inline">\(L_2\)</span> são regulares, então <span class="math inline">\(L_1 - L_2\)</span> também é regular.</p>
<p><strong>4.</strong> Se <span class="math inline">\(L\)</span> é regular e <span class="math inline">\(\overline{L} = \emptyset\)</span>, o que podemos concluir sobre <span class="math inline">\(L\)</span>?</p>
<p><strong>5.</strong> Usando as leis de De Morgan, expresse <span class="math inline">\(\overline{L_1 \cap L_2 \cap L_3}\)</span> em termos de uniões e complementos individuais.</p>
</section>
</section>
</section>
<section id="implicações-práticas-das-propriedades-de-fechamento" class="level3" data-number="4.6.2">
<h3 data-number="4.6.2" class="anchored" data-anchor-id="implicações-práticas-das-propriedades-de-fechamento"><span class="header-section-number">4.6.2</span> Implicações Práticas das Propriedades de Fechamento</h3>
<p>As propriedades de fechamento que a dedicada leitora acaba de estudar não são meras curiosidades matemáticas. Elas fundamentam técnicas essenciais na construção de compiladores e processadores de texto:</p>
<ol type="1">
<li><p><strong>Composição Modular</strong>: Permite construir reconhecedores complexos a partir de componentes simples e bem testados.</p></li>
<li><p><strong>Otimização de Consultas</strong>: Em sistemas de busca, a interseção permite refinar resultados, enquanto a união expande o escopo.</p></li>
<li><p><strong>Análise Léxica Incremental</strong>: Novos padrões podem ser adicionados a um analisador existente através de união, sem reconstruir todo o autômato.</p></li>
<li><p><strong>Verificação de Propriedades</strong>: Para verificar se dois autômatos são equivalentes, basta testar se <span class="math inline">\((L_1 - L_2) \cup (L_2 - L_1) = \emptyset\)</span>.</p></li>
</ol>
<p>A compreensão profunda destas propriedades capacita a engenheira a fazer escolhas arquiteturais informadas, sabendo que a modularidade não compromete a eficiência ou a correção do sistema final.### Minimização de Estados</p>
<p>Um dos resultados mais importantes e práticos da teoria dos Autômatos Finitos Determinísticos é que toda linguagem regular possui um <strong>único Autômato Finito Determinístico mínimo</strong> (a menos de renomeação de estados). Este resultado não apenas tem valor teórico, mas permite otimizações significativas em implementações práticas.</p>
<section id="o-conceito-de-estados-equivalentes" class="level4" data-number="4.6.2.1">
<h4 data-number="4.6.2.1" class="anchored" data-anchor-id="o-conceito-de-estados-equivalentes"><span class="header-section-number">4.6.2.1</span> O Conceito de Estados Equivalentes</h4>
<p>Dois estados <span class="math inline">\(p\)</span> e <span class="math inline">\(q\)</span> são <strong>equivalentes</strong> (denotado <span class="math inline">\(p \equiv q\)</span>) se, para toda <em>string</em> <span class="math inline">\(w \in \Sigma^*\)</span>:</p>
<p><span class="math display">\[\delta^*(p, w) \in F \iff \delta^*(q, w) \in F\]</span></p>
<p>Intuitivamente, dois estados são equivalentes se, a partir deles, o autômato aceita exatamente as mesmas continuações. Esta relação de equivalência particiona o conjunto de estados em classes de equivalência.</p>
</section>
<section id="o-algoritmo-de-minimização-por-refinamento-de-partições" class="level4" data-number="4.6.2.2">
<h4 data-number="4.6.2.2" class="anchored" data-anchor-id="o-algoritmo-de-minimização-por-refinamento-de-partições"><span class="header-section-number">4.6.2.2</span> O Algoritmo de Minimização por Refinamento de Partições</h4>
<p>O algoritmo clássico para minimização de Autômatos Finitos Determinísticos opera refinando iterativamente uma partição dos estados até alcançar o ponto fixo:</p>
<p><strong>Algoritmo de Minimização</strong>:</p>
<pre class="pseudocode"><code>1. Inicialização: Particione Q em dois conjuntos:
   - P₀ = F (estados de aceitação)
   - P₁ = Q - F (estados de não-aceitação)

2. Refinamento: Enquanto a partição mudar:
   Para cada classe de equivalência P na partição atual:
     Para cada símbolo a ∈ Σ:
       Divida P baseado em δ(q, a) para q ∈ P
       
3. Construção: Cada classe de equivalência torna-se
   um estado do Autômato Finito Determinístico mínimo</code></pre>
<p><strong>Exemplo de Minimização</strong>: Considere um Autômato Finito Determinístico com estados redundantes que reconhece <span class="math inline">\((a|b)*abb\)</span>:</p>
<p>Estados originais: <span class="math inline">\(\{q_0, q_1, q_2, q_3, q_4, q_5\}\)</span> nos quais alguns estados são equivalentes.</p>
<p>Após aplicar o algoritmo: 1. Partição inicial: <span class="math inline">\(\{\{q_3\}, \{q_0, q_1, q_2, q_4, q_5\}\}\)</span> 2. Após refinamentos: <span class="math inline">\(\{\{q_3\}, \{q_2\}, \{q_1, q_4\}, \{q_0, q_5\}\}\)</span> 3. Autômato Finito Determinístico mínimo tem apenas 4 estados ao invés de 6</p>
</section>
</section>
<section id="Exercicios-9" class="level3" data-number="4.6.3">
<h3 data-number="4.6.3" class="anchored" data-anchor-id="Exercicios-9"><span class="header-section-number">4.6.3</span> Exercícios 9</h3>
<p><strong>1.</strong> Considere o alfabeto <span class="math inline">\(\Sigma = \{0, 1, +, -, *, /, (, )\}\)</span> representando tokens simplificados de expressões aritméticas binárias. Sejam os autômatos:</p>
<ul>
<li><span class="math inline">\(M_1\)</span>: aceita strings que começam com ‘(’ e terminam com ‘)’;</li>
<li><span class="math inline">\(M_2\)</span>: aceita strings que contêm pelo menos um operador aritmético (+, -, * ou /);</li>
<li><span class="math inline">\(M_3\)</span>: aceita strings de comprimento par.</li>
</ul>
<p>Construa o autômato que reconhece <span class="math inline">\((M_1 \cap M_2) \cup \overline{M_3}\)</span> e determine três strings aceitas e três rejeitadas.</p>
<p><strong>2.</strong> Sobre o alfabeto <span class="math inline">\(\Sigma = \{a, b, \_, 0, 1\}\)</span> representando caracteres válidos em identificadores, considere:</p>
<ul>
<li><span class="math inline">\(M_{id}\)</span>: aceita strings que começam com letra (a ou b) ou underscore, seguidos de qualquer combinação de letras, underscore ou dígitos;</li>
<li><span class="math inline">\(M_{kw}\)</span>: aceita exatamente as strings {“a”, “ab”, “b0”, “b1”} (palavras-chave).</li>
</ul>
<p>Construa o autômato <span class="math inline">\(M_{id} - M_{kw} = M_{id} \cap \overline{M_{kw}}\)</span> que aceita identificadores válidos que não são palavras-chave. Quantos estados tem o autômato mínimo resultante?</p>
<p><strong>3.</strong> Considere <span class="math inline">\(\Sigma = \{/, *, ", \text{outro}\}\)</span> onde ‘outro’ representa qualquer caractere diferente dos anteriores. Sejam:</p>
<ul>
<li><span class="math inline">\(M_{comment}\)</span>: aceita strings da forma /* … */ (comentários de bloco);</li>
<li><span class="math inline">\(M_{string}\)</span>: aceita strings da forma ” … ” (strings literais);</li>
<li><span class="math inline">\(M_{nested}\)</span>: aceita strings que contêm pelo menos um ’/*’ dentro de aspas.</li>
</ul>
<p>Prove que <span class="math inline">\(L(M_{comment}) \cap L(M_{string}) = \emptyset\)</span> e construa <span class="math inline">\(M = (M_{comment} \cup M_{string}) \cap \overline{M_{nested}}\)</span>.</p>
<p><strong>4.</strong> Sobre <span class="math inline">\(\Sigma = \{0, 1, \&amp;, |, !, (, )\}\)</span> representando expressões booleanas:</p>
<ul>
<li><span class="math inline">\(M_{balanced}\)</span>: aceita strings com parênteses balanceados (mesmo número de ‘(’ e ‘)’);</li>
<li><span class="math inline">\(M_{op}\)</span>: aceita strings onde todo operador binário (&amp;, |) é precedido e seguido por 0, 1, ou );</li>
<li><span class="math inline">\(M_{not}\)</span>: aceita strings onde todo ‘!’ é seguido por <code>0</code>, <code>1</code>, ou <code>(</code>.</li>
</ul>
<p>Construa passo a passo o autômato <span class="math inline">\((M_{balanced} \cap M_{op} \cap M_{not}) \cup \overline{(M_{op} \cup M_{not})}\)</span>. Esta construção resulta em um autômato que aceita que tipo de strings?</p>
<p><strong>5.</strong> Dados três autômatos sobre <span class="math inline">\(\Sigma = \{&lt;, &gt;, =, !, 0, 1\}\)</span>:</p>
<ul>
<li><span class="math inline">\(M_1\)</span> com 4 estados, reconhece operadores relacionais válidos (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>);</li>
<li><span class="math inline">\(M_2\)</span> com 3 estados, reconhece strings que começam com operador;</li>
<li><span class="math inline">\(M_3\)</span> com 2 estados, reconhece strings de comprimento ímpar.</li>
</ul>
<ol type="a">
<li><p>Determine o número máximo de estados do autômato <span class="math inline">\((M_1 \cup M_2) \cap \overline{M_3}\)</span> antes da minimização.</p></li>
<li><p>Se <span class="math inline">\(L(M_1) \subseteq L(M_2)\)</span>, simplifique a expressão <span class="math inline">\((M_1 \cap M_2) \cup (\overline{M_1} \cap M_3)\)</span> e justifique algebricamente.</p></li>
<li><p>Prove que <span class="math inline">\(\overline{M_1 \cup M_2 \cup M_3} = \overline{M_1} \cap \overline{M_2} \cap \overline{M_3}\)</span> usando as leis de De Morgan e construa o autômato resultante.</p></li>
</ol>
</section>
<section id="sec-myhill-nerode" class="level3" data-number="4.6.4">
<h3 data-number="4.6.4" class="anchored" data-anchor-id="sec-myhill-nerode"><span class="header-section-number">4.6.4</span> A Relação de Myhill-Nerode</h3>
<p>A relação de Myhill-Nerode fornece uma caracterização fundamental das linguagens regulares e estabelece uma conexão profunda entre a estrutura algébrica de uma linguagem e o autômato mínimo que a reconhece.</p>
<section id="definição-da-relação" class="level4" data-number="4.6.4.1">
<h4 data-number="4.6.4.1" class="anchored" data-anchor-id="definição-da-relação"><span class="header-section-number">4.6.4.1</span> Definição da Relação</h4>
<p>Dada uma linguagem <span class="math inline">\(L \subseteq \Sigma^*\)</span>, definimos a relação de equivalência de Myhill-Nerode sobre <span class="math inline">\(\Sigma^*\)</span>:</p>
<p><span class="math display">\[x \equiv_L y \iff \forall z \in \Sigma^* : xz \in L \leftrightarrow yz \in L\]</span></p>
<p>Duas <em>strings</em> <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span> são equivalentes se elas são <strong>indistinguíveis</strong> com respeito a <span class="math inline">\(L\)</span>: qualquer sufixo <span class="math inline">\(z\)</span> que, concatenado com <span class="math inline">\(x\)</span>, produza uma <em>string</em> em <span class="math inline">\(L\)</span>, também produzirá uma <em>string</em> em <span class="math inline">\(L\)</span> quando concatenado com <span class="math inline">\(y\)</span>, e vice-versa.</p>
</section>
<section id="o-teorema-de-myhill-nerode" class="level4" data-number="4.6.4.2">
<h4 data-number="4.6.4.2" class="anchored" data-anchor-id="o-teorema-de-myhill-nerode"><span class="header-section-number">4.6.4.2</span> O Teorema de Myhill-Nerode</h4>
<p><strong>Teorema (Myhill-Nerode)</strong>: Uma linguagem <span class="math inline">\(L\)</span> é regular se, e somente se, a relação <span class="math inline">\(\equiv_L\)</span> tem um número finito de classes de equivalência. Além disso, o número de estados do Autômato Finito Determinístico mínimo para <span class="math inline">\(L\)</span> é exatamente igual ao número de classes de equivalência de <span class="math inline">\(\equiv_L\)</span>.</p>
<p>Este teorema tem implicações profundas:</p>
<ol type="1">
<li><p><strong>Caracterização Algébrica</strong>: Fornece uma condição necessária e suficiente para regularidade sem mencionar autômatos ou expressões regulares.</p></li>
<li><p><strong>Limite Inferior</strong>: Estabelece o número mínimo de estados necessários para reconhecer uma linguagem.</p></li>
<li><p><strong>Técnica de Prova</strong>: Oferece um método alternativo para provar que uma linguagem não é regular.</p></li>
</ol>
<p><strong>Exemplo de Aplicação</strong>: Para a linguagem <span class="math inline">\(L = \{a^nb^n | n \geq 0\}\)</span>:</p>
<p>As <em>strings</em> <span class="math inline">\(\epsilon, a, aa, aaa, ...\)</span> estão todas em classes de equivalência distintas porque: - <span class="math inline">\(a^i \cdot b^i \in L\)</span> mas <span class="math inline">\(a^j \cdot b^i \notin L\)</span> para <span class="math inline">\(i \neq j\)</span></p>
<p>Como existem infinitas classes de equivalência, <span class="math inline">\(L\)</span> não é regular. Esta é uma prova alternativa ao Lema do Bombeamento!</p>
</section>
</section>
<section id="equivalência-entre-modelos" class="level3" data-number="4.6.5">
<h3 data-number="4.6.5" class="anchored" data-anchor-id="equivalência-entre-modelos"><span class="header-section-number">4.6.5</span> Equivalência entre Modelos</h3>
<p>Um dos resultados fundamentais da teoria das linguagens formais é o <strong>Teorema de Kleene</strong>, que estabelece a equivalência entre três formalismos aparentemente distintos.</p>
<section id="o-teorema-de-kleene" class="level4" data-number="4.6.5.1">
<h4 data-number="4.6.5.1" class="anchored" data-anchor-id="o-teorema-de-kleene"><span class="header-section-number">4.6.5.1</span> O Teorema de Kleene</h4>
<p><strong>Teorema (Kleene)</strong>: As seguintes classes de linguagens são idênticas: 1. Linguagens reconhecidas por Autômatos Finitos Determinísticos 2. Linguagens reconhecidas por Autômatos Finitos Não-Determinísticos 3. Linguagens denotadas por Expressões Regulares</p>
<p>A demonstração deste teorema envolve três construções algorítmicas:</p>
<p><strong>1. Expressão Regular → Autômato Finito Determinístico (Construção de Thompson)</strong>: Para cada operador da expressão regular, existe uma construção sistemática: - Base: <span class="math inline">\(a \in \Sigma\)</span> produz um Autômato Finito Determinístico de dois estados; - União: <span class="math inline">\(r|s\)</span> combina Autômatos Finitos Determinísticos com transições-<span class="math inline">\(\epsilon\)</span>; - Concatenação: <span class="math inline">\(rs\)</span> conecta Autômatos Finitos Determinísticos em sequência; - Fechamento: <span class="math inline">\(r^*\)</span> adiciona ciclo com transições-<span class="math inline">\(\epsilon\)</span>.</p>
<p><strong>2. Autômato Finito Determinístico (Construção de Subconjuntos)</strong>: O algoritmo de subconjuntos constrói um Autômato Finito Determinístico no qual cada estado representa um conjunto de estados do Autômato Finito Determinístico original. Embora potencialmente exponencial, garante determinismo.</p>
<p><strong>3. Autômato Finito Determinístico → Expressão Regular (Eliminação de Estados)</strong>: Remove sistematicamente estados do Autômato Finito Determinístico, substituindo-os por expressões regulares nas transições, até restar apenas uma expressão entre o estado inicial e os finais.</p>
</section>
</section>
<section id="teste-de-equivalência-entre-autômatos-finitos-determinísticos" class="level3" data-number="4.6.6">
<h3 data-number="4.6.6" class="anchored" data-anchor-id="teste-de-equivalência-entre-autômatos-finitos-determinísticos"><span class="header-section-number">4.6.6</span> Teste de Equivalência entre Autômatos Finitos Determinísticos</h3>
<p>Determinar se dois Autômatos Finitos Determinísticos reconhecem a mesma linguagem é um problema fundamental com aplicações práticas importantes, especialmente na otimização de compiladores.</p>
<section id="algoritmo-de-teste-de-equivalência" class="level4" data-number="4.6.6.1">
<h4 data-number="4.6.6.1" class="anchored" data-anchor-id="algoritmo-de-teste-de-equivalência"><span class="header-section-number">4.6.6.1</span> Algoritmo de Teste de Equivalência</h4>
<p><strong>Método 1: Via Minimização</strong>: 1. Minimize ambos os Autômatos Finitos Determinísticos 2. Verifique isomorfismo entre os Autômatos Finitos Determinísticos mínimos</p>
<p><strong>Método 2: Via Construção do Produto</strong>: 1. Construa Autômato Finito Determinístico para <span class="math inline">\((L_1 - L_2) \cup (L_2 - L_1)\)</span> 2. Verifique se a linguagem resultante é vazia</p>
<p><strong>Complexidade</strong>: a complexidade do teste de equivalência entre dois Autômatos Finitos Determinísticos (<span class="math inline">\(M_1\)</span> e <span class="math inline">\(M_2\)</span>) depende do método utilizado.</p>
<ol type="a">
<li><p>O método via <strong>minimização</strong> tem sua complexidade dominada pelo algoritmo de minimização. Utilizando o algoritmo de <a href="https://en.wikipedia.org/wiki/John_Hopcroft">Hopcroft</a>, a complexidade é de <span class="math inline">\(O(k \cdot n \log n)\)</span>, na qual <span class="math inline">\(n\)</span> é o número de estados e <span class="math inline">\(k\)</span> é o tamanho do alfabeto. Se o alfabeto é tratado como uma constante, a complexidade é frequentemente citada como <span class="math inline">\(O(n \log n)\)</span>.</p></li>
<li><p>O método via <strong>construção do produto</strong>, que verifica se a linguagem <span class="math inline">\((L_1 \setminus L_2) \cup (L_2 \setminus L_1)\)</span> é vazia, possui uma complexidade de <span class="math inline">\(O(n_1 \cdot n_2)\)</span>, na qual <span class="math inline">\(n_1\)</span> é o número de estados de <span class="math inline">\(M_1\)</span> e <span class="math inline">\(n_2\)</span> é o número de estados de <span class="math inline">\(M_2\)</span>.</p></li>
</ol>
</section>
</section>
<section id="implicações-práticas-das-propriedades" class="level3" data-number="4.6.7">
<h3 data-number="4.6.7" class="anchored" data-anchor-id="implicações-práticas-das-propriedades"><span class="header-section-number">4.6.7</span> Implicações Práticas das Propriedades</h3>
<p>A diligente leitora observará que estas propriedades matemáticas têm consequências diretas na engenharia de compiladores:</p>
<ol type="1">
<li><p><strong>Composição Modular</strong>: As propriedades de fechamento permitem construir analisadores léxicos complexos a partir de componentes simples, sabendo que o resultado permanecerá tratável.</p></li>
<li><p><strong>Otimização Garantida</strong>: A minimização garante o menor autômato possível, otimizando tanto memória quanto tempo de execução.</p></li>
<li><p><strong>Verificação Formal</strong>: O teste de equivalência permite verificar se otimizações preservam a semântica.</p></li>
<li><p><strong>Geração Automática</strong>: A equivalência entre formalismos permite escolher a representação mais conveniente para cada fase do desenvolvimento.</p></li>
</ol>
<p>Estas propriedades fundamentais estabelecem os Autômatos Finitos Determinísticos não apenas como um modelo teórico elegante, mas como uma ferramenta prática poderosa para o processamento eficiente de linguagens. A compreensão profunda destas propriedades capacita a engenheira de software a fazer escolhas informadas sobre representações, otimizações e implementações em sistemas reais de análise léxica.</p>
</section>
<section id="Exercicios-10" class="level3" data-number="4.6.8">
<h3 data-number="4.6.8" class="anchored" data-anchor-id="Exercicios-10"><span class="header-section-number">4.6.8</span> Exercícios 10</h3>
<p><strong>1.</strong>: Considere a linguagem <span class="math inline">\(L = \{w \in \{0,1\}^* \mid w \text{ contém } 00 \text{ como substring}\}\)</span>.</p>
<ol type="a">
<li><p>Determine todas as classes de equivalência da relação <span class="math inline">\(\equiv_L\)</span>.</p></li>
<li><p>Para cada classe, forneça um representante e explique por que strings dessa classe são equivalentes.</p></li>
<li><p>Construa o Autômato Finito Determinístico mínimo para <span class="math inline">\(L\)</span> usando as classes de equivalência encontradas.</p></li>
<li><p>Verifique que o número de estados do Autômato Finito Determinístico mínimo corresponde ao número de classes.</p></li>
</ol>
<p><strong>2.</strong>: Use a relação de Myhill-Nerode para provar que a linguagem <span class="math inline">\(L = \{0^i1^j \mid i &gt; j \geq 0\}\)</span> não é regular.</p>
<p>Dica: Considere as strings <span class="math inline">\(0^n\)</span> para diferentes valores de <span class="math inline">\(n\)</span> e mostre que estão em classes distintas.</p>
<p><strong>3.</strong>:Considere o Autômato Finito Determinístico <span class="math inline">\(M = (\{q_0, q_1, q_2\}, \{a, b\}, \delta, q_0, \{q_2\})\)</span> com transições:</p>
<ul>
<li><span class="math inline">\(\delta(q_0, a) = q_1\)</span>, <span class="math inline">\(\delta(q_0, b) = q_0\)</span>;</li>
<li><span class="math inline">\(\delta(q_1, a) = q_1\)</span>, <span class="math inline">\(\delta(q_1, b) = q_2\)</span>;</li>
<li><span class="math inline">\(\delta(q_2, a) = q_2\)</span>, <span class="math inline">\(\delta(q_2, b) = q_2\)</span>.</li>
</ul>
<p>Use o método de eliminação de estados para encontrar a expressão regular equivalente. Mostre cada passo da eliminação.</p>
<p><strong>4.</strong>: Dados dois Autômatos Finitos Determinísticos sobre <span class="math inline">\(\Sigma = \{a, b\}\)</span>:</p>
<p><strong>Autômato Finito Determinístico <span class="math inline">\(M_1\)</span>:</strong> Aceita strings com número par de <span class="math inline">\(a\)</span>’s - Estados: <span class="math inline">\(\{p_0, p_1\}\)</span> - Estado inicial: <span class="math inline">\(p_0\)</span> - Estados finais: <span class="math inline">\(\{p_0\}\)</span> - <span class="math inline">\(\delta_1(p_0, a) = p_1\)</span>, <span class="math inline">\(\delta_1(p_0, b) = p_0\)</span> - <span class="math inline">\(\delta_1(p_1, a) = p_0\)</span>, <span class="math inline">\(\delta_1(p_1, b) = p_1\)</span></p>
<p><strong>Autômato Finito Determinístico <span class="math inline">\(M_2\)</span>:</strong> Aceita strings onde a posição de cada <span class="math inline">\(a\)</span> é ímpar (primeira posição = 1) - Estados: <span class="math inline">\(\{q_{par}, q_{impar}, q_{aceita}, q_{rejeita}\}\)</span> - Estado inicial: <span class="math inline">\(q_{par}\)</span> - Estados finais: <span class="math inline">\(\{q_{par}, q_{aceita}\}\)</span></p>
<ol type="a">
<li><p>Determine se <span class="math inline">\(L(M_1) = L(M_2)\)</span> usando o método do produto.</p></li>
<li><p>Verifique sua resposta testando as strings: <span class="math inline">\(\epsilon\)</span>, <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(aa\)</span>, <span class="math inline">\(ab\)</span>, <span class="math inline">\(ba\)</span>, <span class="math inline">\(aba\)</span>.</p></li>
</ol>
<p><strong>5.</strong> Considere um Autômato Finito Determinístico <span class="math inline">\(M\)</span> com 8 estados que reconhece strings sobre <span class="math inline">\(\{0, 1\}\)</span> terminadas em <span class="math inline">\(01\)</span>.</p>
<ol type="a">
<li><p>Aplique o algoritmo de minimização de Hopcroft para encontrar o Autômato Finito Determinístico mínimo.</p></li>
<li><p>Calcule a complexidade temporal da minimização considerando <span class="math inline">\(|\Sigma| = 2\)</span> e <span class="math inline">\(n = 8\)</span>.</p></li>
<li><p>Se tivéssemos dois Autômatos Finitos Determinísticos com 8 e 10 estados respectivamente, compare a complexidade de testar equivalência via minimização versus via construção do produto.</p></li>
</ol>
<p><strong>6.</strong> Você está projetando um analisador léxico que deve reconhecer três tipos de tokens:</p>
<ul>
<li><strong>Inteiros</strong>: sequências de dígitos (0-9);</li>
<li><strong>Identificadores</strong>: começam com letra, seguidos de letras ou dígitos;</li>
<li><strong>Operadores</strong>: <code>++</code>, <code>--</code>, <code>+=</code>, <code>-=</code>.</li>
</ul>
<ol type="a">
<li><p>Construa Autômatos Finitos Determinísticos individuais para cada tipo.</p></li>
<li><p>Use as propriedades de fechamento para criar um único Autômato Finito Determinístico que reconheça qualquer um dos três tipos.</p></li>
<li><p>Discuta como você implementaria a distinção entre os tipos de tokens no Autômato Finito Determinístico combinado.</p></li>
</ol>
</section>
<section id="limitações-dos-autômatos-finitos" class="level3" data-number="4.6.9">
<h3 data-number="4.6.9" class="anchored" data-anchor-id="limitações-dos-autômatos-finitos"><span class="header-section-number">4.6.9</span> Limitações dos Autômatos Finitos</h3>
<p>Apesar de sua grande aplicabilidade na análise léxica e no reconhecimento de padrões, os Autômatos Finitos Determinísticos possuem uma limitação fundamental que reside na própria natureza de sua memória: ela é <strong>finita</strong>. Um Autômato Finito Determinístico só consegue se <em>lembrar</em> de informações através do estado em que se encontra. Como o conjunto de estados <span class="math inline">\(Q\)</span> é finito, a capacidade de memorização da máquina é limitada.</p>
<p>Esta limitação impede que os Autômatos Finitos Determinísticos reconheçam linguagens que exigem uma memória ilimitada ou a capacidade de contar sem um teto predefinido. O exemplo mais clássico de uma linguagem que um Autômato Finito Determinístico não pode reconhecer é a linguagem de parênteses balanceados ou, de forma análoga, a linguagem <span class="math inline">\(L\)</span>:</p>
<p><span class="math display">\[
L = \{0^n1^n \mid n \ge 0\}
\]</span></p>
<p>Esta linguagem consiste em qualquer número <span class="math inline">\(n\)</span> de símbolos ‘0’, seguido pela <strong>mesma quantidade</strong> <span class="math inline">\(n\)</span> de símbolos ‘1’. Alguns exemplos de <em>strings</em> em <span class="math inline">\(L\)</span> são <span class="math inline">\(\epsilon\)</span> (a <em>string</em> vazia, com <span class="math inline">\(n=0\)</span>), <span class="math inline">\(01\)</span>, <span class="math inline">\(0011\)</span>, <span class="math inline">\(000111\)</span>, e assim por diante.</p>
<p>Para que um autômato pudesse reconhecer esta linguagem, ele precisaria ler todos os ’0’s, contar quantos foram lidos, e então verificar se a quantidade de ’1’s subsequentes é exatamente a mesma. Se <span class="math inline">\(n\)</span> pode ser um número arbitrariamente grande, a máquina precisaria de um número infinito de estados para memorizar cada contagem possível de ’0’s, o que viola a definição de um autômato <em>finito</em>.</p>
<p>Essa incapacidade de lidar com estruturas de aninhamento ou contagens ilimitadas é a razão pela qual modelos computacionais mais poderosos, como os <strong>Autômatos de Pilha</strong>, são necessários para as fases seguintes da compilação, como a análise sintática.</p>


<div id="refs" class="references csl-bib-body" data-entry-spacing="1" role="list" style="display: none">
<div id="ref-Aho2007Compilers" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">AHO, A. V. et al. <strong>Compilers: Principles, techniques, and tools</strong>. 2nd. ed. [s.l.] Pearson; Addison-Wesley, 2007. </div>
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./01a-lexico.html" class="pagination-link" aria-label="Alfabetos, Linguagens e Strings: Fundamentos Matemáticos">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Alfabetos, Linguagens e Strings: Fundamentos Matemáticos</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./parsers.html" class="pagination-link" aria-label="Parsers LL(1): O Mundo da Análise Sintática">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Parsers LL(1): O Mundo da Análise Sintática</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/linguagens-formais/edit/main/02-lexico.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linguagens-formais/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>