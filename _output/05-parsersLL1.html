<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Linguagens Formais e Autômatos - 6&nbsp; Parsers LL(1): Começando a Análise Sintática</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./fase1.html" rel="next">
<link href="./04-Gramaticas.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/custom.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./04-Gramaticas.html">Analisadores Sintáticos</a></li><li class="breadcrumb-item"><a href="./05-parsersLL1.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Parsers LL(1): Começando a Análise Sintática</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Linguagens Formais e Autômatos</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/frankalcantara/linguagens-formais" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Disciplina de Linguagens Formais</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Analisadores Léxicos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Analisadores Léxicos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01a-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Alfabetos, Linguagens e Strings: Fundamentos Matemáticos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-lexico.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Autômatos Finitos Determinísticos</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Analisadores Sintáticos</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-Gramaticas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Gramáticas e Linguagens Livres de Contexto</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-parsersLL1.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Parsers LL(1): Começando a Análise Sintática</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Projeto da Disciplina - 2025-2</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./fase1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Fase 1 - Projeto Prático</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./apend1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Apêndice 1: A Relação de Myhill-Nerode</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sol-exercicios.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Solução dos Exercícios</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referências</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sumário</h2>
   
  <ul>
  <li><a href="#definição-e-características-dos-parsers-ll1" id="toc-definição-e-características-dos-parsers-ll1" class="nav-link active" data-scroll-target="#definição-e-características-dos-parsers-ll1"><span class="header-section-number">6.1</span> Definição e Características dos Parsers LL(1)</a></li>
  <li><a href="#eliminação-da-recursão-à-esquerda" id="toc-eliminação-da-recursão-à-esquerda" class="nav-link" data-scroll-target="#eliminação-da-recursão-à-esquerda"><span class="header-section-number">6.2</span> Eliminação da Recursão à Esquerda</a></li>
  <li><a href="#elementos-fundamentais-do-parser-ll1" id="toc-elementos-fundamentais-do-parser-ll1" class="nav-link" data-scroll-target="#elementos-fundamentais-do-parser-ll1"><span class="header-section-number">6.3</span> Elementos Fundamentais do Parser LL(1)</a></li>
  <li><a href="#conjuntos-nullable-first-e-follow" id="toc-conjuntos-nullable-first-e-follow" class="nav-link" data-scroll-target="#conjuntos-nullable-first-e-follow"><span class="header-section-number">6.4</span> Conjuntos NULLABLE, FIRST e FOLLOW</a>
  <ul class="collapse">
  <li><a href="#o-conjunto-nullable" id="toc-o-conjunto-nullable" class="nav-link" data-scroll-target="#o-conjunto-nullable"><span class="header-section-number">6.4.1</span> O Conjunto NULLABLE</a></li>
  <li><a href="#o-conjunto-first" id="toc-o-conjunto-first" class="nav-link" data-scroll-target="#o-conjunto-first"><span class="header-section-number">6.4.2</span> O Conjunto FIRST</a></li>
  <li><a href="#o-conjunto-follow" id="toc-o-conjunto-follow" class="nav-link" data-scroll-target="#o-conjunto-follow"><span class="header-section-number">6.4.3</span> O Conjunto FOLLOW</a></li>
  <li><a href="#algoritmo-para-calcular-o-conjunto-follow-versão-revisada" id="toc-algoritmo-para-calcular-o-conjunto-follow-versão-revisada" class="nav-link" data-scroll-target="#algoritmo-para-calcular-o-conjunto-follow-versão-revisada"><span class="header-section-number">6.4.4</span> Algoritmo para calcular o conjunto FOLLOW (Versão Revisada)</a></li>
  <li><a href="#aplicando-as-regras-um-primeiro-exemplo" id="toc-aplicando-as-regras-um-primeiro-exemplo" class="nav-link" data-scroll-target="#aplicando-as-regras-um-primeiro-exemplo"><span class="header-section-number">6.4.5</span> Aplicando as Regras: Um Primeiro Exemplo</a></li>
  </ul></li>
  <li><a href="#o-exemplo-mais-comum-de-todos" id="toc-o-exemplo-mais-comum-de-todos" class="nav-link" data-scroll-target="#o-exemplo-mais-comum-de-todos"><span class="header-section-number">6.5</span> O Exemplo Mais Comum de Todos</a>
  <ul class="collapse">
  <li><a href="#gramática-original" id="toc-gramática-original" class="nav-link" data-scroll-target="#gramática-original"><span class="header-section-number">6.5.1</span> Gramática Original</a></li>
  <li><a href="#nullable" id="toc-nullable" class="nav-link" data-scroll-target="#nullable"><span class="header-section-number">6.5.2</span> <span class="math inline">\(NULLABLE\)</span></a></li>
  <li><a href="#first" id="toc-first" class="nav-link" data-scroll-target="#first"><span class="header-section-number">6.5.3</span> <span class="math inline">\(FIRST\)</span></a></li>
  <li><a href="#follow" id="toc-follow" class="nav-link" data-scroll-target="#follow"><span class="header-section-number">6.5.4</span> <span class="math inline">\(FOLLOW\)</span></a></li>
  <li><a href="#tabela-de-derivação-ll1" id="toc-tabela-de-derivação-ll1" class="nav-link" data-scroll-target="#tabela-de-derivação-ll1"><span class="header-section-number">6.5.5</span> Tabela de Derivação <span class="math inline">\(LL(1)\)</span></a></li>
  <li><a href="#processo-de-parser-testando-com-id-id-id" id="toc-processo-de-parser-testando-com-id-id-id" class="nav-link" data-scroll-target="#processo-de-parser-testando-com-id-id-id"><span class="header-section-number">6.5.6</span> Processo de Parser Testando com <span class="math inline">\(id + id * id\)</span></a></li>
  <li><a href="#testando-com-a-string-id---id-id" id="toc-testando-com-a-string-id---id-id" class="nav-link" data-scroll-target="#testando-com-a-string-id---id-id"><span class="header-section-number">6.5.7</span> Testando com a <em>string</em> <span class="math inline">\(id - id * id\)</span></a></li>
  </ul></li>
  <li><a href="#um-exemplo-nem-tão-comum" id="toc-um-exemplo-nem-tão-comum" class="nav-link" data-scroll-target="#um-exemplo-nem-tão-comum"><span class="header-section-number">6.6</span> Um Exemplo Nem Tão Comum</a>
  <ul class="collapse">
  <li><a href="#gramática-original-1" id="toc-gramática-original-1" class="nav-link" data-scroll-target="#gramática-original-1"><span class="header-section-number">6.6.1</span> Gramática Original</a></li>
  <li><a href="#corrigindo-a-recursão-à-esquerda" id="toc-corrigindo-a-recursão-à-esquerda" class="nav-link" data-scroll-target="#corrigindo-a-recursão-à-esquerda"><span class="header-section-number">6.6.2</span> Corrigindo a Recursão à Esquerda</a></li>
  <li><a href="#gramática-corrigida-pronta-para-ll1" id="toc-gramática-corrigida-pronta-para-ll1" class="nav-link" data-scroll-target="#gramática-corrigida-pronta-para-ll1"><span class="header-section-number">6.6.3</span> Gramática Corrigida (Pronta para LL(1))</a></li>
  <li><a href="#nullable-1" id="toc-nullable-1" class="nav-link" data-scroll-target="#nullable-1"><span class="header-section-number">6.6.4</span> <span class="math inline">\(NULLABLE\)</span></a></li>
  <li><a href="#first-1" id="toc-first-1" class="nav-link" data-scroll-target="#first-1"><span class="header-section-number">6.6.5</span> <span class="math inline">\(FIRST\)</span></a></li>
  <li><a href="#follow-1" id="toc-follow-1" class="nav-link" data-scroll-target="#follow-1"><span class="header-section-number">6.6.6</span> <span class="math inline">\(FOLLOW\)</span></a></li>
  <li><a href="#tabela-de-derivação-ll1-1" id="toc-tabela-de-derivação-ll1-1" class="nav-link" data-scroll-target="#tabela-de-derivação-ll1-1"><span class="header-section-number">6.6.7</span> Tabela de Derivação <span class="math inline">\(LL(1)\)</span></a></li>
  <li><a href="#testando-com-id-or-not-id-and-id-or-id" id="toc-testando-com-id-or-not-id-and-id-or-id" class="nav-link" data-scroll-target="#testando-com-id-or-not-id-and-id-or-id"><span class="header-section-number">6.6.8</span> Testando com <em>id or not id and (id or id)</em></a></li>
  <li><a href="#testando-com-id-or-not-id-and-id-or-id-1" id="toc-testando-com-id-or-not-id-and-id-or-id-1" class="nav-link" data-scroll-target="#testando-com-id-or-not-id-and-id-or-id-1"><span class="header-section-number">6.6.9</span> Testando com <code>id or not id and (id or id)</code></a></li>
  </ul></li>
  <li><a href="#conflitos-na-tabela-de-derivação" id="toc-conflitos-na-tabela-de-derivação" class="nav-link" data-scroll-target="#conflitos-na-tabela-de-derivação"><span class="header-section-number">6.7</span> Conflitos na Tabela de Derivação</a>
  <ul class="collapse">
  <li><a href="#conjunto-first" id="toc-conjunto-first" class="nav-link" data-scroll-target="#conjunto-first"><span class="header-section-number">6.7.1</span> Conjunto FIRST</a></li>
  <li><a href="#conjunto-follow" id="toc-conjunto-follow" class="nav-link" data-scroll-target="#conjunto-follow"><span class="header-section-number">6.7.2</span> Conjunto FOLLOW</a></li>
  <li><a href="#nullable-2" id="toc-nullable-2" class="nav-link" data-scroll-target="#nullable-2"><span class="header-section-number">6.7.3</span> Nullable</a></li>
  <li><a href="#resumo-dos-conjuntos" id="toc-resumo-dos-conjuntos" class="nav-link" data-scroll-target="#resumo-dos-conjuntos"><span class="header-section-number">6.7.4</span> Resumo dos Conjuntos</a></li>
  </ul></li>
  <li><a href="#tipos-de-conflitos-nas-tabelas-de-derivação" id="toc-tipos-de-conflitos-nas-tabelas-de-derivação" class="nav-link" data-scroll-target="#tipos-de-conflitos-nas-tabelas-de-derivação"><span class="header-section-number">6.8</span> Tipos de Conflitos Nas Tabelas de Derivação</a>
  <ul class="collapse">
  <li><a href="#resolução-de-conflitos" id="toc-resolução-de-conflitos" class="nav-link" data-scroll-target="#resolução-de-conflitos"><span class="header-section-number">6.8.1</span> Resolução de Conflitos</a></li>
  <li><a href="#pseudocódigo-para-a-criação-da-tabela-de-derivação" id="toc-pseudocódigo-para-a-criação-da-tabela-de-derivação" class="nav-link" data-scroll-target="#pseudocódigo-para-a-criação-da-tabela-de-derivação"><span class="header-section-number">6.8.2</span> Pseudocódigo para a Criação da Tabela de Derivação</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/frankalcantara/linguagens-formais/edit/main/05-parsersLL1.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linguagens-formais/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./04-Gramaticas.html">Analisadores Sintáticos</a></li><li class="breadcrumb-item"><a href="./05-parsersLL1.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Parsers LL(1): Começando a Análise Sintática</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Parsers LL(1): Começando a Análise Sintática</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Está sem tempo? Leia o <a href=".\ex\05-expresso.html">Expresso</a>.</p>
</div>
</div>
<p><strong>Elementar meu caro Watson!</strong> Mesmo que Sherlock nunca tenha dito esta frase nos livros de <a href="https://www.ebiografia.com/arthur_conan_doyle/">Sir Arthur Conan Doyle</a>, a lembrança do grande detetive ocupa meu imaginário sempre que falo de <em>parsers</em>. Assim como o grande detetive, o trabalho do <em>parser</em> será verificar todos os detalhes de uma cena e validar cada um dos seus itens em relação a um contexto. No nosso caso, a cena será formada por um <em>string</em> e o contexto do crime, será determinado por uma Tabela de Derivação. Infelizmente nosso detetive, o <em>parser</em> <span class="math inline">\(LL(1)\)</span>, nem de perto terá a mesma capacidade de Sherlock Holmes. Ainda que seja eficiente, um <em>parser</em> <span class="math inline">\(LL(1)\)</span> é linear e determinístico e, pensando bem, esta foi uma metáfora ruim. Mas, eu sempre quis começar um texto falado: elementar meu caro Watson!.</p>
<p>Em geral, ainda que muitos lenços de papel tenham sido gastos durantes as avaliações de final de período, <em>parsers</em> <span class="math inline">\(LL(1)\)</span> são algoritmos simples.</p>
<p>Um <em>parser</em> <span class="math inline">\(LL(1)\)</span> é um tipo de analisador sintático descendente que utiliza a análise preditiva, e uma tabela que chamarei de Tabela de Derivação, para determinar qual será a regra de produção que deverá ser aplicada em cada etapa da análise expandindo um símbolo não-terminal de acordo com uma de suas regras de produção, criando uma árvore sintática e permitindo a identificação de um <em>string</em> como parte de uma determinada linguagem. Esta ideia começou com o trabalho <a href="https://www.sciencedirect.com/science/article/pii/S0019995865904262"><em>On the Translation of Languages from Left to Right</em></a> de <a href="https://pt.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a> mas foi sendo aprimorada ao longo do tempo por pesquisadores como <a href="https://en.wikipedia.org/wiki/Alfred_Aho">Alfred Aho</a> e <a href="https://en.wikipedia.org/wiki/Jeffrey_Ullman">Jeffrey Ullman</a>, nas décadas de 1970 e 1980</p>
<p>A análise preditiva é um tipo de análise descendente que usa uma pilha para armazenar os símbolos esperados e os conjuntos <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span> para prever qual regra de produção aplicar em cada etapa do processo de análise. Essa previsão permite que o analisador tome decisões sem precisar retroceder, tornando a análise mais eficiente computacionalmente. Esta análise preditiva será a ação que um parser <span class="math inline">\(LL(1)\)</span> irá utilizar para validar os <em>strings</em> de uma determinada linguagem, símbolo por símbolo.</p>
<p>Para atingir meu objetivo, com este texto, as linguagens que usaremos como exemplo serão representadas apenas pelo conjunto de regras de produção da sua gramática. Vou manter a álgebra o mais longe possível e se o conjunto de regras de produção estiver perfeitamente construído todos os elementos da gramática poderão ser identificados. Isso permitirá que aqueles sem arrepios algébricos tenham um ponto de partida para uma análise formal da linguagem.</p>
<p>Outro ponto importante, neste texto, símbolos não-terminais serão representados em caracteres latinos maiúsculos seguidos ou não de um apóstrofo (’), e os símbolos terminais em caracteres latinos minúsculos. A única exceção será <span class="math inline">\(\varepsilon\)</span> para representar uma produção vazia.</p>
<section id="definição-e-características-dos-parsers-ll1" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="definição-e-características-dos-parsers-ll1"><span class="header-section-number">6.1</span> Definição e Características dos Parsers LL(1)</h2>
<p>Os <em>parsers</em> preditivos são analisadores sintáticos descendentes (<em>top-down</em>) que utilizam um único símbolo de <em>lookahead</em> (antecipação) para determinar a regra de produção correta a ser aplicada em cada etapa da análise. Eles <em>predizem</em> qual regra usar com base no próximo símbolo da entrada e no não-terminal atualmente sendo analisado. O termo <span class="math inline">\(LL(1)\)</span> significa:</p>
<ul>
<li><strong>L</strong>: Left-to-right scan (varredura da esquerda para a direita) da entrada.</li>
<li><strong>L</strong>: Leftmost derivation (derivação mais à esquerda) da gramática.</li>
<li><strong>1</strong>: Um símbolo de <em>lookahead</em> (antecipação) para tomada de decisão.</li>
</ul>
<p>Um <em>parser</em> <span class="math inline">\(LL(1)\)</span>, requer uma gramática <span class="math inline">\(LL(1)\)</span>. Nesta gramática não pode existir qualquer ambiguidade na escolha da regra de produção que será aplicada a cada símbolo de <em>lookahead</em>. Além disso, a gramática não pode ter recursão à esquerda, seja esta recursão direta ou indireta. A recursão à esquerda é um desafio considerável. Existem duas formas de recursão à esquerda:</p>
<ul>
<li><p><strong>Recursão à Esquerda Direta</strong>: ocorre quando um símbolo não-terminal pode ser derivado em uma sequência que começa com ele mesmo. Por exemplo, na regra <span class="math inline">\(A \rightarrow Aa \mid b\)</span>, o símbolo <span class="math inline">\(A\)</span> pode ser substituído no processo de derivação em <span class="math inline">\(Aa\)</span>, no qual <span class="math inline">\(A\)</span> aparece novamente no início da regra. E aqui está o laço infinito.</p></li>
<li><p><strong>Recursão à Esquerda Indireta</strong>: acontece quando um símbolo não-terminal pode ser derivado em uma sequência que começa com outro símbolo não-terminal, que por sua vez pode ser derivado de volta ao símbolo original. Ilustrando, nas regras <span class="math inline">\(A \rightarrow Ba\)</span> e <span class="math inline">\(B \rightarrow Ab\)</span>, <span class="math inline">\(A\)</span> deriva para <span class="math inline">\(Ba\)</span>, <span class="math inline">\(B\)</span> deriva para <span class="math inline">\(Ab\)</span> e <span class="math inline">\(Ab\)</span> pode derivar novamente para <span class="math inline">\(A\)</span>, criando outro laço infinito.</p></li>
</ul>
<p>Além do perigo do laço de repetição infinito que faz o pobre Turing se revolver no túmulo, a recursão à esquerda impede o desenvolvimento de uma Tabela de Derivação, graças a criação de regras em conflito. Duas ou mais regras, para a mesma combinação de símbolo terminal e símbolo não-terminal em um determinado momento do processo de <em>parser</em>.</p>
</section>
<section id="eliminação-da-recursão-à-esquerda" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="eliminação-da-recursão-à-esquerda"><span class="header-section-number">6.2</span> Eliminação da Recursão à Esquerda</h2>
<p>Felizmente, existem técnicas para eliminar a recursão à esquerda em gramáticas livres de contexto. Uma técnica comum e eficaz envolve a introdução de novos símbolos não terminais e a substituição de regras recursivas por regras equivalentes que não apresentem recursão. Em alguns casos, a substituição direta dos símbolos não terminais recursivos por suas respectivas regras pode ser suficiente para eliminar a recursão à esquerda direta. Outra técnica, a fatoração à esquerda, pode ser utilizada para eliminar ambiguidades na gramática, mas não resolve diretamente o problema da recursão.</p>
<p><strong>Exemplo 1</strong>: eliminando a Recursão à Esquerda Direta, considere a regra <span class="math inline">\(A \rightarrow Aa \mid b\)</span>. Esta regra pode ser reescrita como:</p>
<ol type="1">
<li><span class="math inline">\(A \rightarrow bA'\)</span></li>
<li><span class="math inline">\(A' \rightarrow aA' \mid \varepsilon\)</span></li>
</ol>
<p>Agora, a gramática não contém mais recursão à esquerda direta. Este é um exemplo simples, adequado a este texto cujo objetivo é o parser em si. A nova regra inclui o não-terminal <span class="math inline">\(A'\)</span>, que permite zero ou mais repetições do símbolo <span class="math inline">\(a\)</span>. O uso de <span class="math inline">\(\varepsilon\)</span> (a produção vazia) permite terminar a derivação de <span class="math inline">\(A'\)</span>. Será?</p>
<p>Para verificar a recursão à esquerda indireta, você precisa observar se é possível derivar uma recursão por meio de uma cadeia de substituições:</p>
<ol type="1">
<li>Substituindo <span class="math inline">\(A\)</span>:
<ul>
<li><span class="math inline">\(A \rightarrow bA'\)</span></li>
</ul></li>
<li>Substituindo <span class="math inline">\(A'\)</span>:
<ul>
<li><span class="math inline">\(A' \rightarrow aA'\)</span></li>
<li><span class="math inline">\(A' \rightarrow \varepsilon\)</span></li>
</ul></li>
</ol>
<p>Observe que substituindo <span class="math inline">\(A\)</span> por <span class="math inline">\(bA'\)</span> e depois <span class="math inline">\(A'\)</span> por <span class="math inline">\(aA'\)</span> ou <span class="math inline">\(\varepsilon\)</span> não leva de volta a <span class="math inline">\(A\)</span>. E parece não haver recursão. Contudo, é necessário verificar se foi criada alguma recursão à esquerda indireta, focando em <span class="math inline">\(A'\)</span>:</p>
<ul>
<li><strong>Primeira substituição</strong>:
<ul>
<li><span class="math inline">\(A \rightarrow bA'\)</span></li>
</ul></li>
<li><strong>Substituindo</strong> <span class="math inline">\(A'\)</span> por <span class="math inline">\(aA'\)</span>:
<ul>
<li><span class="math inline">\(bA' \rightarrow b(aA')\)</span></li>
<li><span class="math inline">\(bA' \rightarrow baA'\)</span></li>
</ul></li>
<li><strong>Substituindo novamente</strong> <span class="math inline">\(A'\)</span> por <span class="math inline">\(aA'\)</span>:
<ul>
<li><span class="math inline">\(baA' \rightarrow baaA'\)</span></li>
</ul></li>
<li>E assim por diante… Aqui, <span class="math inline">\(A'\)</span> substitui a si próprio com um prefixo <span class="math inline">\(a\)</span>, mas isto não cria recursão indireta ao <span class="math inline">\(A'\)</span> inicial de forma a levar a uma cadeia circular que retorne ao símbolo inicial <span class="math inline">\(A\)</span>. A gramática transformada não apresenta recursão à esquerda indireta para <span class="math inline">\(A'\)</span>.</li>
<li><span class="math inline">\(A\)</span>: Não tem recursão à esquerda direta nem indireta, porque <span class="math inline">\(A \rightarrow bA'\)</span> começa com um terminal.</li>
<li><span class="math inline">\(A'\)</span>: A regra <span class="math inline">\(A' \rightarrow aA' \mid \varepsilon\)</span> apenas permite que <span class="math inline">\(A'\)</span> produza cadeias de <span class="math inline">\(a\)</span> seguidos possivelmente por <span class="math inline">\(\varepsilon\)</span>, sem retornar a um estado anterior que causaria recursão indireta.</li>
</ul>
<p>Portanto, a transformação feita elimina a recursão à esquerda direta sem introduzir recursão à esquerda indireta. A recursão à esquerda indireta é mais complexa e requer um texto específico para o assunto. Mas, em linhas gerais você terá que refazer a gramática em face dos objetivos originais para eliminar este tipo de recursão.</p>
</section>
<section id="elementos-fundamentais-do-parser-ll1" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="elementos-fundamentais-do-parser-ll1"><span class="header-section-number">6.3</span> Elementos Fundamentais do Parser LL(1)</h2>
<p>Como a classe de gramáticas para um <em>parser</em> <span class="math inline">\(LL(1)\)</span> é limitada (nem todas as gramáticas livres de contexto são <span class="math inline">\(LL(1)\)</span>, é muito comum que seja necessário modificar a sua ideia original de gramática para eliminar ambiguidades e recursões à esquerda. Um <em>parser</em> <span class="math inline">\(LL(1)\)</span>, para funcionar, precisa dos seguintes elementos:</p>
<ol type="1">
<li><p><strong>Tabela de Derivação</strong>: o <em>parser</em> <span class="math inline">\(LL(1)\)</span> utiliza uma Tabela de Derivação, ou Tabela de Análise (<em>parsing</em>), que mapeia cada combinação de não-terminal e terminal (ou símbolo de fim de entrada) para a regra de produção que deve ser aplicada. Essa tabela é construída a partir da gramática e dos conjuntos <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span> e será o mapa que guiará todo o processo de análise sintática.</p></li>
<li><p><strong>Pilha e Buffer</strong>: O parser mantém uma pilha e lê a entrada da esquerda para a direita, carácter por carácter. A pilha inicialmente contém o símbolo inicial da gramática e o símbolo de fim de entrada, um cifrão: $. A entrada frequentemente é mantida em uma estrutura de dados com funcionalidades de <em>buffer</em>, que pode ser a própria <em>string</em> que está sendo analisada.</p></li>
<li><p><strong>Análise</strong>: Em cada passo:</p>
<ul>
<li>O parser consulta a Tabela de Derivação usando como índices o não-terminal no topo da pilha e o próximo símbolo da entrada.</li>
<li>A tabela indica a produção a ser aplicada.</li>
<li>O não-terminal no topo da pilha é substituído pelos símbolos da produção (empilhados em ordem inversa).</li>
<li>Se o topo da pilha for um terminal que coincide com o próximo símbolo da entrada, ambos são removidos da pilha e da entrada.</li>
</ul></li>
<li><p><strong>Sucesso ou Erro</strong>: A análise termina com sucesso quando a pilha e a entrada estão vazias. Caso contrário, ocorre um erro sintático. Erros poderão ocorrer durante o processo sempre que a combinação de símbolos na pilha e no <em>buffer</em> apontarem para uma célula vazia da Tabela de Derivação.</p></li>
</ol>
</section>
<section id="conjuntos-nullable-first-e-follow" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="conjuntos-nullable-first-e-follow"><span class="header-section-number">6.4</span> Conjuntos NULLABLE, FIRST e FOLLOW</h2>
<p>Não dá nem para começar a pensar em criar um <em>parser</em> <span class="math inline">\(LL(1)\)</span> se não entender os conjuntos <span class="math inline">\(NULLABLE\)</span>, <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span>. Imagine que você está aprendendo um novo idioma. Para formar frases corretas, você precisará entender quais palavras podem vir antes ou depois de outras. Ou corre o risco de falar como o Yoda. Se quiser evitar ser confundido com um velho alienígena, precisa aprender, no mínimo, a ordem das palavras, muito antes de entender a classe gramatical destas mesmas palavras. Como uma criança aprendendo a falar.</p>
<p>Eu forcei um pouco a barra na metáfora, mas na análise sintática de linguagens livres de contexto, os conjuntos <span class="math inline">\(NULLABLE\)</span>, <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span> desempenham um papel importante que quase valida minha metáfora. Estes conjuntos ajudam a decifrar a gramática da linguagem de forma determinística, determinando as regras de produção que serão aplicadas aos símbolos da <em>string</em> de entrada para garantir que ela faça parte da linguagem.</p>
<p>Antes de detalharmos o <span class="math inline">\(FIRST\)</span> e o <span class="math inline">\(FOLLOW\)</span>, precisamos de um conceito fundamental: o conjunto de símbolos <strong>NULLABLE</strong>. Um símbolo não-terminal é considerado <em>NULLABLE</em> se ele pode derivar a cadeia vazia (<span class="math inline">\(\varepsilon\)</span>), ou seja, se ele pode efetivamente “desaparecer” em uma derivação. Saber se um símbolo pode ou não desaparecer é essencial para os cálculos seguintes.</p>
<p>O conjunto <span class="math inline">\(FIRST\)</span> de um símbolo não-terminal será composto dos símbolos terminais que podem aparecer como <strong>primeiro símbolo</strong> de qualquer sequência de símbolos que seja derivada desse não-terminal, incluindo <span class="math inline">\(\varepsilon\)</span> se o símbolo for <em>NULLABLE</em>. Em outras palavras, o conjunto <span class="math inline">\(FIRST\)</span> indica quais terminais podem iniciar uma declaração válida (frase) dentro da estrutura gramática definida por um não-terminal. Por exemplo, considere uma gramática para definir expressões aritméticas. O não-terminal <em>EXPR</em> pode derivar diversas sequências de símbolos, como <em>2 + 3</em>, <em>(4</em> 5)<em>,</em> x - y<em>. O conjunto</em> <span class="math inline">\(FIRST\)</span> do não-terminal EXPR* seria, neste caso específico, <span class="math inline">\({número, '+', '-', '('}\)</span>, porque esses são os símbolos que podem iniciar qualquer expressão aritmética válida nesta gramática até onde podemos saber com as informações passadas neste parágrafo.</p>
<p>O conjunto <span class="math inline">\(FOLLOW\)</span>, por sua vez, determina o conjunto de símbolos terminais que podem aparecer <strong>imediatamente após</strong> um não-terminal em alguma derivação da gramática. Ou colocando de outra forma, o conjunto <span class="math inline">\(FOLLOW\)</span> indica quais terminais podem seguir (<em>follow</em>) um não-terminal em uma declaração válida da linguagem.</p>
<p>Diferentemente do <span class="math inline">\(FIRST\)</span>, que se concentra no início de uma derivação, o <span class="math inline">\(FOLLOW\)</span> analisa o contexto no qual um não-terminal aparece. Seu cálculo depende criticamente de saber quais símbolos são <em>NULLABLE</em>, pois se um símbolo <span class="math inline">\(y\)</span> que segue um não-terminal <span class="math inline">\(X\)</span> pode desaparecer, então tudo o que pode seguir a regra na qual <span class="math inline">\(X\)</span> e <span class="math inline">\(y\)</span> aparecem também pode seguir <span class="math inline">\(X\)</span>. Por exemplo, considere uma gramática que define declarações de variáveis. O não-terminal <em>DECLARACAO_VAR</em> pode ser seguido por diferentes símbolos, dependendo do contexto. Em uma linguagem como a linguagem C, por exemplo, uma declaração de variável pode terminar com um ponto e vírgula, ser seguida por um operador de atribuição e uma expressão, ou até mesmo ser parte de uma estrutura maior. Neste cenário, o conjunto <span class="math inline">\(FOLLOW\)</span> do não-terminal <em>DECLARACAO_VAR</em> incluiria o ponto e vírgula ‘;’, o sinal de igual ‘=’, e todos os outros símbolos que podem iniciar uma expressão ou um comando que a linguagem permita ocorrer na mesma linha da declaração da variável.</p>
<p>Os conjuntos <span class="math inline">\(NULLABLE\)</span>, <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span> serão utilizados para construir a Tabela de Derivação <span class="math inline">\(LL(1)\)</span>. A forma tecnicamente mais correta seria dizer que estes conjuntos formam a Tabela De Análise <span class="math inline">\(LL(1)\)</span>. Entretanto, pobre de mim, prefiro chamar de Tabela de Derivação.</p>
<p>As Tabelas de Derivação são tabelas que guiam o processo de análise sintática descendente preditiva no <em>parser</em> <span class="math inline">\(LL(1)\)</span> deterministicamente. Cada célula dessas tabelas corresponde a relação que existe em um par não-terminal, terminal. De forma que o valor da célula apontada por este par indica qual regra de produção deve ser aplicada quando o analisador encontrar este par específico durante a análise preditiva <span class="math inline">\(LL(1)\)</span>.</p>
<section id="o-conjunto-nullable" class="level3" data-number="6.4.1">
<h3 data-number="6.4.1" class="anchored" data-anchor-id="o-conjunto-nullable"><span class="header-section-number">6.4.1</span> O Conjunto NULLABLE</h3>
<p>Antes de nos aprofundarmos nos conjuntos <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span>, é essencial entender um conceito preliminar: o conjunto dos símbolos <span class="math inline">\(NULLABLE\)</span>. Um símbolo não-terminal é considerado <span class="math inline">\(NULLABLE\)</span> se ele pode derivar a cadeia vazia (<span class="math inline">\(\varepsilon\)</span>) através de qualquer sequência de derivações possível.</p>
<p><strong>Importante:</strong> Um símbolo pode ser <span class="math inline">\(NULLABLE\)</span> de três formas distintas:</p>
<ol type="1">
<li><strong>Nullable Direto</strong>: Quando existe uma produção explícita <span class="math inline">\(A \rightarrow \varepsilon\)</span>;</li>
<li><strong>Nullable Indireto Simples</strong>: Quando <span class="math inline">\(A \rightarrow B\)</span> e <span class="math inline">\(B\)</span> é <span class="math inline">\(NULLABLE\)</span>;</li>
<li><strong>Nullable Indireto Múltiplo</strong>: Quando <span class="math inline">\(A \rightarrow B_1 B_2 ... B_n\)</span> e <strong>todos</strong> os símbolos <span class="math inline">\(B_1, B_2, ..., B_n\)</span> são <span class="math inline">\(NULLABLE\)</span> (seja direta ou indiretamente).</li>
</ol>
<p>Por exemplo, considere as produções listadas a seguir:</p>
<ul>
<li><span class="math inline">\(A \rightarrow B C\)</span>;</li>
<li><span class="math inline">\(B \rightarrow D E\)</span>;</li>
<li><span class="math inline">\(C \rightarrow \varepsilon\)</span>;</li>
<li><span class="math inline">\(D \rightarrow \varepsilon\)</span>;</li>
<li><span class="math inline">\(E \rightarrow \varepsilon\)</span>.</li>
</ul>
<p>Neste caso, teremos:</p>
<ul>
<li><span class="math inline">\(C\)</span>, <span class="math inline">\(D\)</span> e <span class="math inline">\(E\)</span> são <span class="math inline">\(NULLABLE\)</span> diretos (regra 1);</li>
<li><span class="math inline">\(B\)</span> é <span class="math inline">\(NULLABLE\)</span> porque <span class="math inline">\(B \rightarrow D E\)</span> e tanto <span class="math inline">\(D\)</span> quanto <span class="math inline">\(E\)</span> são <span class="math inline">\(NULLABLE\)</span> (regra 3);</li>
<li><span class="math inline">\(A\)</span> é <span class="math inline">\(NULLABLE\)</span> porque <span class="math inline">\(A \rightarrow B C\)</span> e tanto <span class="math inline">\(B\)</span> quanto <span class="math inline">\(C\)</span> são <span class="math inline">\(NULLABLE\)</span> (regra 3).</li>
</ul>
<p>Note que <span class="math inline">\(A\)</span> só se torna <span class="math inline">\(NULLABLE\)</span> após várias iterações: primeiro identificamos <span class="math inline">\(C\)</span>, <span class="math inline">\(D\)</span> e <span class="math inline">\(E\)</span>, depois <span class="math inline">\(B\)</span>, e finalmente <span class="math inline">\(A\)</span>. Esta propagação em cascata é fundamental para o algoritmo.</p>
<p>Identificar quais símbolos são <span class="math inline">\(NULLABLE\)</span> é um passo preparatório fundamental. Essa informação é usada para determinar:</p>
<ol type="a">
<li>Quando incluir <span class="math inline">\(\varepsilon\)</span> no conjunto <span class="math inline">\(FIRST\)</span> de um não-terminal;</li>
<li>Quando o analisador deve “olhar através” de um símbolo em uma produção para calcular o <span class="math inline">\(FIRST\)</span> do que vem a seguir;</li>
<li>Quando o conjunto <span class="math inline">\(FOLLOW\)</span> de um não-terminal deve herdar símbolos do <span class="math inline">\(FOLLOW\)</span> de outro, porque o símbolo que o sucede pode “desaparecer” (derivar em <span class="math inline">\(\varepsilon\)</span>).</li>
</ol>
<section id="regras-de-criação-do-conjunto-nullable" class="level4" data-number="6.4.1.1">
<h4 data-number="6.4.1.1" class="anchored" data-anchor-id="regras-de-criação-do-conjunto-nullable"><span class="header-section-number">6.4.1.1</span> Regras de Criação do Conjunto NULLABLE</h4>
<p>Para construir o conjunto de todos os símbolos não-terminais <em>NULLABLE</em> de uma gramática, aplicamos as seguintes regras de forma iterativa até que o conjunto não mude mais:</p>
<ol type="1">
<li><strong>Regra Base (Nulidade Direta):</strong> Se existe uma produção da forma <span class="math inline">\(A \rightarrow ε\)</span>, então <span class="math inline">\(A\)</span> é adicionado ao conjunto <em>NULLABLE</em>.</li>
<li><strong>Regra de Indução (Nulidade Indireta):</strong> Se existe uma produção da forma <span class="math inline">\(A \rightarrow Y₁Y₂...Yₙ\)</span>, e <strong>todos</strong> os símbolos <span class="math inline">\(Y₁\)</span>, <span class="math inline">\(Y₂\)</span>, …, <span class="math inline">\(Yₙ\)</span> já foram identificados como <em>NULLABLE</em>, então <span class="math inline">\(A\)</span> também é adicionado ao conjunto.</li>
</ol>
</section>
<section id="exemplo-de-criação-do-conjunto-nullable" class="level4" data-number="6.4.1.2">
<h4 data-number="6.4.1.2" class="anchored" data-anchor-id="exemplo-de-criação-do-conjunto-nullable"><span class="header-section-number">6.4.1.2</span> Exemplo de Criação do Conjunto NULLABLE</h4>
<p>Considere a seguinte gramática:</p>
<p><span class="math display">\[
\begin{array}{c}
S \rightarrow A B C \\
&amp;A \rightarrow a | ε \\
&amp;B \rightarrow C D \\
&amp;C \rightarrow c | ε \\
&amp;D \rightarrow A
\end{array}
\]</span></p>
<p>O processo de construção do conjunto <em>NULLABLE</em> seria:</p>
<ol type="1">
<li><strong>Iteração 1:</strong> Analisando as regras diretas, encontramos <code>A \rightarrow ε</code> e <code>C \rightarrow ε</code>. <em>Conjunto Nullable = { A, C }</em></li>
<li><strong>Iteração 2:</strong> Agora, verificamos as outras regras com base no que já sabemos.
<ul>
<li>Na regra <code>D \rightarrow A</code>, como <code>A</code> está no conjunto, <code>D</code> também se torna <em>NULLABLE</em>.</li>
<li>Na regra <code>B \rightarrow C D</code>, agora sabemos que tanto <code>C</code> quanto <code>D</code> são <em>NULLABLE</em>. Portanto, <code>B</code> também se torna <em>NULLABLE</em>. <em>Conjunto Nullable = { A, C, D, B }</em></li>
</ul></li>
<li><strong>Iteração 3:</strong> Revisitamos as regras com o conjunto atualizado.
<ul>
<li>Na regra <code>S \rightarrow A B C</code>, agora sabemos que <code>A</code>, <code>B</code> e <code>C</code> são todos <em>NULLABLE</em>. Portanto, <code>S</code> também se torna <em>NULLABLE</em>. <em>Conjunto Nullable = { A, C, D, B, S }</em></li>
</ul></li>
<li><strong>Iteração 4:</strong> Nenhuma nova adição é feita ao conjunto. O algoritmo termina.</li>
</ol>
<p>O conjunto final de símbolos <em>NULLABLE</em> para esta gramática é <code>{ S, A, B, C, D }</code>.</p>
</section>
<section id="algoritmo-para-criação-do-conjunto-nullable" class="level4" data-number="6.4.1.3">
<h4 data-number="6.4.1.3" class="anchored" data-anchor-id="algoritmo-para-criação-do-conjunto-nullable"><span class="header-section-number">6.4.1.3</span> Algoritmo para Criação do Conjunto NULLABLE</h4>
<p>O algoritmo abaixo assume que a gramática é representada por um dicionário, no qual cada chave é um não-terminal e o valor é uma lista de produções, sendo cada produção uma lista de símbolos.</p>
<pre class="pseudo"><code>função calcular_NULLABLE(gramatica):
    // gramatica é um dicionário: { 'A': [['Y1', 'Y2'], ['ε']], ... }
    NULLABLE = conjunto vazio
    
    // 1. Regra Base: Adiciona não-terminais que derivam ε diretamente.
    para cada não-terminal A em gramatica:
        para cada produção P nas alternativas de A:
            se P é ['EPSILON']:
                adicionar A em NULLABLE

    // 2. Regra de Indução: Itera até que nenhuma nova adição seja feita.
    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        para cada não-terminal A em gramatica:
            se A não está em NULLABLE:
                para cada produção P = [Y1, Y2, ..., Yn] nas alternativas de A:
                    
                    // Verifica se todos os símbolos na produção P já são NULLABLE.
                    todos_simbolos_sao_nullable = verdadeiro
                    para cada simbolo Yk em P:
                        se Yk não está em NULLABLE:
                            todos_simbolos_sao_nullable = falso
                            quebrar // Interrompe a verificação desta produção
                    
                    // Se todos eram NULLABLE, então A também é.
                    se todos_simbolos_sao_nullable:
                        adicionar A em NULLABLE
                        mudou = verdadeiro
                        quebrar // Já sabemos que A é NULLABLE, podemos passar para o próximo não-terminal.
    
    retornar NULLABLE</code></pre>
<p>Sobre este pseudocódigo podemos construir um código em Python. Porém, antes da esforçada leitora continuar de observar que ao transpor os conceitos teóricos para os algoritmos em Python, a representação muda de <span class="math inline">\(\varepsilon\)</span> para a string ‘EPSILON’. É importante esclarecer que essa não é uma contradição, mas sim uma adaptação necessária para a implementação. O símbolo <span class="math inline">\(\varepsilon\)</span> é universalmente aceito na teoria de linguagens formais e compiladores para representar a cadeia vazia.</p>
<p>Na prática, em um programa de computador que manipula regras de produção como texto, é necessário ter um marcador explícito para a produção vazia. Usar uma string vazia de fato (’‘) poderia levar a ambiguidades no processamento do código. Portanto, vamos adotar a string ’EPSILON’, para representar de forma inequívoca o conceito teórico de <span class="math inline">\(\varepsilon\)</span>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Código 1: Cálculo do conjunto NULLABLE</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcular_NULLABLE(gramatica: <span class="bu">dict</span>[<span class="bu">str</span>, <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">str</span>]]]) <span class="op">-&gt;</span> <span class="bu">set</span>[<span class="bu">str</span>]:</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcula o conjunto de não-terminais que podem derivar a cadeia vazia (ε).</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">        gramatica: Um dicionário representando a gramática.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">                   Ex: {'S': [['A', 'B']], 'A': [['a'], ['EPSILON']]}</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">        Um conjunto contendo os não-terminais que são NULLABLE.</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    NULLABLE <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Regra Base: Adiciona não-terminais com produções diretas para 'EPSILON'.</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nao_terminal, producoes <span class="kw">in</span> gramatica.items():</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> producao <span class="op">==</span> [<span class="st">'EPSILON'</span>]:</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>                NULLABLE.add(nao_terminal)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Regra de Indução: Itera até não haver mais mudanças.</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> mudou:</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        mudou <span class="op">=</span> <span class="va">False</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nao_terminal, producoes <span class="kw">in</span> gramatica.items():</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nao_terminal <span class="kw">not</span> <span class="kw">in</span> NULLABLE:</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Se a produção for vazia ou EPSILON, já foi tratada.</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="kw">not</span> producao <span class="kw">or</span> producao <span class="op">==</span> [<span class="st">'EPSILON'</span>]:</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">continue</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Verifica se todos os símbolos da produção são NULLABLE.</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>                    todos_sao_nullable <span class="op">=</span> <span class="bu">all</span>(simbolo <span class="kw">in</span> NULLABLE <span class="cf">for</span> simbolo <span class="kw">in</span> producao)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> todos_sao_nullable:</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>                        NULLABLE.add(nao_terminal)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>                        mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Otimização: Se A se tornou NULLABLE por uma de suas produções,</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># podemos parar de verificar as outras produções de A nesta iteração.</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">break</span> </span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULLABLE</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Exemplo de uso com a estrutura de dados robusta</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>gramatica_exemplo <span class="op">=</span> {</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    <span class="st">'S'</span>: [[<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>]],</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    <span class="st">'A'</span>: [[<span class="st">'a'</span>], [<span class="st">'EPSILON'</span>]],</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    <span class="st">'B'</span>: [[<span class="st">'C'</span>, <span class="st">'D'</span>]],</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="st">'C'</span>: [[<span class="st">'c'</span>], [<span class="st">'EPSILON'</span>]],</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    <span class="st">'D'</span>: [[<span class="st">'A'</span>]]</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>nullable_set <span class="op">=</span> calcular_NULLABLE(gramatica_exemplo)</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Conjunto NULLABLE: </span><span class="sc">{</span><span class="bu">sorted</span>(<span class="bu">list</span>(nullable_set))<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Saída esperada: Conjunto NULLABLE: ['A', 'B', 'C', 'D', 'S']</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="o-conjunto-first" class="level3" data-number="6.4.2">
<h3 data-number="6.4.2" class="anchored" data-anchor-id="o-conjunto-first"><span class="header-section-number">6.4.2</span> O Conjunto FIRST</h3>
<p>O conjunto <span class="math inline">\(FIRST\)</span> de um símbolo não-terminal é o conjunto de todos os terminais que podem aparecer no início de qualquer <em>string</em> derivada desse símbolo, incluindo o símbolo vazio (<span class="math inline">\(\varepsilon\)</span>) se o não-terminal for <em>NULLABLE</em>. Para os símbolos terminais, o elemento do conjunto <span class="math inline">\(FIRST\)</span> será o próprio símbolo terminal.</p>
<section id="regras-de-criação-do-conjunto-first" class="level4" data-number="6.4.2.1">
<h4 data-number="6.4.2.1" class="anchored" data-anchor-id="regras-de-criação-do-conjunto-first"><span class="header-section-number">6.4.2.1</span> Regras de Criação do Conjunto FIRST</h4>
<p>Para definir o conjunto <span class="math inline">\(FIRST(X)\)</span> para todos os símbolos <span class="math inline">\(X\)</span> de uma gramática, assumindo que o conjunto <span class="math inline">\(NULLABLE\)</span> já foi previamente calculado, podemos seguir os seguintes passos de forma iterativa:</p>
<ol type="1">
<li><p><strong>Para símbolos terminais</strong>: o conjunto <span class="math inline">\(FIRST\)</span> é o próprio símbolo terminal. Ou seja, se <span class="math inline">\(a\)</span> é um terminal, então <span class="math inline">\(FIRST(a) = \{a\}\)</span>.</p></li>
<li><p><strong>Para um símbolo não-terminal</strong> <span class="math inline">\(X\)</span>: olhe para cada regra de produção <span class="math inline">\(X \rightarrow Y_1 Y_2 ... Y_n\)</span> e siga as seguintes regras:</p>
<ul>
<li>Adicione a <span class="math inline">\(FIRST(X)\)</span> todos os símbolos de <span class="math inline">\(FIRST(Y_1)\)</span>, exceto <span class="math inline">\(\varepsilon\)</span>.</li>
<li>Se <span class="math inline">\(Y_1\)</span> é <em>NULLABLE</em>, adicione a <span class="math inline">\(FIRST(X)\)</span> todos os símbolos de <span class="math inline">\(FIRST(Y_2)\)</span>, exceto <span class="math inline">\(\varepsilon\)</span>.</li>
<li>Continue este processo: se todos os símbolos de <span class="math inline">\(Y_1\)</span> até <span class="math inline">\(Y_{k-1}\)</span> são <em>NULLABLE</em>, adicione a <span class="math inline">\(FIRST(X)\)</span> todos os símbolos de <span class="math inline">\(FIRST(Y_k)\)</span>, exceto <span class="math inline">\(\varepsilon\)</span>. O processo para no primeiro símbolo <span class="math inline">\(Y_k\)</span> que não for <em>NULLABLE</em>.</li>
</ul></li>
</ol>
<p><strong>O símbolo vazio</strong> <span class="math inline">\(\varepsilon\)</span> pertence ao conjunto <span class="math inline">\(FIRST(X)\)</span> se, e somente se, <span class="math inline">\(X\)</span> pertence ao conjunto <span class="math inline">\(NULLABLE\)</span>.</p>
<p>Repita esses passos até que os conjuntos <span class="math inline">\(FIRST\)</span> de todos os símbolos não-terminais não possam ser alterados.</p>
</section>
<section id="exemplo-1-criação-de-conjuntos-first" class="level4" data-number="6.4.2.2">
<h4 data-number="6.4.2.2" class="anchored" data-anchor-id="exemplo-1-criação-de-conjuntos-first"><span class="header-section-number">6.4.2.2</span> Exemplo 1: Criação de Conjuntos FIRST</h4>
<p>Para ilustrar a aplicação destas regras e a importância do conjunto <span class="math inline">\(NULLABLE\)</span>, considere a gramática definida pelo seguinte conjunto de regras de produção:</p>
<p><span class="math display">\[
\begin{array}{ll}
1. &amp; S \rightarrow A B \\
2. &amp; A \rightarrow a \mid \varepsilon \\
3. &amp; B \rightarrow b \\
\end{array}
\]</span></p>
<p>Primeiro, identificamos o conjunto <span class="math inline">\(NULLABLE\)</span> para esta gramática. Pela regra <span class="math inline">\(A \rightarrow \varepsilon\)</span>, concluímos que <span class="math inline">\(NULLABLE = \{A\}\)</span>.</p>
<p>Com base nisso, o conjunto de regras de produção permite criar a seguinte tabela:</p>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Símbolo</th>
<th style="text-align: left;">FIRST</th>
<th style="text-align: left;">Explicação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>A</strong></td>
<td style="text-align: left;"><span class="math inline">\(\{a, \varepsilon\}\)</span></td>
<td style="text-align: left;">Da produção <span class="math inline">\(A \rightarrow a\)</span>, adicionamos ‘a’. Como <span class="math inline">\(A\)</span> é <em>NULLABLE</em>, adicionamos <span class="math inline">\(\varepsilon\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>B</strong></td>
<td style="text-align: left;"><span class="math inline">\(\{b\}\)</span></td>
<td style="text-align: left;">Da produção <span class="math inline">\(B \rightarrow b\)</span>, o único terminal que pode iniciar a derivação é ‘b’.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>S</strong></td>
<td style="text-align: left;"><span class="math inline">\(\{a, b\}\)</span></td>
<td style="text-align: left;">Para a produção <span class="math inline">\(S \rightarrow A B\)</span>: <br> 1. Analisamos <span class="math inline">\(A\)</span> e adicionamos <span class="math inline">\(FIRST(A) - \{\varepsilon\}\)</span>, que resulta em <span class="math inline">\(\{a\}\)</span>. <br> 2. Como <span class="math inline">\(A\)</span> é <em>NULLABLE</em>, continuamos a análise para o próximo símbolo, <span class="math inline">\(B\)</span>. <br> 3. Adicionamos <span class="math inline">\(FIRST(B)\)</span>, que é <span class="math inline">\(\{b\}\)</span>. Como <span class="math inline">\(B\)</span> não é <em>NULLABLE</em>, o processo para.</td>
</tr>
</tbody>
</table>
<p>Logo: <span class="math inline">\(FIRST =\{(S,\{a, b\}),(A,\{a, \varepsilon\}),(B,\{b\})\}}\)</span>, um conjunto de tuplas.</p>
<p>Agora que entendemos o algoritmo e sua dependência do conjunto <span class="math inline">\(NULLABLE\)</span>, podemos formalizá-lo.</p>
</section>
<section id="algoritmo-para-calcular-o-conjunto-first" class="level4" data-number="6.4.2.3">
<h4 data-number="6.4.2.3" class="anchored" data-anchor-id="algoritmo-para-calcular-o-conjunto-first"><span class="header-section-number">6.4.2.3</span> Algoritmo para calcular o conjunto FIRST</h4>
<pre class="pseudo"><code>#### Algoritmo para calcular o conjunto FIRST (Revisado)

função calcular_FIRST(gramatica, NULLABLE):
    // gramatica é um dicionário, NULLABLE é um conjunto
    FIRST = {}
    para cada não-terminal N em gramatica:
        FIRST[N] = conjunto vazio
    
    // Adiciona ε ao FIRST de todos os não-terminais que são NULLABLE.
    para cada N em NULLABLE:
        adicionar 'EPSILON' em FIRST[N]

    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        para cada não-terminal A em gramatica:
            para cada produção P = [Y1, Y2, ..., Yn] nas alternativas de A:
                para cada simbolo Yk em P:
                    // Se Yk é um terminal
                    se Yk não é um não-terminal:
                        se Yk não está em FIRST[A]:
                            adicionar Yk em FIRST[A]
                            mudou = verdadeiro
                        quebrar // Para a análise desta produção
                    
                    // Se Yk é um não-terminal
                    else:
                        // Adiciona FIRST[Yk] - {ε} ao FIRST[A]
                        tamanho_anterior = tamanho(FIRST[A])
                        FIRST[A] = união(FIRST[A], FIRST[Yk] - {'EPSILON'})
                        se tamanho(FIRST[A]) &gt; tamanho_anterior:
                            mudou = verdadeiro
                        
                        // Se Yk não é NULLABLE, para a análise desta produção
                        se Yk não está em NULLABLE:
                            quebrar
    retornar FIRST</code></pre>
<p>Código em Python para <span class="math inline">\(FIRST\)</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Código 2: Cálculo do conjunto FIRST   </span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcular_FIRST(gramatica: <span class="bu">dict</span>, nao_terminais: <span class="bu">set</span>, NULLABLE: <span class="bu">set</span>) <span class="op">-&gt;</span> <span class="bu">dict</span>:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcula o conjunto FIRST para todos os não-terminais, usando a estrutura de dicionário.</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    FIRST <span class="op">=</span> {nt: <span class="bu">set</span>() <span class="cf">for</span> nt <span class="kw">in</span> nao_terminais}</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nt <span class="kw">in</span> NULLABLE:</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        FIRST[nt].add(<span class="st">'EPSILON'</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> mudou:</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        mudou <span class="op">=</span> <span class="va">False</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nt_head, producoes <span class="kw">in</span> gramatica.items():</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> simbolo <span class="kw">in</span> producao:</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> simbolo <span class="op">==</span> <span class="st">'EPSILON'</span>:</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">continue</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Se o símbolo é um terminal</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> nao_terminais:</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> FIRST[nt_head]:</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>                            FIRST[nt_head].add(simbolo)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>                            mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">break</span>  <span class="co"># interrompe a análise aqui</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Se o símbolo é um não-terminal</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>                        tamanho_anterior <span class="op">=</span> <span class="bu">len</span>(FIRST[nt_head])</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>                        FIRST[nt_head].update(FIRST[simbolo] <span class="op">-</span> {<span class="st">'EPSILON'</span>})</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> <span class="bu">len</span>(FIRST[nt_head]) <span class="op">&gt;</span> tamanho_anterior:</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>                            mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> NULLABLE:</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">break</span>  <span class="co"># interrompe a análise aqui</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FIRST</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="o-conjunto-follow" class="level3" data-number="6.4.3">
<h3 data-number="6.4.3" class="anchored" data-anchor-id="o-conjunto-follow"><span class="header-section-number">6.4.3</span> O Conjunto FOLLOW</h3>
<p>O conjunto <span class="math inline">\(FOLLOW\)</span> de um símbolo não-terminal é o conjunto de terminais que podem aparecer imediatamente à direita (após, <em>follow</em>) desse não-terminal em alguma forma sentencial derivada, <strong>ou o símbolo de fim de entrada ($) se o não-terminal puder aparecer no final de uma forma sentencial</strong>.</p>
<p>Para definir o conjunto <span class="math inline">\(FOLLOW(A)\)</span> para cada não-terminal <span class="math inline">\(A\)</span>, assumindo que os conjuntos <span class="math inline">\(NULLABLE\)</span> e <span class="math inline">\(FIRST\)</span> já foram calculados, aplicamos as seguintes regras de forma iterativa até que os conjuntos <span class="math inline">\(FOLLOW\)</span> não mudem mais:</p>
<ol type="1">
<li><p><strong>Regra do Símbolo Inicial</strong>: Coloque o símbolo de fim de entrada ($$$) no conjunto <span class="math inline">\(FOLLOW\)</span> do símbolo inicial da gramática.</p></li>
<li><p><strong>Regra das Produções</strong>: Para cada produção da forma <span class="math inline">\(A \rightarrow \alpha B \beta\)</span> na gramática, na qual <span class="math inline">\(B\)</span> é um não-terminal e <span class="math inline">\(\alpha\)</span> e <span class="math inline">\(\beta\)</span> são sequências de símbolos quaisquer:</p>
<ol type="a">
<li>Adicione todos os símbolos do conjunto <span class="math inline">\(FIRST(\beta)\)</span> ao conjunto <span class="math inline">\(FOLLOW(B)\)</span>, exceto por <span class="math inline">\(\varepsilon\)</span>.</li>
<li>Se a sequência <span class="math inline">\(\beta\)</span> for <em>NULLABLE</em> (ou seja, todos os símbolos em <span class="math inline">\(\beta\)</span> pertencem ao conjunto <span class="math inline">\(NULLABLE\)</span>) ou se <span class="math inline">\(\beta\)</span> for vazia, então adicione todos os símbolos do conjunto <span class="math inline">\(FOLLOW(A)\)</span> ao conjunto <span class="math inline">\(FOLLOW(B)\)</span>.</li>
</ol></li>
</ol>
<p>A longa explicação para a primeira regra é que, ao colocar o símbolo de fim de entrada ($) no <span class="math inline">\(FOLLOW\)</span> do símbolo inicial da gramática, garantimos que o analisador sintático reconheça a última derivação da gramática como válida. Isso significa que o analisador estará preparado para encontrar o símbolo (<span class="math inline">\() ao final da string de entrada, indicando que a análise foi concluída com sucesso. Em outras palavras, o símbolo (\)</span>) no <span class="math inline">\(FOLLOW\)</span> do símbolo inicial representa a expectativa de que a string de entrada seja completamente processada e que não existam símbolos após a última derivada.</p>
<p><strong>Exemplo</strong>: Para ilustrar todas as regras, incluindo a interação com os conjuntos <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(NULLABLE\)</span>, vamos usar uma nova gramática:</p>
<p><span class="math display">\[
\begin{array}{ll}
1. &amp; S \rightarrow A B C \\
2. &amp; A \rightarrow a \\
3. &amp; B \rightarrow b \mid \varepsilon \\
4. &amp; C \rightarrow c
\end{array}
\]</span></p>
<p><strong>Conjuntos Prévios</strong>:</p>
<ul>
<li><span class="math inline">\(NULLABLE\)</span>: Apenas <span class="math inline">\(B\)</span> é <em>NULLABLE</em> devido à produção <span class="math inline">\(B \rightarrow \varepsilon\)</span>. Logo, <span class="math inline">\(NULLABLE = \{B\}\)</span>.</li>
<li><span class="math inline">\(FIRST\)</span>:
<ul>
<li><span class="math inline">\(FIRST(A) = \{a\}\)</span></li>
<li><span class="math inline">\(FIRST(B) = \{b, \varepsilon\}\)</span></li>
<li><span class="math inline">\(FIRST(C) = \{c\}\)</span></li>
<li><span class="math inline">\(FIRST(S) = \{a\}\)</span> (Pois <span class="math inline">\(FIRST(A)\)</span> é <span class="math inline">\(\{a\}\)</span> e <span class="math inline">\(A\)</span> não é <em>NULLABLE</em>)</li>
</ul></li>
</ul>
<p><strong>Cálculo do Conjunto FOLLOW</strong>:</p>
<p>Vamos aplicar as regras passo a passo:</p>
<ol type="1">
<li><p><strong>Inicialização</strong>: Pela Regra 1, adicionamos $$$ ao <span class="math inline">\(FOLLOW\)</span> do símbolo inicial, <span class="math inline">\(S\)</span>.</p>
<ul>
<li><span class="math inline">\(FOLLOW(S) = \{\)</span>}$</li>
</ul></li>
<li><p><strong>Análise da Produção</strong> <span class="math inline">\(S \rightarrow A B C\)</span>:</p>
<ol type="a">
<li><strong>Para</strong> <span class="math inline">\(FOLLOW(A)\)</span>: O não-terminal <span class="math inline">\(A\)</span> é seguido pela sequência <span class="math inline">\(\beta = BC\)</span>.</li>
</ol>
<ul>
<li>Adicionamos <span class="math inline">\(FIRST(BC)\)</span> a <span class="math inline">\(FOLLOW(A)\)</span>. Para encontrar <span class="math inline">\(FIRST(BC)\)</span>, olhamos <span class="math inline">\(FIRST(B)\)</span>, que é <span class="math inline">\(\{b, \varepsilon\}\)</span>. Adicionamos ‘b’. Como <span class="math inline">\(B\)</span> é <em>NULLABLE</em>, olhamos para o próximo símbolo, <span class="math inline">\(C\)</span>, e adicionamos <span class="math inline">\(FIRST(C)\)</span>, que é <span class="math inline">\(\{c\}\)</span>.</li>
<li>Portanto, <span class="math inline">\(FIRST(BC) = \{b, c\}\)</span>. Adicionamos isso a <span class="math inline">\(FOLLOW(A)\)</span>.</li>
<li><span class="math inline">\(FOLLOW(A) = \{b, c\}\)</span></li>
</ul>
<ol start="2" type="a">
<li><strong>Para</strong> <span class="math inline">\(FOLLOW(B)\)</span>: O não-terminal <span class="math inline">\(B\)</span> é seguido pela sequência <span class="math inline">\(\beta = C\)</span>.</li>
</ol>
<ul>
<li>Adicionamos <span class="math inline">\(FIRST(C)\)</span> a <span class="math inline">\(FOLLOW(B)\)</span>. <span class="math inline">\(FIRST(C)\)</span> é <span class="math inline">\(\{c\}\)</span>.</li>
<li>A sequência <span class="math inline">\(C\)</span> não é <em>NULLABLE</em>, então não aplicamos a segunda parte da regra.</li>
<li><span class="math inline">\(FOLLOW(B) = \{c\}\)</span></li>
</ul>
<ol start="3" type="a">
<li><strong>Para</strong> <span class="math inline">\(FOLLOW(C)\)</span>: O não-terminal <span class="math inline">\(C\)</span> está no final da produção, então a sequência <span class="math inline">\(\beta\)</span> é vazia.</li>
</ol>
<ul>
<li>Como <span class="math inline">\(\beta\)</span> é vazia, adicionamos <span class="math inline">\(FOLLOW(S)\)</span> a <span class="math inline">\(FOLLOW(C)\)</span>.</li>
<li><span class="math inline">\(FOLLOW(C) = \{\)</span>}$</li>
</ul></li>
</ol>
<p>O conjunto resultante será:</p>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Símbolo</th>
<th style="text-align: left;">FOLLOW</th>
<th style="text-align: left;">Explicação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>S</strong></td>
<td style="text-align: left;">${ $ }$</td>
<td style="text-align: left;">É o símbolo inicial (Regra 1).</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>A</strong></td>
<td style="text-align: left;"><span class="math inline">\(\{ b, c \}\)</span></td>
<td style="text-align: left;">É seguido por <span class="math inline">\(BC\)</span> na regra <span class="math inline">\(S \rightarrow ABC\)</span>. <span class="math inline">\(FOLLOW(A)\)</span> recebe <span class="math inline">\(FIRST(BC)\)</span>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>B</strong></td>
<td style="text-align: left;"><span class="math inline">\(\{ c \}\)</span></td>
<td style="text-align: left;">É seguido por <span class="math inline">\(C\)</span> na regra <span class="math inline">\(S \rightarrow ABC\)</span>. <span class="math inline">\(FOLLOW(B)\)</span> recebe <span class="math inline">\(FIRST(C)\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>C</strong></td>
<td style="text-align: left;">${ $ }$</td>
<td style="text-align: left;">Está no final da regra <span class="math inline">\(S \rightarrow ABC\)</span>. <span class="math inline">\(FOLLOW(C)\)</span> herda <span class="math inline">\(FOLLOW(S)\)</span>.</td>
</tr>
</tbody>
</table>
</section>
<section id="algoritmo-para-calcular-o-conjunto-follow-versão-revisada" class="level3" data-number="6.4.4">
<h3 data-number="6.4.4" class="anchored" data-anchor-id="algoritmo-para-calcular-o-conjunto-follow-versão-revisada"><span class="header-section-number">6.4.4</span> Algoritmo para calcular o conjunto FOLLOW (Versão Revisada)</h3>
<p>Com os conjuntos <code>NULLABLE</code> e <code>FIRST</code> em mãos, podemos finalmente calcular o conjunto <code>FOLLOW</code>. A seguir estão os pseudocódigos e a implementação final em Python, ambos utilizando a estrutura de dados de dicionário para manter a consistência.</p>
<section id="pseudocódigo-da-função-auxiliar-calcular_first_da_sequencia" class="level4" data-number="6.4.4.1">
<h4 data-number="6.4.4.1" class="anchored" data-anchor-id="pseudocódigo-da-função-auxiliar-calcular_first_da_sequencia"><span class="header-section-number">6.4.4.1</span> Pseudocódigo da Função Auxiliar: <code>calcular_first_da_sequencia</code></h4>
<p>Para calcular <code>FOLLOW</code>, precisamos de uma função auxiliar que calcule o conjunto <code>FIRST</code> de uma sequência arbitrária de símbolos (ex: <code>FIRST(B C D)</code>), o que é um pouco diferente de calcular o <code>FIRST</code> de um único símbolo.</p>
<pre class="pseudo"><code>### Algoritmo para calcular o conjunto FOLLOW (Versão Revisada)

Com os conjuntos `NULLABLE` e `FIRST` em mãos, podemos finalmente calcular o conjunto `FOLLOW`. A seguir estão os pseudocódigos e a implementação final em Python, ambos utilizando a estrutura de dados de dicionário para manter a consistência.

#### Pseudocódigo da Função Auxiliar: `calcular_first_da_sequencia`

Para calcular `FOLLOW`, precisamos de uma função auxiliar que calcule o conjunto `FIRST` de uma sequência arbitrária de símbolos (ex: `FIRST(B C D)`), o que é um pouco diferente de calcular o `FIRST` de um único símbolo.

```pseudo
função calcular_first_da_sequencia(sequencia, FIRST, NULLABLE, nao_terminais):
    // sequencia é uma lista de símbolos, ex: ['B', 'C']
    first_da_sequencia = conjunto vazio

    para cada simbolo S na sequencia:
        // Se S é um terminal, adiciona-o e para.
        se S não está em nao_terminais:
            adicionar S em first_da_sequencia
            retornar first_da_sequencia // Fim da análise para esta sequência

        // Se S é um não-terminal, adiciona seu FIRST (sem EPSILON)
        adicionar (FIRST[S] - {'EPSILON'}) em first_da_sequencia

        // Se S não pode ser vazio, a análise da sequência para aqui.
        se S não está em NULLABLE:
            retornar first_da_sequencia

    // Se o loop terminou, é porque todos os símbolos da sequência são NULLABLE.
    // Portanto, a própria sequência pode ser vazia.
    adicionar 'EPSILON' em first_da_sequencia
    retornar first_da_sequencia

função calcular_FOLLOW(gramatica, simbolo_inicial, nao_terminais, FIRST, NULLABLE):
    FOLLOW = {}
    para cada N em nao_terminais:
        FOLLOW[N] = conjunto vazio
    
    // Regra 1: Adiciona $ ao FOLLOW do símbolo inicial.
    adicionar '$' em FOLLOW[simbolo_inicial]

    mudou = verdadeiro
    enquanto mudou:
        mudou = falso
        // Itera sobre cada produção da gramática
        para cada não-terminal A e suas produções em gramatica:
            para cada produção P = [Y1, Y2, ..., Yn]:
                // Itera sobre cada símbolo da produção
                para i de 0 até tamanho(P) - 1:
                    B = P[i]
                    se B é um não-terminal:
                        beta = o restante da produção após B, ou seja, P[i+1:]
                        
                        // Regra 2.a: Adicionar FIRST(beta) a FOLLOW(B)
                        se beta não é vazio:
                            first_beta = calcular_first_da_sequencia(beta, ...)
                            
                            tamanho_anterior = tamanho(FOLLOW[B])
                            adicionar (first_beta - {'EPSILON'}) em FOLLOW[B]
                            se tamanho(FOLLOW[B]) &gt; tamanho_anterior:
                                mudou = verdadeiro

                            // Regra 2.b: Se beta pode ser vazio, adicionar FOLLOW(A) a FOLLOW(B)
                            se 'EPSILON' está em first_beta:
                                tamanho_anterior = tamanho(FOLLOW[B])
                                adicionar FOLLOW[A] em FOLLOW[B]
                                se tamanho(FOLLOW[B]) &gt; tamanho_anterior:
                                    mudou = verdadeiro
                        
                        // Regra 2.b (caso alternativo): Se não há nada após B
                        senão:
                            tamanho_anterior = tamanho(FOLLOW[B])
                            adicionar FOLLOW[A] em FOLLOW[B]
                            se tamanho(FOLLOW[B]) &gt; tamanho_anterior:
                                mudou = verdadeiro
    
    retornar FOLLOW</code></pre>
<p>Em Python, teremos:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Código 3: Cálculo do conjunto FOLLOW </span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcular_first_da_sequencia(</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    sequencia: <span class="bu">list</span>[<span class="bu">str</span>],</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    FIRST: <span class="bu">dict</span>[<span class="bu">str</span>, <span class="bu">set</span>],</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    NULLABLE: <span class="bu">set</span>[<span class="bu">str</span>],</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    nao_terminais: <span class="bu">set</span>[<span class="bu">str</span>]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">set</span>[<span class="bu">str</span>]:</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcula o conjunto FIRST de uma sequência de símbolos.</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    first_seq <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> simbolo <span class="kw">in</span> sequencia:</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> nao_terminais:  <span class="co"># É terminal</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            first_seq.add(simbolo)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> first_seq</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:  <span class="co"># É não-terminal</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            first_seq.update(FIRST[simbolo] <span class="op">-</span> {<span class="st">'EPSILON'</span>})</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> simbolo <span class="kw">not</span> <span class="kw">in</span> NULLABLE:</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> first_seq</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Se o loop terminou, todos os símbolos da sequência são NULLABLE.</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    first_seq.add(<span class="st">'EPSILON'</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> first_seq</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calcular_FOLLOW(</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    gramatica: <span class="bu">dict</span>[<span class="bu">str</span>, <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">str</span>]]],</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    simbolo_inicial: <span class="bu">str</span>,</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    nao_terminais: <span class="bu">set</span>[<span class="bu">str</span>],</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    FIRST: <span class="bu">dict</span>[<span class="bu">str</span>, <span class="bu">set</span>],</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    NULLABLE: <span class="bu">set</span>[<span class="bu">str</span>]</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">dict</span>[<span class="bu">str</span>, <span class="bu">set</span>]:</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcula o conjunto FOLLOW para todos os não-terminais, usando a estrutura de dicionário.</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    FOLLOW <span class="op">=</span> {nt: <span class="bu">set</span>() <span class="cf">for</span> nt <span class="kw">in</span> nao_terminais}</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    FOLLOW[simbolo_inicial].add(<span class="st">'$'</span>)</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> mudou:</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>        mudou <span class="op">=</span> <span class="va">False</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nt_head, producoes <span class="kw">in</span> gramatica.items():</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> i, simbolo <span class="kw">in</span> <span class="bu">enumerate</span>(producao):</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> simbolo <span class="kw">in</span> nao_terminais:</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>                        beta <span class="op">=</span> producao[i<span class="op">+</span><span class="dv">1</span>:]</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Regra 2.a: Adicionar FIRST(beta) a FOLLOW(simbolo)</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> beta:</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>                            first_beta <span class="op">=</span> calcular_first_da_sequencia(beta, FIRST, NULLABLE, nao_terminais)</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>                            </span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>                            tamanho_anterior <span class="op">=</span> <span class="bu">len</span>(FOLLOW[simbolo])</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>                            FOLLOW[simbolo].update(first_beta <span class="op">-</span> {<span class="st">'EPSILON'</span>})</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> <span class="bu">len</span>(FOLLOW[simbolo]) <span class="op">&gt;</span> tamanho_anterior:</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>                                mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>                            </span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>                            <span class="co"># Regra 2.b: Se beta é NULLABLE, adicionar FOLLOW(head) a FOLLOW(simbolo)</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> <span class="st">'EPSILON'</span> <span class="kw">in</span> first_beta:</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>                                tamanho_anterior <span class="op">=</span> <span class="bu">len</span>(FOLLOW[simbolo])</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>                                FOLLOW[simbolo].update(FOLLOW[nt_head])</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>                                <span class="cf">if</span> <span class="bu">len</span>(FOLLOW[simbolo]) <span class="op">&gt;</span> tamanho_anterior:</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>                                    mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Regra 2.b (caso beta seja vazio): Adicionar FOLLOW(head) a FOLLOW(simbolo)</span></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">else</span>:</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>                            tamanho_anterior <span class="op">=</span> <span class="bu">len</span>(FOLLOW[simbolo])</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>                            FOLLOW[simbolo].update(FOLLOW[nt_head])</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> <span class="bu">len</span>(FOLLOW[simbolo]) <span class="op">&gt;</span> tamanho_anterior:</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>                                mudou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> FOLLOW</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="aplicando-as-regras-um-primeiro-exemplo" class="level3" data-number="6.4.5">
<h3 data-number="6.4.5" class="anchored" data-anchor-id="aplicando-as-regras-um-primeiro-exemplo"><span class="header-section-number">6.4.5</span> Aplicando as Regras: Um Primeiro Exemplo</h3>
<p>Para solidificar o entendimento, vamos aplicar as regras de construção em uma gramática simples e ideal, antes de partirmos para casos mais complexos.</p>
<p><strong>Exemplo 1</strong>: Considere a gramática definida pelo seguinte conjunto de regras de produção:</p>
<p><span class="math display">\[
\begin{array}{cc}
1. &amp; S \rightarrow aB \mid bA \\
2. &amp; A \rightarrow c \mid d \\
3. &amp; B \rightarrow e \mid f \\
\end{array}
\]</span></p>
<p>A partir deste conjunto de regras, como não há produções vazias, o cálculo dos conjuntos é direto.</p>
<p><strong>1. Conjunto</strong> <span class="math inline">\(FIRST\)</span>:</p>
<ul>
<li><span class="math inline">\(FIRST(S) = \{a, b\}\)</span></li>
<li><span class="math inline">\(FIRST(A) = \{c, d\}\)</span></li>
<li><span class="math inline">\(FIRST(B) = \{e, f\}\)</span></li>
</ul>
<p><strong>2. Conjunto</strong> <span class="math inline">\(FOLLOW\)</span>:</p>
<ul>
<li><span class="math inline">\(FOLLOW(S) = \{\$\}\)</span> (Símbolo inicial)</li>
<li><span class="math inline">\(FOLLOW(A) = \{\$\}\)</span> (Pois em <span class="math inline">\(S \rightarrow bA\)</span>, A herda o <span class="math inline">\(FOLLOW(S)\)</span>)</li>
<li><span class="math inline">\(FOLLOW(B) = \{\$\}\)</span> (Pois em <span class="math inline">\(S \rightarrow aB\)</span>, B herda o <span class="math inline">\(FOLLOW(S)\)</span>)</li>
</ul>
<p><strong>3. Construindo a Tabela</strong>: Como nenhuma produção deriva em <span class="math inline">\(\varepsilon\)</span>, apenas a <strong>Regra 1 (Regra do <code>FIRST</code>)</strong> será utilizada:</p>
<ul>
<li>Para <span class="math inline">\(S \rightarrow aB\)</span>: Como <span class="math inline">\(a\)</span> está em <span class="math inline">\(FIRST(aB)\)</span>, adicionamos <span class="math inline">\(S \rightarrow aB\)</span> em <code>Tabela[S, a]</code>.</li>
<li>Para <span class="math inline">\(S \rightarrow bA\)</span>: Como <span class="math inline">\(b\)</span> está em <span class="math inline">\(FIRST(bA)\)</span>, adicionamos <span class="math inline">\(S \rightarrow bA\)</span> em <code>Tabela[S, b]</code>.</li>
<li>Para <span class="math inline">\(A \rightarrow c\)</span>: Como <span class="math inline">\(c\)</span> está em <span class="math inline">\(FIRST(c)\)</span>, adicionamos <span class="math inline">\(A \rightarrow c\)</span> em <code>Tabela[A, c]</code>.</li>
<li>Para <span class="math inline">\(A \rightarrow d\)</span>: Como <span class="math inline">\(d\)</span> está em <span class="math inline">\(FIRST(d)\)</span>, adicionamos <span class="math inline">\(A \rightarrow d\)</span> em <code>Tabela[A, d]</code>.</li>
<li>Para <span class="math inline">\(B \rightarrow e\)</span>: Como <span class="math inline">\(e\)</span> está em <span class="math inline">\(FIRST(e)\)</span>, adicionamos <span class="math inline">\(B \rightarrow e\)</span> em <code>Tabela[B, e]</code>.</li>
<li>Para <span class="math inline">\(B \rightarrow f\)</span>: Como <span class="math inline">\(f\)</span> está em <span class="math inline">\(FIRST(f)\)</span>, adicionamos <span class="math inline">\(B \rightarrow f\)</span> em <code>Tabela[B, f]</code>.</li>
</ul>
<p>A Tabela de Derivação resultante é:</p>
<table class="table">
<colgroup>
<col style="width: 15%">
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 8%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Não-Terminal</th>
<th style="text-align: left;"><strong>a</strong></th>
<th style="text-align: left;"><strong>b</strong></th>
<th style="text-align: left;"><strong>c</strong></th>
<th style="text-align: left;"><strong>d</strong></th>
<th style="text-align: left;"><strong>e</strong></th>
<th style="text-align: left;"><strong>f</strong></th>
<th style="text-align: left;"><strong>$</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>S</strong></td>
<td style="text-align: left;"><span class="math inline">\(S \rightarrow aB\)</span></td>
<td style="text-align: left;"><span class="math inline">\(S \rightarrow bA\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>A</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(A \rightarrow c\)</span></td>
<td style="text-align: left;"><span class="math inline">\(A \rightarrow d\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>B</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(B \rightarrow e\)</span></td>
<td style="text-align: left;"><span class="math inline">\(B \rightarrow f\)</span></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Este exemplo é perfeito: para cada par (não-terminal, terminal) existe no máximo uma regra de produção. Infelizmente, quando estamos construindo linguagens livres de contexto para problemas reais, este não é o cenário mais comum, como veremos a seguir.</p>
</section>
</section>
<section id="o-exemplo-mais-comum-de-todos" class="level2" data-number="6.5">
<h2 data-number="6.5" class="anchored" data-anchor-id="o-exemplo-mais-comum-de-todos"><span class="header-section-number">6.5</span> O Exemplo Mais Comum de Todos</h2>
<p>O exemplo a seguir está em todos os sites, livros e aulas que eu já vi disponíveis na internet. É tão comum que não me dei ao trabalho de procurar sua origem. Meu instinto me diz que deve ser do <a href="https://amzn.to/4celnGt">livro do Aho</a>, mas não fui conferir. É um exemplo tão bom que deve ser do Aho. Enfim, vamos ao trabalho:</p>
<section id="gramática-original" class="level3" data-number="6.5.1">
<h3 data-number="6.5.1" class="anchored" data-anchor-id="gramática-original"><span class="header-section-number">6.5.1</span> Gramática Original</h3>
<p>Considere a gramática representada pelo conjunto de regras de produção a seguir:</p>
<p><span class="math display">\[
\begin{array}{ll}
1. &amp; S \rightarrow E \\
2. &amp; E \rightarrow E + T \mid T \\
3. &amp; T \rightarrow T * F \mid F \\
4. &amp; F \rightarrow (E) \mid id
\end{array}
\]</span></p>
<p>Antes de prosseguir, é fundamental que a atenta leitora note que existe um problema grave com a gramática acima: ela possui <strong>recursão à esquerda direta</strong> nas regras para os não-terminais <span class="math inline">\(E\)</span> e <span class="math inline">\(T\)</span>. Como vimos anteriormente, um <em>parser</em> <span class="math inline">\(LL(1)\)</span> não consegue lidar com esse tipo de regra, pois entraria em um laço infinito.</p>
<p>Para que possamos construir uma Tabela de Derivação <span class="math inline">\(LL(1)\)</span>, precisamos primeiro eliminar essa recursão. Faremos isso aplicando a técnica padrão de transformação.</p>
<p><strong>1. Eliminando a recursão em</strong> <span class="math inline">\(E \rightarrow E + T \mid T\)</span>:</p>
<ul>
<li>A regra está no formato <span class="math inline">\(A \rightarrow A\alpha \mid \beta\)</span>, na qual <span class="math inline">\(A=E\)</span>, <span class="math inline">\(\alpha = +T\)</span> e <span class="math inline">\(\beta = T\)</span>.</li>
<li>A transformamos em <span class="math inline">\(A \rightarrow \beta A'\)</span> e <span class="math inline">\(A' \rightarrow \alpha A' \mid \varepsilon\)</span>.</li>
<li>As novas regras são:
<ul>
<li><span class="math inline">\(E \rightarrow T E'\)</span></li>
<li><span class="math inline">\(E' \rightarrow + T E' \mid \varepsilon\)</span></li>
</ul></li>
</ul>
<p><strong>2. Eliminando a recursão em</strong> <span class="math inline">\(T \rightarrow T * F \mid F\)</span>:</p>
<ul>
<li>A regra está no formato <span class="math inline">\(A \rightarrow A\alpha \mid \beta\)</span>, na qual <span class="math inline">\(A=T\)</span>, <span class="math inline">\(\alpha = *F\)</span> e <span class="math inline">\(\beta = F\)</span>.</li>
<li>A transformamos em <span class="math inline">\(A \rightarrow \beta A'\)</span> e <span class="math inline">\(A' \rightarrow \alpha A' \mid \varepsilon\)</span>.</li>
<li>As novas regras são:
<ul>
<li><span class="math inline">\(T \rightarrow F T'\)</span></li>
<li><span class="math inline">\(T' \rightarrow * F T' \mid \varepsilon\)</span></li>
</ul></li>
</ul>
<p>Após as transformações, a gramática equivalente e adequada para a análise <span class="math inline">\(LL(1)\)</span> é:</p>
<p><span class="math display">\[
\begin{array}{ll}
1. &amp; S \rightarrow E \\
2. &amp; E \rightarrow T E' \\
3. &amp; E' \rightarrow + T E' \mid \varepsilon \\
4. &amp; T \rightarrow F T' \\
5. &amp; T' \rightarrow * F T' \mid \varepsilon \\
6. &amp; F \rightarrow (E) \mid id
\end{array}
\]</span></p>
<p>Com esta gramática correta, podemos agora calcular os conjuntos necessários.</p>
</section>
<section id="nullable" class="level3" data-number="6.5.2">
<h3 data-number="6.5.2" class="anchored" data-anchor-id="nullable"><span class="header-section-number">6.5.2</span> <span class="math inline">\(NULLABLE\)</span></h3>
<p>Analisando a nova gramática, identificamos quais não-terminais podem derivar a cadeia vazia (<span class="math inline">\(\varepsilon\)</span>).</p>
<ul>
<li><span class="math inline">\(E' \rightarrow \varepsilon\)</span>, portanto <span class="math inline">\(E'\)</span> é <em>NULLABLE</em>.</li>
<li><span class="math inline">\(T' \rightarrow \varepsilon\)</span>, portanto <span class="math inline">\(T'\)</span> é <em>NULLABLE</em>.</li>
<li><span class="math inline">\(S, E, T, F\)</span> não podem derivar <span class="math inline">\(\varepsilon\)</span> diretamente e suas produções sempre contêm símbolos que não são <em>NULLABLE</em>, então eles não são <em>NULLABLE</em>.</li>
</ul>
</section>
<section id="first" class="level3" data-number="6.5.3">
<h3 data-number="6.5.3" class="anchored" data-anchor-id="first"><span class="header-section-number">6.5.3</span> <span class="math inline">\(FIRST\)</span></h3>
<p>Vamos calcular o conjunto <span class="math inline">\(FIRST\)</span> para cada não-terminal da gramática corrigida.</p>
<ul>
<li><span class="math inline">\(FIRST(F)\)</span>: A partir de <span class="math inline">\(F \rightarrow (E) \mid id\)</span>, os primeiros terminais possíveis são <code>(</code> e <code>id</code>.
<ul>
<li><span class="math inline">\(FIRST(F) = \{ '(', id \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FIRST(T')\)</span>: A partir de <span class="math inline">\(T' \rightarrow * F T' \mid \varepsilon\)</span>, os primeiros símbolos são <code>*</code> ou a cadeia vazia.
<ul>
<li><span class="math inline">\(FIRST(T') = \{ '*', \varepsilon \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FIRST(T)\)</span>: A regra é <span class="math inline">\(T \rightarrow F T'\)</span>. O <span class="math inline">\(FIRST(T)\)</span> é igual ao <span class="math inline">\(FIRST(F)\)</span>.
<ul>
<li><span class="math inline">\(FIRST(T) = FIRST(F) = \{ '(', id \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FIRST(E')\)</span>: A partir de <span class="math inline">\(E' \rightarrow + T E' \mid \varepsilon\)</span>, os primeiros símbolos são <code>+</code> ou a cadeia vazia.
<ul>
<li><span class="math inline">\(FIRST(E') = \{ '+', \varepsilon \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FIRST(E)\)</span>: A regra é <span class="math inline">\(E \rightarrow T E'\)</span>. O <span class="math inline">\(FIRST(E)\)</span> é igual ao <span class="math inline">\(FIRST(T)\)</span>.
<ul>
<li><span class="math inline">\(FIRST(E) = FIRST(T) = \{ '(', id \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FIRST(S)\)</span>: A regra é <span class="math inline">\(S \rightarrow E\)</span>. O <span class="math inline">\(FIRST(S)\)</span> é igual ao <span class="math inline">\(FIRST(E)\)</span>.
<ul>
<li><span class="math inline">\(FIRST(S) = FIRST(E) = \{ '(', id \}\)</span></li>
</ul></li>
</ul>
</section>
<section id="follow" class="level3" data-number="6.5.4">
<h3 data-number="6.5.4" class="anchored" data-anchor-id="follow"><span class="header-section-number">6.5.4</span> <span class="math inline">\(FOLLOW\)</span></h3>
<p>Agora, calculamos o conjunto <span class="math inline">\(FOLLOW\)</span> para cada não-terminal.</p>
<ul>
<li><span class="math inline">\(FOLLOW(S)\)</span>: <span class="math inline">\(S\)</span> é o símbolo inicial, então iniciamos com o marcador de fim de entrada.
<ul>
<li>$FOLLOW(S) = { $ }$</li>
</ul></li>
<li><span class="math inline">\(FOLLOW(E)\)</span>:
<ul>
<li>Da regra <span class="math inline">\(S \rightarrow E\)</span>, <span class="math inline">\(E\)</span> está no final, então <span class="math inline">\(FOLLOW(E)\)</span> herda <span class="math inline">\(FOLLOW(S)\)</span>. $FOLLOW(E) = { $ }$.</li>
<li>Da regra <span class="math inline">\(F \rightarrow (E)\)</span>, o símbolo <code>)</code> segue <span class="math inline">\(E\)</span>. Adicionamos <code>)</code> ao <span class="math inline">\(FOLLOW(E)\)</span>.</li>
<li>$FOLLOW(E) = { <span class="math inline">\(, ')' \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FOLLOW(E')\)</span>: Da regra <span class="math inline">\(E \rightarrow T E'\)</span>, <span class="math inline">\(E'\)</span> está no final, então <span class="math inline">\(FOLLOW(E')\)</span> herda <span class="math inline">\(FOLLOW(E)\)</span>.
<ul>
<li>$FOLLOW(E’) = FOLLOW(E) = { <span class="math inline">\(, ')' \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FOLLOW(T)\)</span>:
<ul>
<li>Da regra <span class="math inline">\(E \rightarrow T E'\)</span>, <span class="math inline">\(T\)</span> é seguido por <span class="math inline">\(E'\)</span>. Adicionamos <span class="math inline">\(FIRST(E') - \{\varepsilon\}\)</span> ao <span class="math inline">\(FOLLOW(T)\)</span>. Isso adiciona <code>+</code>.</li>
<li>Como <span class="math inline">\(E'\)</span> é <em>NULLABLE</em>, também adicionamos <span class="math inline">\(FOLLOW(E)\)</span> ao <span class="math inline">\(FOLLOW(T)\)</span>.</li>
<li>$FOLLOW(T) = { ‘+’ } = { ‘+’, <span class="math inline">\(, ')' \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FOLLOW(T')\)</span>: Da regra <span class="math inline">\(T \rightarrow F T'\)</span>, <span class="math inline">\(T'\)</span> está no final, então <span class="math inline">\(FOLLOW(T')\)</span> herda <span class="math inline">\(FOLLOW(T)\)</span>.
<ul>
<li>$FOLLOW(T’) = FOLLOW(T) = { ‘+’, <span class="math inline">\(, ')' \}\)</span></li>
</ul></li>
<li><ul>
<li><span class="math inline">\(FOLLOW(F)\)</span>:
<ul>
<li>Analisamos todas as regras em que <span class="math inline">\(F\)</span> aparece no lado direito. A única regra relevante é <span class="math inline">\(T \rightarrow F T'\)</span>.</li>
<li><strong>Passo 1</strong>: O não-terminal <span class="math inline">\(F\)</span> é seguido pela sequência <span class="math inline">\(T'\)</span>. Aplicamos a regra que diz para adicionar <span class="math inline">\(FIRST(T') - \{\varepsilon\}\)</span> ao conjunto <span class="math inline">\(FOLLOW(F)\)</span>.
<ul>
<li>Sabemos que <span class="math inline">\(FIRST(T') = \{ '*', \varepsilon \}\)</span>.</li>
<li>Portanto, adicionamos <span class="math inline">\(\{ * \}\)</span> ao <span class="math inline">\(FOLLOW(F)\)</span>.</li>
</ul></li>
<li><strong>Passo 2</strong>: Como a sequência que segue <span class="math inline">\(F\)</span> (neste caso, <span class="math inline">\(T'\)</span>) é <em>NULLABLE</em>, devemos também adicionar o conjunto <span class="math inline">\(FOLLOW\)</span> do não-terminal que está à esquerda da produção, ou seja, <span class="math inline">\(FOLLOW(T)\)</span>, ao conjunto <span class="math inline">\(FOLLOW(F)\)</span>.
<ul>
<li>Sabemos que <span class="math inline">\(FOLLOW(T) = \{ '+', \$, ')' \}\)</span>.</li>
</ul></li>
<li><strong>Passo 3</strong>: O conjunto final para <span class="math inline">\(FOLLOW(F)\)</span> é a união dos resultados dos passos anteriores.
<ul>
<li><span class="math inline">\(FOLLOW(F) = (FIRST(T') - \{\varepsilon\}) \cup FOLLOW(T)\)</span></li>
<li><span class="math inline">\(FOLLOW(F) = \{ * \} \cup \{ '+', \$, ')' \}\)</span></li>
<li><span class="math inline">\(FOLLOW(F) = \{ '*', '+', \$, ')' \}\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="tabela-de-derivação-ll1" class="level3" data-number="6.5.5">
<h3 data-number="6.5.5" class="anchored" data-anchor-id="tabela-de-derivação-ll1"><span class="header-section-number">6.5.5</span> Tabela de Derivação <span class="math inline">\(LL(1)\)</span></h3>
<p>Com os conjuntos <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span> corretos, podemos construir a Tabela de Derivação. A construção da tabela segue um algoritmo preciso com duas regras principais, que utilizam os conjuntos que acabamos de calcular para preencher as células <code>Tabela[Não-Terminal, Terminal]</code>:</p>
<ol type="1">
<li><p><strong>Regra do</strong> <span class="math inline">\(FIRST\)</span>: Para cada produção da gramática, na forma <span class="math inline">\(A \rightarrow \alpha\)</span>: para cada símbolo terminal <strong>t</strong> que pertence a <span class="math inline">\(FIRST(\alpha)\)</span>, adicione a produção <span class="math inline">\(A \rightarrow \alpha\)</span> na célula <code>Tabela[A, t]</code>.</p></li>
<li><p><strong>Regra do</strong> <span class="math inline">\(FOLLOW\)</span>: Se <span class="math inline">\(\varepsilon\)</span> (a cadeia vazia) pertence a <span class="math inline">\(FIRST(\alpha)\)</span>: para cada símbolo terminal <strong>t</strong> (incluindo o marcador <strong>$</strong>) que pertence a <span class="math inline">\(FOLLOW(A)\)</span>, adicione a produção <span class="math inline">\(A \rightarrow \alpha\)</span> na célula <code>Tabela[A, t]</code>.</p></li>
</ol>
<p>Qualquer célula que permaneça vazia após a aplicação destas regras representará um erro sintático, indicando que a ocorrência daquele terminal é inesperada naquele ponto da análise. Assim, temos:</p>
<table class="table">
<colgroup>
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Não-Terminal</th>
<th style="text-align: left;"><strong>id</strong></th>
<th style="text-align: left;"><strong>+</strong></th>
<th style="text-align: left;"><strong>*</strong></th>
<th style="text-align: left;"><strong>(</strong></th>
<th style="text-align: left;"><strong>)</strong></th>
<th style="text-align: left;"><strong>$</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>S</strong></td>
<td style="text-align: left;"><span class="math inline">\(S \rightarrow E\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(S \rightarrow E\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>E</strong></td>
<td style="text-align: left;"><span class="math inline">\(E \rightarrow T E'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(E \rightarrow T E'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>E’</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(E' \rightarrow + T E'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(E' \rightarrow \varepsilon\)</span></td>
<td style="text-align: left;"><span class="math inline">\(E' \rightarrow \varepsilon\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>T</strong></td>
<td style="text-align: left;"><span class="math inline">\(T \rightarrow F T'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(T \rightarrow F T'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>T’</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(T' \rightarrow \varepsilon\)</span></td>
<td style="text-align: left;"><span class="math inline">\(T' \rightarrow * F T'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(T' \rightarrow \varepsilon\)</span></td>
<td style="text-align: left;"><span class="math inline">\(T' \rightarrow \varepsilon\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>F</strong></td>
<td style="text-align: left;"><span class="math inline">\(F \rightarrow id\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(F \rightarrow (E)\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</section>
<section id="processo-de-parser-testando-com-id-id-id" class="level3" data-number="6.5.6">
<h3 data-number="6.5.6" class="anchored" data-anchor-id="processo-de-parser-testando-com-id-id-id"><span class="header-section-number">6.5.6</span> Processo de Parser Testando com <span class="math inline">\(id + id * id\)</span></h3>
<p>Vamos agora rastrear a análise da <em>string</em> <code>id + id * id</code> usando a pilha, a entrada e a Tabela de Derivação corrigida em relação ao apontamento feito. A inconsistência estava no passo <code>T(T', +)</code>, no qual a tabela indica <code>T' -&gt; ε</code> (o que é o correto, pois <code>+</code> pertence ao <code>FOLLOW(T')</code>), e o rastreamento anterior poderia gerar dúvida. O rastreamento correto é o seguinte.</p>
<p><strong>Notação utilizada no rastreamento:</strong></p>
<ul>
<li><code>T(X, a)</code> significa “consultar a Tabela de Derivação na linha do não-terminal X e coluna do terminal a”;</li>
<li>Por exemplo, <code>T(S, id)</code> significa consultar a tabela na linha S, coluna id;</li>
<li>O resultado da consulta indica qual produção deve ser aplicada;</li>
<li>“Consumir” significa remover o símbolo tanto do topo da pilha quanto do início da entrada.</li>
</ul>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 24%">
<col style="width: 55%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Pilha</th>
<th style="text-align: left;">Entrada</th>
<th style="text-align: left;">Ação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>S $</code></td>
<td style="text-align: left;"><code>id + id * id $</code></td>
<td style="text-align: left;"><code>T(S, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>S -&gt; E</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>E $</code></td>
<td style="text-align: left;"><code>id + id * id $</code></td>
<td style="text-align: left;"><code>T(E, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>E -&gt; T E'</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>T E' $</code></td>
<td style="text-align: left;"><code>id + id * id $</code></td>
<td style="text-align: left;"><code>T(T, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>T -&gt; F T'</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>F T' E' $</code></td>
<td style="text-align: left;"><code>id + id * id $</code></td>
<td style="text-align: left;"><code>T(F, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>F -&gt; id</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>id T' E' $</code></td>
<td style="text-align: left;"><code>id + id * id $</code></td>
<td style="text-align: left;">Consumir <code>id</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>T' E' $</code></td>
<td style="text-align: left;"><code>+ id * id $</code></td>
<td style="text-align: left;"><code>T(T', +)</code> <span class="math inline">\(\rightarrow\)</span> <code>T' -&gt; ε</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>E' $</code></td>
<td style="text-align: left;"><code>+ id * id $</code></td>
<td style="text-align: left;"><code>T(E', +)</code> <span class="math inline">\(\rightarrow\)</span> <code>E' -&gt; + T E'</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>+ T E' $</code></td>
<td style="text-align: left;"><code>+ id * id $</code></td>
<td style="text-align: left;">Consumir <code>+</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>T E' $</code></td>
<td style="text-align: left;"><code>id * id $</code></td>
<td style="text-align: left;"><code>T(T, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>T -&gt; F T'</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>F T' E' $</code></td>
<td style="text-align: left;"><code>id * id $</code></td>
<td style="text-align: left;"><code>T(F, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>F -&gt; id</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>id T' E' $</code></td>
<td style="text-align: left;"><code>id * id $</code></td>
<td style="text-align: left;">Consumir <code>id</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>T' E' $</code></td>
<td style="text-align: left;"><code>* id $</code></td>
<td style="text-align: left;"><code>T(T', *)</code> <span class="math inline">\(\rightarrow\)</span> <code>T' -&gt; * F T'</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>* F T' E' $</code></td>
<td style="text-align: left;"><code>* id $</code></td>
<td style="text-align: left;">Consumir <code>*</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>F T' E' $</code></td>
<td style="text-align: left;"><code>id $</code></td>
<td style="text-align: left;"><code>T(F, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>F -&gt; id</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>id T' E' $</code></td>
<td style="text-align: left;"><code>id $</code></td>
<td style="text-align: left;">Consumir <code>id</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>T' E' $</code></td>
<td style="text-align: left;"><code>$</code></td>
<td style="text-align: left;"><code>T(T', $)</code> <span class="math inline">\(\rightarrow\)</span> <code>T' -&gt; ε</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>E' $</code></td>
<td style="text-align: left;"><code>$</code></td>
<td style="text-align: left;"><code>T(E', $)</code> <span class="math inline">\(\rightarrow\)</span> <code>E' -&gt; ε</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>$</code></td>
<td style="text-align: left;"><code>$</code></td>
<td style="text-align: left;"><strong>Aceita</strong></td>
</tr>
</tbody>
</table>
<p>Como foi possível consumir toda a <em>string</em> e esvaziar a pilha, a <em>string</em> <code>id + id * id</code> é aceita pela gramática.</p>
</section>
<section id="testando-com-a-string-id---id-id" class="level3" data-number="6.5.7">
<h3 data-number="6.5.7" class="anchored" data-anchor-id="testando-com-a-string-id---id-id"><span class="header-section-number">6.5.7</span> Testando com a <em>string</em> <span class="math inline">\(id - id * id\)</span></h3>
<p>Vamos analisar a <em>string</em> <code>id - id * id</code>. O processo inicial é o mesmo do exemplo anterior.</p>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Pilha</th>
<th style="text-align: left;">Entrada</th>
<th style="text-align: left;">Ação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>S $</code></td>
<td style="text-align: left;"><code>id - id * id $</code></td>
<td style="text-align: left;"><code>T(S, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>S \rightarrow E</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>E $</code></td>
<td style="text-align: left;"><code>id - id * id $</code></td>
<td style="text-align: left;"><code>T(E, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>E \rightarrow T E'</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>T E' $</code></td>
<td style="text-align: left;"><code>id - id * id $</code></td>
<td style="text-align: left;"><code>T(T, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>T \rightarrow F T'</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>F T' E' $</code></td>
<td style="text-align: left;"><code>id - id * id $</code></td>
<td style="text-align: left;"><code>T(F, id)</code> <span class="math inline">\(\rightarrow\)</span> <code>F \rightarrow id</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>id T' E' $</code></td>
<td style="text-align: left;"><code>id - id * id $</code></td>
<td style="text-align: left;">Consumir <code>id</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>T' E' $</code></td>
<td style="text-align: left;"><code>- id * id $</code></td>
<td style="text-align: left;"><code>T(T', -)</code> <span class="math inline">\(\rightarrow\)</span> <strong>Erro</strong></td>
</tr>
</tbody>
</table>
<p>A análise para. A célula da tabela para o não-terminal no topo da pilha (<code>T'</code>) e o símbolo de entrada (<code>-</code>) está vazia. Isso indica um erro sintático.</p>
<p>Portanto, a <em>string</em> <code>id - id * id</code> <strong>não faz parte da linguagem definida pela gramática fornecida</strong>. O que deveria ser óbvio, já que a gramática não tem regras para lidar com o símbolo <code>-</code>.</p>
<p>Vimos, com a mesma gramática, as duas situações possíveis: ou a <em>string</em> faz parte da linguagem, ou não. Simples assim.</p>
</section>
</section>
<section id="um-exemplo-nem-tão-comum" class="level2" data-number="6.6">
<h2 data-number="6.6" class="anchored" data-anchor-id="um-exemplo-nem-tão-comum"><span class="header-section-number">6.6</span> Um Exemplo Nem Tão Comum</h2>
<p>Este exemplo saiu das vozes da minha cabeça. Pode ser que exista em algum outro lugar, mas não me dei ao trabalho de verificar. É um exemplo que uso há muitos anos, em aula e já nem me preocupo com ele. Se souber a origem, fico grato.</p>
<section id="gramática-original-1" class="level3" data-number="6.6.1">
<h3 data-number="6.6.1" class="anchored" data-anchor-id="gramática-original-1"><span class="header-section-number">6.6.1</span> Gramática Original</h3>
<p>Considere a seguinte gramática para expressões booleanas (<span class="math inline">\(OR, AND, NOT\)</span>), definida pelo conjunto de regras de produção a seguir:</p>
<p><span class="math display">\[
\begin{array}{ll}
1. &amp; S \rightarrow B \\
2. &amp; B \rightarrow B \,\, OR \,\, M \mid M \\
3. &amp; M \rightarrow M \,\, AND \,\, N \mid N \\
4. &amp; N \rightarrow NOT \,\, N \mid (B) \,\mid id
\end{array}
\]</span></p>
</section>
<section id="corrigindo-a-recursão-à-esquerda" class="level3" data-number="6.6.2">
<h3 data-number="6.6.2" class="anchored" data-anchor-id="corrigindo-a-recursão-à-esquerda"><span class="header-section-number">6.6.2</span> Corrigindo a Recursão à Esquerda</h3>
<p>Assim como no exemplo anterior, esta gramática não é adequada para um <em>parser</em> <span class="math inline">\(LL(1)\)</span> por possuir <strong>recursão à esquerda direta</strong> nas regras dos não-terminais <span class="math inline">\(B\)</span> e <span class="math inline">\(M\)</span>. Para prosseguir, precisamos primeiro eliminar essa recursão.</p>
<p><strong>1. Eliminando a recursão em</strong> <span class="math inline">\(B \rightarrow B \,\, OR \,\, M \mid M\)</span>:</p>
<ul>
<li>A regra tem o formato <span class="math inline">\(A \rightarrow A\alpha \mid \beta\)</span>, na qual <span class="math inline">\(A=B\)</span>, <span class="math inline">\(\alpha = OR \,\, M\)</span> e <span class="math inline">\(\beta = M\)</span>.</li>
<li>A transformamos nas novas regras:
<ul>
<li><span class="math inline">\(B \rightarrow M B'\)</span>;</li>
<li><span class="math inline">\(B' \rightarrow OR \,\, M B' \mid \varepsilon\)</span>.</li>
</ul></li>
</ul>
<p><strong>2. Eliminando a recursão em</strong> <span class="math inline">\(M \rightarrow M \,\, AND \,\, N \mid N\)</span>:</p>
<ul>
<li>A regra tem o formato <span class="math inline">\(A \rightarrow A\alpha \mid \beta\)</span>, na qual <span class="math inline">\(A=M\)</span>, <span class="math inline">\(\alpha = AND \,\, N\)</span> e <span class="math inline">\(\beta = N\)</span>.</li>
<li>A transformamos nas novas regras:
<ul>
<li><span class="math inline">\(M \rightarrow N M'\)</span>;</li>
<li><span class="math inline">\(M' \rightarrow AND \,\, N M' \mid \varepsilon\)</span>.</li>
</ul></li>
</ul>
</section>
<section id="gramática-corrigida-pronta-para-ll1" class="level3" data-number="6.6.3">
<h3 data-number="6.6.3" class="anchored" data-anchor-id="gramática-corrigida-pronta-para-ll1"><span class="header-section-number">6.6.3</span> Gramática Corrigida (Pronta para LL(1))</h3>
<p>A gramática final, equivalente à original mas sem recursão à esquerda, é:</p>
<p><span class="math display">\[
\begin{array}{ll}
1. &amp; S \rightarrow B \\
2. &amp; B \rightarrow M B' \\
3. &amp; B' \rightarrow OR \,\, M B' \mid \varepsilon \\
4. &amp; M \rightarrow N M' \\
5. &amp; M' \rightarrow AND \,\, N M' \mid \varepsilon \\
6. &amp; N \rightarrow NOT \,\, N \\
7. &amp; N \rightarrow (B) \\
8. &amp; N \rightarrow id
\end{array}
\]</span></p>
<p>Com esta gramática corrigida, podemos prosseguir com os cálculos.</p>
</section>
<section id="nullable-1" class="level3" data-number="6.6.4">
<h3 data-number="6.6.4" class="anchored" data-anchor-id="nullable-1"><span class="header-section-number">6.6.4</span> <span class="math inline">\(NULLABLE\)</span></h3>
<ul>
<li><span class="math inline">\(B' \rightarrow \varepsilon\)</span>, portanto <span class="math inline">\(B'\)</span> é <em>NULLABLE</em>.</li>
<li><span class="math inline">\(M' \rightarrow \varepsilon\)</span>, portanto <span class="math inline">\(M'\)</span> é <em>NULLABLE</em>.</li>
<li>Nenhum outro não-terminal pode derivar a cadeia vazia.</li>
</ul>
</section>
<section id="first-1" class="level3" data-number="6.6.5">
<h3 data-number="6.6.5" class="anchored" data-anchor-id="first-1"><span class="header-section-number">6.6.5</span> <span class="math inline">\(FIRST\)</span></h3>
<ul>
<li><span class="math inline">\(FIRST(N)\)</span>: A partir das regras de <span class="math inline">\(N\)</span>, os primeiros terminais são <code>NOT</code>, <code>(</code> e <code>id</code>.
<ul>
<li><span class="math inline">\(FIRST(N) = \{ NOT, '(', id \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FIRST(M')\)</span>: A partir de <span class="math inline">\(M' \rightarrow AND \,\, N M' \mid \varepsilon\)</span>.
<ul>
<li><span class="math inline">\(FIRST(M') = \{ AND, \varepsilon \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FIRST(M)\)</span>: A regra é <span class="math inline">\(M \rightarrow N M'\)</span>. <span class="math inline">\(FIRST(M) = FIRST(N)\)</span>.
<ul>
<li><span class="math inline">\(FIRST(M) = \{ NOT, '(', id \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FIRST(B')\)</span>: A partir de <span class="math inline">\(B' \rightarrow OR \,\, M B' \mid \varepsilon\)</span>.
<ul>
<li><span class="math inline">\(FIRST(B') = \{ OR, \varepsilon \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FIRST(B)\)</span>: A regra é <span class="math inline">\(B \rightarrow M B'\)</span>. <span class="math inline">\(FIRST(B) = FIRST(M)\)</span>.
<ul>
<li><span class="math inline">\(FIRST(B) = \{ NOT, '(', id \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FIRST(S)\)</span>: A regra é <span class="math inline">\(S \rightarrow B\)</span>. <span class="math inline">\(FIRST(S) = FIRST(B)\)</span>.
<ul>
<li><span class="math inline">\(FIRST(S) = \{ NOT, '(', id \}\)</span></li>
</ul></li>
</ul>
</section>
<section id="follow-1" class="level3" data-number="6.6.6">
<h3 data-number="6.6.6" class="anchored" data-anchor-id="follow-1"><span class="header-section-number">6.6.6</span> <span class="math inline">\(FOLLOW\)</span></h3>
<ul>
<li><span class="math inline">\(FOLLOW(S)\)</span>: Símbolo inicial.
<ul>
<li>$FOLLOW(S) = { $ }$</li>
</ul></li>
<li><span class="math inline">\(FOLLOW(B)\)</span>:
<ul>
<li>Da regra <span class="math inline">\(S \rightarrow B\)</span>, <span class="math inline">\(FOLLOW(B)\)</span> herda <span class="math inline">\(FOLLOW(S)\)</span>, então $FOLLOW(B) = { $ }$.</li>
<li>Da regra <span class="math inline">\(N \rightarrow (B)\)</span>, o símbolo <code>)</code> segue <span class="math inline">\(B\)</span>.</li>
<li>$FOLLOW(B) = { <span class="math inline">\(, ')' \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FOLLOW(B')\)</span>: Da regra <span class="math inline">\(B \rightarrow M B'\)</span>, <span class="math inline">\(B'\)</span> está no final, então <span class="math inline">\(FOLLOW(B')\)</span> herda <span class="math inline">\(FOLLOW(B)\)</span>.
<ul>
<li>$FOLLOW(B’) = { <span class="math inline">\(, ')' \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FOLLOW(M)\)</span>:
<ul>
<li>Da regra <span class="math inline">\(B \rightarrow M B'\)</span>, <span class="math inline">\(M\)</span> é seguido por <span class="math inline">\(B'\)</span>. Adicionamos <span class="math inline">\(FIRST(B') - \{\varepsilon\}\)</span> ao <span class="math inline">\(FOLLOW(M)\)</span>, que é <span class="math inline">\(\{ OR \}\)</span>.</li>
<li>Como <span class="math inline">\(B'\)</span> é <em>NULLABLE</em>, também adicionamos <span class="math inline">\(FOLLOW(B)\)</span> ao <span class="math inline">\(FOLLOW(M)\)</span>.</li>
<li>$FOLLOW(M) = { OR } = { OR, <span class="math inline">\(, ')' \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FOLLOW(M')\)</span>: Da regra <span class="math inline">\(M \rightarrow N M'\)</span>, <span class="math inline">\(M'\)</span> está no final, então <span class="math inline">\(FOLLOW(M')\)</span> herda <span class="math inline">\(FOLLOW(M)\)</span>.
<ul>
<li>$FOLLOW(M’) = { OR, <span class="math inline">\(, ')' \}\)</span></li>
</ul></li>
<li><span class="math inline">\(FOLLOW(N)\)</span>:
<ul>
<li>Da regra <span class="math inline">\(M \rightarrow N M'\)</span>, <span class="math inline">\(N\)</span> é seguido por <span class="math inline">\(M'\)</span>. Adicionamos <span class="math inline">\(FIRST(M') - \{\varepsilon\}\)</span> ao <span class="math inline">\(FOLLOW(N)\)</span>, que é <span class="math inline">\(\{ AND \}\)</span>.</li>
<li>Como <span class="math inline">\(M'\)</span> é <em>NULLABLE</em>, também adicionamos <span class="math inline">\(FOLLOW(M)\)</span> ao <span class="math inline">\(FOLLOW(N)\)</span>.</li>
<li>$FOLLOW(N) = { AND } = { AND, OR, <span class="math inline">\(, ')' \}\)</span></li>
</ul></li>
</ul>
</section>
<section id="tabela-de-derivação-ll1-1" class="level3" data-number="6.6.7">
<h3 data-number="6.6.7" class="anchored" data-anchor-id="tabela-de-derivação-ll1-1"><span class="header-section-number">6.6.7</span> Tabela de Derivação <span class="math inline">\(LL(1)\)</span></h3>
<table class="table">
<colgroup>
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 12%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Não-Terminal</th>
<th style="text-align: left;"><strong>id</strong></th>
<th style="text-align: left;"><strong>OR</strong></th>
<th style="text-align: left;"><strong>AND</strong></th>
<th style="text-align: left;"><strong>NOT</strong></th>
<th style="text-align: left;"><strong>(</strong></th>
<th style="text-align: left;"><strong>)</strong></th>
<th style="text-align: left;"><strong>$</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>S</strong></td>
<td style="text-align: left;"><span class="math inline">\(S \rightarrow B\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(S \rightarrow B\)</span></td>
<td style="text-align: left;"><span class="math inline">\(S \rightarrow B\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>B</strong></td>
<td style="text-align: left;"><span class="math inline">\(B \rightarrow M B'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(B \rightarrow M B'\)</span></td>
<td style="text-align: left;"><span class="math inline">\(B \rightarrow M B'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>B’</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(B' \rightarrow OR \,\, M B'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(B' \rightarrow \varepsilon\)</span></td>
<td style="text-align: left;"><span class="math inline">\(B' \rightarrow \varepsilon\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>M</strong></td>
<td style="text-align: left;"><span class="math inline">\(M \rightarrow N M'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(M \rightarrow N M'\)</span></td>
<td style="text-align: left;"><span class="math inline">\(M \rightarrow N M'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>M’</strong></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(M' \rightarrow \varepsilon\)</span></td>
<td style="text-align: left;"><span class="math inline">\(M' \rightarrow AND \,\, N M'\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(M' \rightarrow \varepsilon\)</span></td>
<td style="text-align: left;"><span class="math inline">\(M' \rightarrow \varepsilon\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>N</strong></td>
<td style="text-align: left;"><span class="math inline">\(N \rightarrow id\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><span class="math inline">\(N \rightarrow NOT \,\, N\)</span></td>
<td style="text-align: left;"><span class="math inline">\(N \rightarrow (B)\)</span></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</section>
<section id="testando-com-id-or-not-id-and-id-or-id" class="level3" data-number="6.6.8">
<h3 data-number="6.6.8" class="anchored" data-anchor-id="testando-com-id-or-not-id-and-id-or-id"><span class="header-section-number">6.6.8</span> Testando com <em>id or not id and (id or id)</em></h3>
<p>Vamos rastrear a análise da <em>string</em> usando a Tabela de Derivação correta.</p>
</section>
<section id="testando-com-id-or-not-id-and-id-or-id-1" class="level3" data-number="6.6.9">
<h3 data-number="6.6.9" class="anchored" data-anchor-id="testando-com-id-or-not-id-and-id-or-id-1"><span class="header-section-number">6.6.9</span> Testando com <code>id or not id and (id or id)</code></h3>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Pilha</th>
<th style="text-align: left;">Buffer</th>
<th style="text-align: left;">Ação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>S $</code></td>
<td style="text-align: left;"><code>id or not id and (id or id) $</code></td>
<td style="text-align: left;"><code>T(S, 'id')</code> <span class="math inline">\(\rightarrow\)</span> <code>$S \rightarrow B$</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>B $</code></td>
<td style="text-align: left;"><code>id or not id and (id or id) $</code></td>
<td style="text-align: left;"><code>T(B, 'id')</code> <span class="math inline">\(\rightarrow\)</span> <code>$B \rightarrow M B'$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>M B' $</code></td>
<td style="text-align: left;"><code>id or not id and (id or id) $</code></td>
<td style="text-align: left;"><code>T(M, 'id')</code> <span class="math inline">\(\rightarrow\)</span> <code>$M \rightarrow N M'$</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>N M' B' $</code></td>
<td style="text-align: left;"><code>id or not id and (id or id) $</code></td>
<td style="text-align: left;"><code>T(N, 'id')</code> <span class="math inline">\(\rightarrow\)</span> <code>$N \rightarrow \text{id}$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>id M' B' $</code></td>
<td style="text-align: left;"><code>id or not id and (id or id) $</code></td>
<td style="text-align: left;">Consumir <code>id</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>M' B' $</code></td>
<td style="text-align: left;"><code>or not id and (id or id) $</code></td>
<td style="text-align: left;"><code>T(M', 'or')</code> <span class="math inline">\(\rightarrow\)</span> <code>$M' \rightarrow \varepsilon$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>B' $</code></td>
<td style="text-align: left;"><code>or not id and (id or id) $</code></td>
<td style="text-align: left;"><code>T(B', 'or')</code> <span class="math inline">\(\rightarrow\)</span> <code>$B' \rightarrow \text{or } M B'$</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>or M B' $</code></td>
<td style="text-align: left;"><code>or not id and (id or id) $</code></td>
<td style="text-align: left;">Consumir <code>or</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>M B' $</code></td>
<td style="text-align: left;"><code>not id and (id or id) $</code></td>
<td style="text-align: left;"><code>T(M, 'not')</code> <span class="math inline">\(\rightarrow\)</span> <code>$M \rightarrow N M'$</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>N M' B' $</code></td>
<td style="text-align: left;"><code>not id and (id or id) $</code></td>
<td style="text-align: left;"><code>T(N, 'not')</code> <span class="math inline">\(\rightarrow\)</span> <code>$N \rightarrow \text{not } N$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>not N M' B' $</code></td>
<td style="text-align: left;"><code>not id and (id or id) $</code></td>
<td style="text-align: left;">Consumir <code>not</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>N M' B' $</code></td>
<td style="text-align: left;"><code>id and (id or id) $</code></td>
<td style="text-align: left;"><code>T(N, 'id')</code> <span class="math inline">\(\rightarrow\)</span> <code>$N \rightarrow \text{id}$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>id M' B' $</code></td>
<td style="text-align: left;"><code>id and (id or id) $</code></td>
<td style="text-align: left;">Consumir <code>id</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>M' B' $</code></td>
<td style="text-align: left;"><code>and (id or id) $</code></td>
<td style="text-align: left;"><code>T(M', 'and')</code> <span class="math inline">\(\rightarrow\)</span> <code>$M' \rightarrow \text{and } N M'$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>and N M' B' $</code></td>
<td style="text-align: left;"><code>and (id or id) $</code></td>
<td style="text-align: left;">Consumir <code>and</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>N M' B' $</code></td>
<td style="text-align: left;"><code>(id or id) $</code></td>
<td style="text-align: left;"><code>T(N, '(')</code> <span class="math inline">\(\rightarrow\)</span> <code>$N \rightarrow (B)$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>( B ) M' B' $</code></td>
<td style="text-align: left;"><code>(id or id) $</code></td>
<td style="text-align: left;">Consumir <code>(</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>B ) M' B' $</code></td>
<td style="text-align: left;"><code>id or id) $</code></td>
<td style="text-align: left;"><code>T(B, 'id')</code> <span class="math inline">\(\rightarrow\)</span> <code>$B \rightarrow M B'$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>M B' ) M' B' $</code></td>
<td style="text-align: left;"><code>id or id) $</code></td>
<td style="text-align: left;"><code>T(M, 'id')</code> <span class="math inline">\(\rightarrow\)</span> <code>$M \rightarrow N M'$</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>N M' B' ) M' B' $</code></td>
<td style="text-align: left;"><code>id or id) $</code></td>
<td style="text-align: left;"><code>T(N, 'id')</code> <span class="math inline">\(\rightarrow\)</span> <code>$N \rightarrow \text{id}$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>id M' B' ) M' B' $</code></td>
<td style="text-align: left;"><code>id or id) $</code></td>
<td style="text-align: left;">Consumir <code>id</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>M' B' ) M' B' $</code></td>
<td style="text-align: left;"><code>or id) $</code></td>
<td style="text-align: left;"><code>T(M', 'or')</code> <span class="math inline">\(\rightarrow\)</span> <code>$M' \rightarrow \varepsilon$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>B' ) M' B' $</code></td>
<td style="text-align: left;"><code>or id) $</code></td>
<td style="text-align: left;"><code>T(B', 'or')</code> <span class="math inline">\(\rightarrow\)</span> <code>$B' \rightarrow \text{or } M B'$</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>or M B' ) M' B' $</code></td>
<td style="text-align: left;"><code>or id) $</code></td>
<td style="text-align: left;">Consumir <code>or</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>M B' ) M' B' $</code></td>
<td style="text-align: left;"><code>id) $</code></td>
<td style="text-align: left;"><code>T(M, 'id')</code> <span class="math inline">\(\rightarrow\)</span> <code>$M \rightarrow N M'$</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>N M' B' ) M' B' $</code></td>
<td style="text-align: left;"><code>id) $</code></td>
<td style="text-align: left;"><code>T(N, 'id')</code> <span class="math inline">\(\rightarrow\)</span> <code>$N \rightarrow \text{id}$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>id M' B' ) M' B' $</code></td>
<td style="text-align: left;"><code>id) $</code></td>
<td style="text-align: left;">Consumir <code>id</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>M' B' ) M' B' $</code></td>
<td style="text-align: left;"><code>) $</code></td>
<td style="text-align: left;"><code>T(M', ')')</code> <span class="math inline">\(\rightarrow\)</span> <code>$M' \rightarrow \varepsilon$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>B' ) M' B' $</code></td>
<td style="text-align: left;"><code>) $</code></td>
<td style="text-align: left;"><code>T(B', ')')</code> <span class="math inline">\(\rightarrow\)</span> <code>$B' \rightarrow \varepsilon$</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>) M' B' $</code></td>
<td style="text-align: left;"><code>) $</code></td>
<td style="text-align: left;">Consumir <code>)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>M' B' $</code></td>
<td style="text-align: left;"><code>$</code></td>
<td style="text-align: left;"><code>T(M', '$')</code> <span class="math inline">\(\rightarrow\)</span> <code>$M' \rightarrow \varepsilon$</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>B' $</code></td>
<td style="text-align: left;"><code>$</code></td>
<td style="text-align: left;"><code>T(B', '$')</code> <span class="math inline">\(\rightarrow\)</span> <code>$B' \rightarrow \varepsilon$</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>$</code></td>
<td style="text-align: left;"><code>$</code></td>
<td style="text-align: left;"><strong>Aceita</strong></td>
</tr>
</tbody>
</table>
<p>Como foi possível consumir toda a <em>string</em> de entrada <em>id or not id and (id or id)</em> e esvaziar a pilha sem encontrar nenhum erro, a <em>string</em> <em>id or not id and (id or id)</em> é de fato parte da linguagem definida e pode ser identificada por um <em>parser</em> <span class="math inline">\(LL(1)\)</span>.</p>
</section>
</section>
<section id="conflitos-na-tabela-de-derivação" class="level2" data-number="6.7">
<h2 data-number="6.7" class="anchored" data-anchor-id="conflitos-na-tabela-de-derivação"><span class="header-section-number">6.7</span> Conflitos na Tabela de Derivação</h2>
<p>Conflitos na Tabela de Derivação <span class="math inline">\(LL(1)\)</span> ocorrem quando há mais de uma regra de produção associada a um mesmo par indicador (terminal, não-terminal). Esta ambiguidade significa que, ao encontrar esse par, o <em>parser</em> <span class="math inline">\(LL(1)\)</span> não conseguirá determinar, de forma única e inequívoca, qual regra deverá aplicar a um determinado símbolo de entrada, tornando a gramática ambígua e inadequada para uso com <em>parsers</em> <span class="math inline">\(LL(1)\)</span>.</p>
<p><strong>Exemplo 1</strong>: observe que gramática a seguir foi criada para criar um conflito na Tabela de Derivação. Antes de nos preocuparmos com os tipos de conflito, e como solucioná-los, vamos rever todo o processo de criação de uma Tabela de Derivação para entender o problema.</p>
<p><span class="math display">\[
\begin{aligned}
1. &amp;\ E \rightarrow T + E \ \mid  \ T \\
2. &amp;\ T \rightarrow int \ \mid  \ (E)
\end{aligned}
\]</span></p>
<section id="conjunto-first" class="level3" data-number="6.7.1">
<h3 data-number="6.7.1" class="anchored" data-anchor-id="conjunto-first"><span class="header-section-number">6.7.1</span> Conjunto FIRST</h3>
<ol type="1">
<li><p><strong>Para o não-terminal E</strong>:</p>
<ul>
<li><span class="math inline">\(E \rightarrow T + E\)</span>: o primeiro símbolo é <span class="math inline">\(T\)</span>. Portanto, incluímos <span class="math inline">\(FIRST(T)\)</span> em <span class="math inline">\(FIRST(E)\)</span>.</li>
<li><span class="math inline">\(E \rightarrow T\)</span>: o primeiro símbolo é <span class="math inline">\(T\)</span>. Portanto, incluímos <span class="math inline">\(FIRST(T)\)</span> em <span class="math inline">\(FIRST(E)\)</span>.</li>
</ul></li>
<li><p><strong>Para o não-terminal T</strong>:</p>
<ul>
<li><span class="math inline">\(T \rightarrow int\)</span>: o primeiro símbolo é <span class="math inline">\(int\)</span>. Portanto, <span class="math inline">\(FIRST(T)\)</span> inclui <span class="math inline">\(int\)</span>.</li>
<li><span class="math inline">\(T \rightarrow (E)\)</span>: o primeiro símbolo é <span class="math inline">\((\)</span>. Portanto, <span class="math inline">\(FIRST(T)\)</span> inclui <span class="math inline">\((\)</span>.</li>
</ul></li>
</ol>
<p>Assim, temos:</p>
<p><span class="math display">\[
\begin{aligned}
FIRST(T) &amp;= \{ int, ( \} \\
FIRST(E) &amp;= FIRST(T) = \{ int, ( \}
\end{aligned}
\]</span></p>
</section>
<section id="conjunto-follow" class="level3" data-number="6.7.2">
<h3 data-number="6.7.2" class="anchored" data-anchor-id="conjunto-follow"><span class="header-section-number">6.7.2</span> Conjunto FOLLOW</h3>
<ol type="1">
<li><strong>Para o símbolo inicial E</strong>:
<ul>
<li><span class="math inline">\(FOLLOW(E)\)</span> inclui $.</li>
</ul></li>
<li><strong>Para as produções de E</strong>:
<ul>
<li><span class="math inline">\(E \rightarrow T + E\)</span>:
<ul>
<li>o símbolo <span class="math inline">\(T\)</span> pode ser seguido por <span class="math inline">\(+\)</span>, então <span class="math inline">\(+\)</span> está em <span class="math inline">\(FOLLOW(T)\)</span>.</li>
<li>o símbolo <span class="math inline">\(E\)</span> é o último da produção, então <span class="math inline">\(FOLLOW(E)\)</span> inclui <span class="math inline">\(FOLLOW(E)\)</span>.</li>
</ul></li>
<li><span class="math inline">\(E \rightarrow T\)</span>: o símbolo <span class="math inline">\(T\)</span> é o último da produção, então <span class="math inline">\(FOLLOW(T)\)</span> inclui <span class="math inline">\(FOLLOW(E)\)</span>.</li>
</ul></li>
<li><strong>Para as produções de T</strong>:
<ul>
<li><span class="math inline">\(T \rightarrow int\)</span>: <span class="math inline">\(int\)</span> é um terminal, não influencia <span class="math inline">\(FOLLOW\)</span>.</li>
<li><span class="math inline">\(T \rightarrow (E)\)</span>: <span class="math inline">\(E\)</span> pode ser seguido por <span class="math inline">\()\)</span>, então <span class="math inline">\(FOLLOW(E)\)</span> inclui <span class="math inline">\()\)</span>.</li>
</ul></li>
</ol>
<p>Assim, teremos:</p>
<p><span class="math display">\[
\begin{aligned}
FOLLOW(E) &amp;= \{ \$, ) \} \\
FOLLOW(T) &amp;= \{ +, \$, ) \}
\end{aligned}
\]</span></p>
</section>
<section id="nullable-2" class="level3" data-number="6.7.3">
<h3 data-number="6.7.3" class="anchored" data-anchor-id="nullable-2"><span class="header-section-number">6.7.3</span> Nullable</h3>
<p>Para determinar se algum não-terminal é <em>nullable</em>, verificamos se ele pode derivar a string vazia <span class="math inline">\(\varepsilon\)</span>.</p>
<ol type="1">
<li><strong>Para E</strong>:
<ul>
<li><span class="math inline">\(E \rightarrow T + E\)</span>: <span class="math inline">\(T\)</span> não é <em>nullable</em>, portanto, <span class="math inline">\(E\)</span> não é <em>nullable</em> a partir desta produção.</li>
<li><span class="math inline">\(E \rightarrow T\)</span>: <span class="math inline">\(T\)</span> não é <em>nullable</em>, portanto, <span class="math inline">\(E\)</span> não é <em>nullable</em>.</li>
</ul></li>
<li><strong>Para T</strong>:
<ul>
<li><span class="math inline">\(T \rightarrow int\)</span>: <span class="math inline">\(int\)</span> não é <em>nullable</em>.</li>
<li><span class="math inline">\(T \rightarrow (E)\)</span>: <span class="math inline">\(E\)</span> não é <em>nullable</em> e <span class="math inline">\((\)</span> é um terminal.</li>
</ul></li>
</ol>
<p>Ou seja, nenhum dos não-terminais é <em>nullable</em>:</p>
<p><span class="math display">\[
\begin{aligned}
Nullable(E) &amp;= false \\
Nullable(T) &amp;= false
\end{aligned}
\]</span></p>
</section>
<section id="resumo-dos-conjuntos" class="level3" data-number="6.7.4">
<h3 data-number="6.7.4" class="anchored" data-anchor-id="resumo-dos-conjuntos"><span class="header-section-number">6.7.4</span> Resumo dos Conjuntos</h3>
<p><span class="math display">\[
\begin{aligned}
FIRST(E) &amp;= \{ int, ( \} \\
FIRST(T) &amp;= \{ int, ( \} \\
FOLLOW(E) &amp;= \{ \$ ) \} \\
FOLLOW(T) &amp;= \{ +, \$ ) \} \\
Nullable(E) &amp;= false \\
Nullable(T) &amp;= false
\end{aligned}
\]</span></p>
<p>O que permite gerar a seguinte Tabela de Derivação:</p>
<table class="table">
<colgroup>
<col style="width: 18%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>não-terminal</th>
<th>int</th>
<th>(</th>
<th>+</th>
<th>$</th>
<th>)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E</td>
<td><span class="math inline">\(E \rightarrow T + E\)</span><br><span class="math inline">\(E \rightarrow T\)</span></td>
<td><span class="math inline">\(E \rightarrow T + E\)</span><br><span class="math inline">\(E \rightarrow T\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>T</td>
<td><span class="math inline">\(T \rightarrow int\)</span></td>
<td><span class="math inline">\(T \rightarrow (E)\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Nesta tabela podemos ver um conflito explícito. O não-terminal <span class="math inline">\(E\)</span> possui duas produções para os símbolos <span class="math inline">\(int\)</span> e <span class="math inline">\((\)</span>.</p>
<p>Sempre que na criação de Tabelas de Derivação existir um conflito estaremos gerando ambiguidades na derivação. A gramática é ambígua, sempre que uma sentença puder ser derivada de duas ou mais formas diferentes, gerando árvores sintáticas diferentes. Por exemplo, na gramática do <strong>Exemplo 1</strong>, a sentença <span class="math inline">\(int + int\)</span> pode ser derivada tanto como <span class="math inline">\(E → T → int\)</span> seguido de <span class="math inline">\(E → T + E → int + int\)</span> quanto como <span class="math inline">\(E → T + E → T + T → int + int\)</span>.</p>
</section>
</section>
<section id="tipos-de-conflitos-nas-tabelas-de-derivação" class="level2" data-number="6.8">
<h2 data-number="6.8" class="anchored" data-anchor-id="tipos-de-conflitos-nas-tabelas-de-derivação"><span class="header-section-number">6.8</span> Tipos de Conflitos Nas Tabelas de Derivação</h2>
<p>Conflitos na Tabela de Derivação, ou tabela de análise, <span class="math inline">\(LL(1)\)</span> podem ser classificados em dois tipos principais:</p>
<ol type="1">
<li><p><strong>Conflito</strong> <span class="math inline">\(FIRST\)</span>/<span class="math inline">\(FIRST\)</span>: ocorre quando o conjunto <span class="math inline">\(FIRST\)</span> de duas ou mais produções de um mesmo não-terminal possui um terminal em comum. Na gramática do <strong>Exemplo 1</strong>, as produções <span class="math inline">\(E \rightarrow T + E\)</span> e <span class="math inline">\(E \rightarrow T\)</span> possuem os terminais <span class="math inline">\(int\)</span> e <span class="math inline">\((\)</span> em seus conjuntos <span class="math inline">\(FIRST\)</span>. Ao encontrar <span class="math inline">\(int\)</span> ou <span class="math inline">\((\)</span> na entrada, o <em>parser</em> não sabe se deve aplicar a regra que deriva uma expressão com um operador <span class="math inline">\(+\)</span> ou a regra que deriva um termo. Neste momento do processo de <em>parsing</em> determinismo saiu pela janela e o <em>parser</em> <span class="math inline">\(LL(1)\)</span> é inútil.</p></li>
<li><p><strong>Conflito</strong> <span class="math inline">\(FIRST\)</span>/<span class="math inline">\(FOLLOW\)</span>: ocorre quando uma produção tem <span class="math inline">\(\varepsilon\)</span> (a <em>string</em> vazia) em seu conjunto <span class="math inline">\(FIRST\)</span> e o conjunto <span class="math inline">\(FOLLOW\)</span> do não-terminal da produção possui um terminal em comum com o <span class="math inline">\(FIRST\)</span> de outra produção do mesmo não-terminal. Por exemplo, na gramática do <strong>Exemplo 1</strong>, se <span class="math inline">\(E \rightarrow \varepsilon\)</span> fosse uma produção e o conjunto <span class="math inline">\(FOLLOW(E)\)</span> contivesse <span class="math inline">\(+\)</span>, que também está no <span class="math inline">\(FIRST\)</span> da produção <span class="math inline">\(E \rightarrow T + E\)</span>, ao encontrar o fim de uma expressão (representado por um símbolo em <span class="math inline">\(FOLLOW(E)\)</span>), o <em>parser</em> não saberia se deve aplicar a regra que deriva apenas um termo ou a regra que deriva uma expressão com um operador <span class="math inline">\(+\)</span>.</p></li>
</ol>
<section id="resolução-de-conflitos" class="level3" data-number="6.8.1">
<h3 data-number="6.8.1" class="anchored" data-anchor-id="resolução-de-conflitos"><span class="header-section-number">6.8.1</span> Resolução de Conflitos</h3>
<p>Conflitos na tabela <span class="math inline">\(LL(1)\)</span> podem ser resolvidos das seguintes formas:</p>
<ol type="1">
<li><strong>Refatoração da gramática</strong>: A gramática pode ser reescrita para eliminar ambiguidades e recursões à esquerda, evitando assim os conflitos.</li>
<li><strong>Fatoração à esquerda</strong>: Produções com prefixos comuns podem ser fatoradas para que a decisão entre elas possa ser tomada com base em um único símbolo de <em>lookahead</em>.</li>
<li><strong>Uso de analisadores mais poderosos</strong>: Se os conflitos não puderem ser resolvidos na gramática, pode ser necessário usar um analisador sintático mais poderoso, como um analisador <span class="math inline">\(LR(1)\)</span> ou <span class="math inline">\(LALR(1)\)</span>, que conseguem lidar com gramáticas mais complexas.</li>
</ol>
<p>As soluções 1 e 2 implicam na modificação da sua gramática, o que ocorre com frequência quando começamos do zero. A solução 3, em linguagens complexas, pode ser a solução adequada, mas implica em mudar de algoritmo de <em>parser</em></p>
<p><strong>Exemplo 2</strong>: resolução de conflito. No exemplo da gramática anterior, o conflito <span class="math inline">\(FIRST\)</span>/<span class="math inline">\(FIRST\)</span> pode ser resolvido fatorando as produções de <span class="math inline">\(E\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
1. &amp;\ E \rightarrow T E' \\
2. &amp;\ E' \rightarrow + E \ \mid  \ \varepsilon \\
3. &amp;\ T \rightarrow int \ \mid  \ (E)
\end{aligned}
\]</span></p>
<p>Se calcularmos os conjuntos <span class="math inline">\(FIRST\)</span> e <span class="math inline">\(FOLLOW\)</span> novamente, teremos:</p>
<section id="conjunto-first-1" class="level4" data-number="6.8.1.1">
<h4 data-number="6.8.1.1" class="anchored" data-anchor-id="conjunto-first-1"><span class="header-section-number">6.8.1.1</span> Conjunto FIRST</h4>
<ol type="1">
<li><strong>Para o não-terminal E</strong>:
<ul>
<li><span class="math inline">\(E \rightarrow T E'\)</span>: o primeiro símbolo é <span class="math inline">\(T\)</span>. Portanto, incluímos <span class="math inline">\(FIRST(T)\)</span> em <span class="math inline">\(FIRST(E)\)</span>.</li>
</ul></li>
<li><strong>Para o não-terminal E’</strong>:
<ul>
<li><span class="math inline">\(E' \rightarrow + E\)</span>: o primeiro símbolo é <span class="math inline">\(+\)</span>. Portanto, <span class="math inline">\(FIRST(E')\)</span> inclui <span class="math inline">\(+\)</span>.</li>
<li><span class="math inline">\(E' \rightarrow \varepsilon\)</span>: incluímos <span class="math inline">\(\varepsilon\)</span> em <span class="math inline">\(FIRST(E')\)</span>.</li>
</ul></li>
<li><strong>Para o não-terminal T</strong>:
<ul>
<li><span class="math inline">\(T \rightarrow int\)</span>: o primeiro símbolo é <span class="math inline">\(int\)</span>. Portanto, <span class="math inline">\(FIRST(T)\)</span> inclui <span class="math inline">\(int\)</span>.</li>
<li><span class="math inline">\(T \rightarrow (E)\)</span>: o primeiro símbolo é $( $. Portanto, <span class="math inline">\(FIRST(T)\)</span> inclui $( $.</li>
</ul></li>
</ol>
<p>Assim, teremos:</p>
<p><span class="math display">\[
\begin{aligned}
FIRST(T) &amp;= \{ int, ( \} \\
FIRST(E') &amp;= \{ +, \varepsilon \} \\
FIRST(E) &amp;= FIRST(T) = \{ int, ( \}
\end{aligned}
\]</span></p>
</section>
<section id="conjunto-follow-1" class="level4" data-number="6.8.1.2">
<h4 data-number="6.8.1.2" class="anchored" data-anchor-id="conjunto-follow-1"><span class="header-section-number">6.8.1.2</span> Conjunto FOLLOW</h4>
<ol type="1">
<li><strong>Para o símbolo inicial E</strong>:
<ul>
<li><span class="math inline">\(FOLLOW(E)\)</span> inclui $.</li>
</ul></li>
<li><strong>Para as produções de E</strong>:
<ul>
<li><span class="math inline">\(E \rightarrow T E'\)</span>:
<ul>
<li>O símbolo <span class="math inline">\(E'\)</span> pode ser seguido por <span class="math inline">\(FOLLOW(E)\)</span>.</li>
<li>Então, <span class="math inline">\(FOLLOW(E')\)</span> inclui <span class="math inline">\(FOLLOW(E)\)</span>.</li>
</ul></li>
</ul></li>
<li><strong>Para as produções de E’</strong>:
<ul>
<li><span class="math inline">\(E' \rightarrow + E\)</span>:
<ul>
<li>O símbolo <span class="math inline">\(E\)</span> pode ser seguido por <span class="math inline">\(FOLLOW(E')\)</span>.</li>
<li>Então, <span class="math inline">\(FOLLOW(E)\)</span> inclui <span class="math inline">\(FOLLOW(E')\)</span>.</li>
</ul></li>
<li><span class="math inline">\(E' \rightarrow \varepsilon\)</span>: não há efeito em <span class="math inline">\(FOLLOW\)</span>.</li>
</ul></li>
<li><strong>Para as produções de T</strong>:
<ul>
<li><span class="math inline">\(T \rightarrow int\)</span>: <span class="math inline">\(int\)</span> é um terminal, não influencia <span class="math inline">\(FOLLOW\)</span>.</li>
<li><span class="math inline">\(T \rightarrow (E)\)</span>: <span class="math inline">\(E\)</span> pode ser seguido por <span class="math inline">\()\)</span>, então <span class="math inline">\(FOLLOW(E)\)</span> inclui <span class="math inline">\()\)</span>.</li>
</ul></li>
</ol>
<p>Assim, teremos:</p>
<p><span class="math display">\[
\begin{aligned}
FOLLOW(E) &amp;= \{ \$, ) \} \\
FOLLOW(E') &amp;= \{ \$, ) \} \\
FOLLOW(T) &amp;= \{ +, \$, ) \}
\end{aligned}
\]</span></p>
</section>
<section id="nullable-3" class="level4" data-number="6.8.1.3">
<h4 data-number="6.8.1.3" class="anchored" data-anchor-id="nullable-3"><span class="header-section-number">6.8.1.3</span> Nullable</h4>
<p>Para determinar se algum não-terminal é <em>nullable</em>, verificamos se ele pode derivar a string vazia <span class="math inline">\(\varepsilon\)</span>.</p>
<ol type="1">
<li><strong>Para E</strong>:
<ul>
<li><span class="math inline">\(E \rightarrow T E'\)</span>: <span class="math inline">\(T\)</span> não é <em>nullable</em>, portanto, <span class="math inline">\(E\)</span> não é <em>nullable</em>.</li>
</ul></li>
<li><strong>Para E’</strong>:
<ul>
<li><span class="math inline">\(E' \rightarrow + E\)</span>: <span class="math inline">\(+\)</span> é um terminal, portanto, não é <em>nullable</em>.</li>
<li><span class="math inline">\(E' \rightarrow \varepsilon\)</span>: <span class="math inline">\(E'\)</span> é <em>nullable</em>.</li>
</ul></li>
<li><strong>Para T</strong>:
<ul>
<li><span class="math inline">\(T \rightarrow int\)</span>: <span class="math inline">\(int\)</span> não é <em>nullable</em>.</li>
<li><span class="math inline">\(T \rightarrow (E)\)</span>: $( $ é um terminal, portanto, não é <em>nullable</em>.</li>
</ul></li>
</ol>
<p>Assim, teremos:</p>
<p><span class="math display">\[
\begin{aligned}
Nullable(E) &amp;= false \\
Nullable(E') &amp;= true \\
Nullable(T) &amp;= false
\end{aligned}
\]</span></p>
</section>
<section id="resumo-dos-conjuntos-1" class="level4" data-number="6.8.1.4">
<h4 data-number="6.8.1.4" class="anchored" data-anchor-id="resumo-dos-conjuntos-1"><span class="header-section-number">6.8.1.4</span> Resumo dos Conjuntos</h4>
<p><span class="math display">\[
\begin{aligned}
FIRST(E) &amp;= \{ int, ( \} \\
FIRST(E') &amp;= \{ +, \varepsilon \} \\
FIRST(T) &amp;= \{ int, ( \} \\
FOLLOW(E) &amp;= \{ \$, ) \} \\
FOLLOW(E') &amp;= \{ \$, ) \} \\
FOLLOW(T) &amp;= \{ +, \$, ) \} \\
Nullable(E) &amp;= false \\
Nullable(E') &amp;= true \\
Nullable(T) &amp;= false
\end{aligned}
\]</span></p>
<p>O que permite gerar a seguinte Tabela de Derivação:</p>
<table class="table">
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>não-terminal</th>
<th>int</th>
<th>(</th>
<th>+</th>
<th>$</th>
<th>)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>E</td>
<td><span class="math inline">\(E \rightarrow TE'\)</span></td>
<td><span class="math inline">\(E \rightarrow TE'\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>E’</td>
<td></td>
<td></td>
<td><span class="math inline">\(E' \rightarrow +E\)</span></td>
<td><span class="math inline">\(E' \rightarrow \varepsilon\)</span></td>
<td><span class="math inline">\(E' \rightarrow \varepsilon\)</span></td>
</tr>
<tr class="odd">
<td>T</td>
<td><span class="math inline">\(T \rightarrow int\)</span></td>
<td><span class="math inline">\(T \rightarrow (E)\)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Agora, a decisão entre derivar uma expressão com um operador <span class="math inline">\(+\)</span> ou apenas um termo pode ser tomada com base no próximo símbolo da entrada: se for <span class="math inline">\(+\)</span>, aplica-se a regra <span class="math inline">\(E' \rightarrow + E\)</span>; caso contrário, aplica-se a regra <span class="math inline">\(E' \rightarrow \varepsilon\)</span>.</p>
<p>Assim como fiz nos artigos anteriores, vou sugerir um pseudocódigo, um tanto inocente, para a criação de tabelas de derivação. Acredito que, com um pouco de cuidado, depois que a amável leitora dominar esta técnica possa criar um pseudocódigo mais eficiente. A fé move montanhas.</p>
</section>
</section>
<section id="pseudocódigo-para-a-criação-da-tabela-de-derivação" class="level3" data-number="6.8.2">
<h3 data-number="6.8.2" class="anchored" data-anchor-id="pseudocódigo-para-a-criação-da-tabela-de-derivação"><span class="header-section-number">6.8.2</span> Pseudocódigo para a Criação da Tabela de Derivação</h3>
<pre class="pseudo"><code>função construir_tabela(gramatica, nao_terminais, terminais, FIRST, FOLLOW):
    // Inicializa a tabela com entradas vazias (erro)
    Tabela = criar um dicionário aninhado [nao_terminal][terminal]

    // Itera sobre cada produção A -&gt; α
    para cada não-terminal A e suas produções em gramatica:
        para cada produção α (lista de símbolos):
            
            // Calcula o FIRST da sequência α
            first_α = calcular_first_da_sequencia(α, ...)

            // Regra 1: Para cada terminal 't' em FIRST(α)
            para cada terminal t em first_α:
                se t != 'EPSILON':
                    se Tabela[A][t] já está preenchida:
                        Lançar ErroDeConflito(A, t)
                    senão:
                        Tabela[A][t] = produção A -&gt; α

            // Regra 2: Se α pode ser vazio (ε)
            se 'EPSILON' está em first_α:
                // Para cada terminal 't' em FOLLOW(A)
                para cada terminal t em FOLLOW[A]:
                    se Tabela[A][t] já está preenchida:
                        Lançar ErroDeConflito(A, t)
                    senão:
                        Tabela[A][t] = produção A -&gt; ε
    
    retornar Tabela</code></pre>
<p>Em fim, este código pode ser implementado em Python por:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construir_tabela_ll1(</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    gramatica: <span class="bu">dict</span>,</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    simbolo_inicial: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">dict</span>[<span class="bu">str</span>, <span class="bu">dict</span>[<span class="bu">str</span>, <span class="bu">list</span> <span class="op">|</span> <span class="va">None</span>]]:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Constrói a Tabela de Análise LL(1) completa a partir de uma gramática.</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Esta função serve como um integrador para todas as funções anteriores.</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Identificar todos os símbolos</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    nao_terminais <span class="op">=</span> <span class="bu">set</span>(gramatica.keys())</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    simbolos <span class="op">=</span> <span class="bu">set</span>(nao_terminais)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> producoes <span class="kw">in</span> gramatica.values():</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            simbolos.update(producao)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    terminais <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(simbolos <span class="op">-</span> nao_terminais <span class="op">-</span> {<span class="st">'EPSILON'</span>})) <span class="op">+</span> [<span class="st">'$'</span>]</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Calcular os conjuntos</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    nullable <span class="op">=</span> calcular_NULLABLE(gramatica)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    first <span class="op">=</span> calcular_FIRST(gramatica, nao_terminais, nullable)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    follow <span class="op">=</span> calcular_FOLLOW(gramatica, simbolo_inicial, nao_terminais, first, nullable)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Inicializar e preencher a tabela</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    tabela <span class="op">=</span> {nt: {t: <span class="va">None</span> <span class="cf">for</span> t <span class="kw">in</span> terminais} <span class="cf">for</span> nt <span class="kw">in</span> nao_terminais}</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nt_head, producoes <span class="kw">in</span> gramatica.items():</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> producao <span class="kw">in</span> producoes:</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>            first_producao <span class="op">=</span> calcular_first_da_sequencia(producao, first, nullable, nao_terminais)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Regra 1: FIRST</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> terminal <span class="kw">in</span> first_producao <span class="op">-</span> {<span class="st">'EPSILON'</span>}:</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> tabela[nt_head][terminal] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Conflito FIRST/FIRST em [</span><span class="sc">{</span>nt_head<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>terminal<span class="sc">}</span><span class="ss">]!"</span>)</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>                tabela[nt_head][terminal] <span class="op">=</span> producao</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Regra 2: FOLLOW</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="st">'EPSILON'</span> <span class="kw">in</span> first_producao:</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> terminal <span class="kw">in</span> follow[nt_head]:</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> tabela[nt_head][terminal] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Conflito FIRST/FOLLOW em [</span><span class="sc">{</span>nt_head<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>terminal<span class="sc">}</span><span class="ss">]!"</span>)</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>                    tabela[nt_head][terminal] <span class="op">=</span> producao</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tabela</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> imprimir_tabela(tabela: <span class="bu">dict</span>):</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Função auxiliar para exibir a tabela de forma legível no console."""</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>    nao_terminais <span class="op">=</span> <span class="bu">sorted</span>(tabela.keys())</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nao_terminais: <span class="cf">return</span></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>    terminais <span class="op">=</span> <span class="bu">sorted</span>(tabela[nao_terminais[<span class="dv">0</span>]].keys())</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Imprimir cabeçalho</span></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>    header <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span><span class="st">'Não-Terminal'</span><span class="sc">:&lt;15}</span><span class="ss">"</span> <span class="op">+</span> <span class="st">""</span>.join([<span class="ss">f"</span><span class="sc">{</span>t<span class="sc">:&lt;18}</span><span class="ss">"</span> <span class="cf">for</span> t <span class="kw">in</span> terminais])</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(header)</span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span> <span class="op">*</span> <span class="bu">len</span>(header))</span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Imprimir linhas</span></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nt <span class="kw">in</span> nao_terminais:</span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>        row_str <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>nt<span class="sc">:&lt;15}</span><span class="ss">"</span></span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> terminais:</span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>            producao <span class="op">=</span> tabela[nt][t]</span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> producao <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>                cell <span class="op">=</span> <span class="st">" "</span></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Formata a produção como "A -&gt; α"</span></span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>                cell <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>nt<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span><span class="st">' '</span><span class="sc">.</span>join(producao)<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>            row_str <span class="op">+=</span> <span class="ss">f"</span><span class="sc">{</span>cell<span class="sc">:&lt;18}</span><span class="ss">"</span></span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(row_str)</span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Exemplo de uso para a gramática refatorada (Exemplo 2) ---</span></span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>gramatica_sem_conflito <span class="op">=</span> {</span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>    <span class="st">'E'</span>: [[<span class="st">'T'</span>, <span class="st">"E'"</span>]],</span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>    <span class="st">"E'"</span>: [[<span class="st">'+'</span>, <span class="st">'E'</span>], [<span class="st">'EPSILON'</span>]],</span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>    <span class="st">'T'</span>: [[<span class="st">'int'</span>], [<span class="st">'('</span>, <span class="st">'E'</span>, <span class="st">')'</span>]]</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>    tabela_final <span class="op">=</span> construir_tabela_ll1(gramatica_sem_conflito, <span class="st">'E'</span>)</span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Tabela de Análise LL(1) gerada com sucesso:</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>    imprimir_tabela(tabela_final)</span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Erro ao gerar tabela: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/frankalcantara\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./04-Gramaticas.html" class="pagination-link" aria-label="Gramáticas e Linguagens Livres de Contexto">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Gramáticas e Linguagens Livres de Contexto</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./fase1.html" class="pagination-link" aria-label="Fase 1 - Projeto Prático">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Fase 1 - Projeto Prático</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright © 2025 Frank de Alcantara</p>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/frankalcantara/linguagens-formais/edit/main/05-parsersLL1.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/frankalcantara/linguagens-formais/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>