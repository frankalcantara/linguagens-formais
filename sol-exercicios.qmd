# Solução dos Exercícios

## Capítulo: @sec-alfabeto-linguagem-string

### Exercícios 1: @sec-ex-alfabeto

1. **Solução:**

- **$\Sigma_1 = \{a, b, c, +, -, *, /, (, )\}$**
  
  Contando cada símbolo: $a, b, c, +, -, *, /, (, )$
  
  $$|\Sigma_1| = 9$$

- **$\Sigma_2 = \{0, 1, 2, \ldots, 9, A, B, C, D, E, F\}$ (hexadecimal)**
  
  Dígitos decimais: $\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$ → 10 símbolos
  
  Letras hexadecimais: $\{A, B, C, D, E, F\}$ → 6 símbolos
  
  $$|\Sigma_2| = 10 + 6 = 16$$

- **$\Sigma_3 = \{\text{verdadeiro}, \text{falso}, \land, \lor, \neg, (, )\}$**
  
  Contando cada símbolo: $\text{verdadeiro}, \text{falso}, \land, \lor, \neg, (, )$
  
  $$|\Sigma_3| = 7$$

2. **Solução:**

- **Expressões lógicas booleanas simples com variáveis $p$, $q$, $r$:**
  
  $$\Sigma_{\text{bool}} = \{p, q, r, \land, \lor, \neg, (, )\}$$
  
  **Justificativa:** Inclui as três variáveis proposicionais, os conectivos lógicos básicos (conjunção, disjunção, negação) e parênteses para agrupamento.

- **Números em notação científica (ex: $1.23 \times 10^{-4}$):**
  
  $$\Sigma_{\text{cient}} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, -, ., \times, ^{}, 1, 0\}$$
  
  Ou de forma mais concisa:
  
  $$\Sigma_{\text{cient}} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, -, ., \times, ^\}$$
  
  **Justificativa:** Inclui dígitos para o número base, sinais para número e expoente, ponto decimal, símbolo de multiplicação e símbolo de potência.

- **Coordenadas cartesianas no formato $(x, y)$:**
  
  $$\Sigma_{\text{coord}} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, -, ., (, ), ,\}$$
  
  **Justificativa:** Inclui dígitos para números, sinais, ponto decimal, parênteses para delimitação e vírgula como separador.

3. **Solução:**

- **$A = \emptyset$**
  
  **NÃO é um alfabeto válido.**
  
  **Justificativa:** A definição formal exige que um alfabeto seja um conjunto finito **não-vazio**. Como $A$ é o conjunto vazio, ele viola a condição $n \geq 1$.

- **$B = \{\epsilon\}$**
  
  **É um alfabeto válido.**
  
  **Justificativa:** É um conjunto finito ($|B| = 1$) e não-vazio. O símbolo $\epsilon$ pode ser tratado como um símbolo atômico qualquer para fins de definição de alfabeto.

- **$C = \{1, 2, 3, \ldots\}$**
  
  **NÃO é um alfabeto válido.**
  
  **Justificativa:** Este é o conjunto dos números naturais positivos, que é infinito ($|C| = \infty$). A definição de alfabeto exige finitude.

- **$D = \{a, b, a\}$**
  
  **É um alfabeto válido, mas equivalente a $\{a, b\}$.**
  
  **Justificativa:** Como conjuntos não possuem elementos repetidos, $D = \{a, b\}$. É finito ($|D| = 2$) e não-vazio, portanto é um alfabeto válido.

4. **Solução:**

Dado $S = \{\text{if}, \text{then}, \text{else}, \text{fi}\}$, precisamos encontrar todos os símbolos que aparecem nas strings:

- $\text{if}$: símbolos $i, f$
- $\text{then}$: símbolos $t, h, e, n$  
- $\text{else}$: símbolos $e, l, s, e$ (note que $e$ se repete)
- $\text{fi}$: símbolos $f, i$

Coletando todos os símbolos únicos:

$$\Sigma_{\text{mín}} = \{e, f, h, i, l, n, s, t\}$$

**Cardinalidade:** $|\Sigma_{\text{mín}}| = 8$

**Verificação:** Todas as strings em $S$ podem ser formadas usando apenas estes símbolos, e nenhum símbolo pode ser removido sem impossibilitar a formação de pelo menos uma string.

5. **Solução:**

Comparando $\Sigma_A = \{0, 1\}$ e $\Sigma_B = \{a, b, c\}$:

**Cardinalidade:**
- $|\Sigma_A| = 2$
- $|\Sigma_B| = 3$

**Número de strings de comprimento 3:**

Para um alfabeto de tamanho $n$, o número de strings de comprimento $k$ é $n^k$.

- Para $\Sigma_A$: $|\Sigma_A|^3 = 2^3 = 8$ strings
  
  Strings: $\{000, 001, 010, 011, 100, 101, 110, 111\}$

- Para $\Sigma_B$: $|\Sigma_B|^3 = 3^3 = 27$ strings
  
  Exemplos: $\{aaa, aab, aac, aba, abb, abc, \ldots, ccc\}$

**Aplicabilidade para representar números binários:**

- **$\Sigma_A$:** Perfeitamente adequado para representação binária, pois contém exatamente os símbolos $0$ e $1$ necessários.

- **$\Sigma_B$:** Inadequado para representação binária direta. Seria necessário estabelecer uma convenção de mapeamento (por exemplo, $a \rightarrow 0$, $b \rightarrow 1$, e $c$ seria um símbolo extra não utilizado).

**Conclusão:** $\Sigma_A$ é mais eficiente para representação binária, enquanto $\Sigma_B$ oferece maior capacidade expressiva para outras aplicações devido ao seu maior tamanho.

### Exercícios 2: @sec-ex-strings

1. **Solução:**

**Dado:** $x = ab$ e $y = cd$

**Concatenações:**
- $xy = ab \cdot cd = abcd$
- $yx = cd \cdot ab = cdab$

**Observação:** Note que $xy \neq yx$, demonstrando que a concatenação não é comutativa.

**Potências:**
- $x^3 = (ab)^3 = ab \cdot ab \cdot ab = ababab$
- $y^2 = (cd)^2 = cd \cdot cd = cdcd$

**Potências de concatenações:**
- $(xy)^2 = (abcd)^2 = abcd \cdot abcd = abcdabcd$
- $x^2y^2 = (ab)^2(cd)^2 = abab \cdot cdcd = ababcdcd$

**Observação:** $(xy)^2 \neq x^2y^2$, mostrando que $(uv)^n \neq u^nv^n$ em geral.

**Comprimento de $x^n$:**

Como $|x| = |ab| = 2$, temos:

$$|x^n| = n \cdot |x| = n \cdot 2 = 2n$$

**Verificação:** $|x^3| = |ababab| = 6 = 2 \cdot 3$ 

2. **Solução:**

**Aplicando a definição recursiva $\epsilon^R = \epsilon$ e $(wa)^R = aw^R$:**

- **$w_1 = abcde$**
  
  Aplicando passo a passo:
  $$w_1^R = (abcde)^R = e(abcd)^R = ed(abc)^R = edc(ab)^R = edcb(a)^R = edcba$$

- **$w_2 = palindromo$**
  
  $$w_2^R = (palindromo)^R = omordnilap$$

- **$w_3 = \epsilon$ (string vazia)**
  
  $$w_3^R = \epsilon^R = \epsilon$$

**Prova de que $(\epsilon)^R = \epsilon$:**

**Demonstração:** Pela definição recursiva, o caso base estabelece diretamente que $\epsilon^R = \epsilon$. Isso é consistente, pois a string vazia não possui símbolos para inverter, mantendo-se inalterada.

3. **Solução:**

**Associatividade:** $(xy)z = x(yz)$ para $x = a$, $y = bc$, $z = d$

$$\text{Lado esquerdo: } (xy)z = (a \cdot bc)d = (abc)d = abcd$$
$$\text{Lado direito: } x(yz) = a(bc \cdot d) = a(bcd) = abcd$$

$$\therefore (xy)z = x(yz) = abcd$$

**Elemento neutro:** $w\epsilon = \epsilon w = w$ para $w = abc$

$$w\epsilon = abc \cdot \epsilon = abc$$
$$\epsilon w = \epsilon \cdot abc = abc$$

$$\therefore w\epsilon = \epsilon w = w = abc$$

**Não-comutatividade:** Encontrar $x$ e $y$ tais que $xy \neq yx$

**Exemplo:** $x = a$ e $y = b$

$$xy = a \cdot b = ab$$
$$yx = b \cdot a = ba$$

Como $ab \neq ba$, a concatenação não é comutativa.

4. **Solução:**

**Dado:** $w = compilador$

**Prefixos próprios** (todos os prefixos exceto a própria string):

$$\{\epsilon, c, co, com, comp, compi, compil, compila, compilado\}$$

**Total de prefixos próprios:** 9

**Sufixos próprios** (todos os sufixos exceto a própria string):

$$\{\epsilon, r, or, dor, ador, lador, ilador, pilador, mpilador\}$$

**Total de sufixos próprios:** 9

**Substrings de comprimento 4:**

Posições possíveis para substrings de comprimento 4 em uma string de comprimento 10:

$$\{comp, ompi, mpil, pila, ilad, lado, ador\}$$

**Total de substrings de comprimento 4:** 7

**Contagem total:**
- **Prefixos totais:** 10 (incluindo $\epsilon$ e a própria string)
- **Sufixos totais:** 10 (incluindo $\epsilon$ e a própria string)

**Fórmula geral:** Para uma string de comprimento $n$, existem $n+1$ prefixos e $n+1$ sufixos.

5. **Solução:**

**Dado:** $w = aba$

**Cálculo de $w^R$:**
$$w^R = (aba)^R = a(ba)^R = ab(a)^R = aba$$

**Observação:** $w = aba$ é um palíndromo, logo $w^R = w$.

**$(w^R)^2$:**
$$w^R = aba$$
$$(w^R)^2 = (aba)^2 = aba \cdot aba = abaaba$$

**$(w^2)^R$:**
$$w^2 = aba \cdot aba = abaaba$$
$$(w^2)^R = (abaaba)^R = abaaba$$

**$w^R w$:**
$$w^R w = aba \cdot aba = abaaba$$

**Verificação se $(w^2)^R = (w^R)^2$:**

$$\text{Lado esquerdo: } (w^2)^R = abaaba$$
$$\text{Lado direito: } (w^R)^2 = abaaba$$

$$\therefore (w^2)^R = (w^R)^2$$

**Explicação:** Esta igualdade vale neste caso específico porque $w$ é um palíndromo ($w = w^R$). Em geral, para strings arbitrárias, $(w^n)^R = (w^R)^n$, que se reduz a $w^n = w^n$ quando $w$ é um palíndromo.

**Propriedade geral:** Para qualquer string $u$ e inteiro positivo $n$:
$$(u^n)^R = (u^R)^n$$

No nosso caso, como $w^R = w$, ambos os lados se tornam $w^2 = abaaba$.

### Exercícios 3: @sec-ex-linguagens2

1. **Solução:**

**Dado:** $L_1 = \{a, ab, b\}$ e $L_2 = \{b, ba, \epsilon\}$

**União:** $L_1 \cup L_2$
$$L_1 \cup L_2 = \{a, ab, b\} \cup \{b, ba, \epsilon\} = \{a, ab, b, ba, \epsilon\}$$

**Interseção:** $L_1 \cap L_2$
$$L_1 \cap L_2 = \{a, ab, b\} \cap \{b, ba, \epsilon\} = \{b\}$$

**Diferença:** $L_1 - L_2$
$$L_1 - L_2 = \{a, ab, b\} - \{b, ba, \epsilon\} = \{a, ab\}$$

**Cardinalidades:**
- $|L_1 \cup L_2| = |\{a, ab, b, ba, \epsilon\}| = 5$
- $|L_1 \cap L_2| = |\{b\}| = 1$

**Verificação:** $|L_1| + |L_2| - |L_1 \cap L_2| = 3 + 3 - 1 = 5 = |L_1 \cup L_2|$ 

2. **Solução:**

**Dado:** $L_1 = \{a, bb\}$ e $L_2 = \{c, dd\}$

**$L_1 \cdot L_2$:**

Aplicando a definição $L_1 \cdot L_2 = \{xy \mid x \in L_1 \text{ e } y \in L_2\}$:

$$L_1 \cdot L_2 = \{ac, add, bbc, bbdd\}$$

**Cálculo detalhado:**
- $a \cdot c = ac$
- $a \cdot dd = add$  
- $bb \cdot c = bbc$
- $bb \cdot dd = bbdd$

**$L_2 \cdot L_1$:**

$$L_2 \cdot L_1 = \{ca, cbb, dda, ddbb\}$$

**Cálculo detalhado:**
- $c \cdot a = ca$
- $c \cdot bb = cbb$
- $dd \cdot a = dda$
- $dd \cdot bb = ddbb$

**Cardinalidade:**
$$|L_1 \cdot L_2| = |L_1| \times |L_2| = 2 \times 2 = 4$$
$$|L_2 \cdot L_1| = |L_2| \times |L_1| = 2 \times 2 = 4$$

**Verificação de comutatividade:**
$$L_1 \cdot L_2 = \{ac, add, bbc, bbdd\}$$
$$L_2 \cdot L_1 = \{ca, cbb, dda, ddbb\}$$

Como os conjuntos são distintos, $L_1 \cdot L_2 \neq L_2 \cdot L_1$. A concatenação de linguagens **não é comutativa**.

3. **Solução:**

**Dado:** $L = \{a, b\}$

**$L^0$:**
Por definição, $L^0 = \{\epsilon\}$ para qualquer linguagem $L$.

**$L^1$:**
$$L^1 = L = \{a, b\}$$

**$L^2$:**
$$L^2 = L \cdot L = \{xy \mid x \in L \text{ e } y \in L\}$$
$$L^2 = \{aa, ab, ba, bb\}$$

**Cálculo detalhado de $L^2$:**
- $a \cdot a = aa$
- $a \cdot b = ab$
- $b \cdot a = ba$ 
- $b \cdot b = bb$

**Fórmula para $|L^n|$:**

Como $|L| = 2$, temos:
$$|L^n| = |L|^n = 2^n$$

**Verificação:**
- $|L^0| = |\{\epsilon\}| = 1 = 2^0$ 
- $|L^1| = |\{a, b\}| = 2 = 2^1$   
- $|L^2| = |\{aa, ab, ba, bb\}| = 4 = 2^2$ 

**Três primeiras strings de $L^3$ em ordem lexicográfica:**

$L^3$ contém todas as strings de comprimento 3 sobre $\{a, b\}$.

Em ordem lexicográfica: $\{aaa, aab, aba, abb, baa, bab, bba, bbb\}$

**Três primeiras:** $aaa, aab, aba$

4. **Solução:**

**Dado:** $L = \{ab\}$

**Elementos de $L^*$ até strings de comprimento 6:**

Pela definição: $L^* = L^0 \cup L^1 \cup L^2 \cup L^3 \cup \ldots$

- $L^0 = \{\epsilon\}$
- $L^1 = \{ab\}$ (comprimento 2)
- $L^2 = \{ab \cdot ab\} = \{abab\}$ (comprimento 4)  
- $L^3 = \{ab \cdot ab \cdot ab\} = \{ababab\}$ (comprimento 6)

$$L^* \text{ até comprimento 6} = \{\epsilon, ab, abab, ababab\}$$

**$L^+$:**
$$L^+ = L^1 \cup L^2 \cup L^3 \cup \ldots = L^* - \{\epsilon\}$$
$$L^+ = \{ab, abab, ababab, abababab, \ldots\}$$

**Verificações:**

**$\epsilon \in L^*$?**
Sim, pois $\epsilon \in L^0$ e $L^0 \subseteq L^*$.

**$\epsilon \in L^+$?**
Não, pois $L^+ = L^1 \cup L^2 \cup \ldots$ e $\epsilon \notin L^n$ para $n \geq 1$ quando $L = \{ab\}$.

**Padrão geral:**
Como $L = \{ab\}$ contém apenas uma string de comprimento 2, temos:
$$L^* = \{\epsilon, ab, (ab)^2, (ab)^3, \ldots\} = \{(ab)^n \mid n \geq 0\}$$
$$L^+ = \{ab, (ab)^2, (ab)^3, \ldots\} = \{(ab)^n \mid n \geq 1\}$$

5. **Solução:**

**Dado:** $L = \{a\}$

**Propriedade 1: $L^* = L^+$?**

$$L^* = \{\epsilon, a, aa, aaa, \ldots\} = \{a^n \mid n \geq 0\}$$
$$L^+ = \{a, aa, aaa, \ldots\} = \{a^n \mid n \geq 1\}$$

Como $\epsilon \in L^*$ mas $\epsilon \notin L^+$, temos $L^* \neq L^+$.

**Resposta:** **FALSO**

**Propriedade 2: $L^* \cup L^+ = L^*$?**

Como $L^+ \subseteq L^*$ (pela definição $L^+ = L^* - \{\epsilon\}$ quando $\epsilon \notin L$), temos:
$$L^* \cup L^+ = L^*$$

**Resposta:** **VERDADEIRO**

**Propriedade 3: $(L^*)^* = L^*$?**

Esta é uma propriedade geral do fechamento de Kleene. 

**Demonstração:** 
- $(L^*)^*$ contém todas as concatenações possíveis de elementos de $L^*$
- Como $L^* = \{a^n \mid n \geq 0\}$, qualquer concatenação de elementos de $L^*$ resulta em $a^k$ para algum $k \geq 0$
- Portanto, $(L^*)^* \subseteq L^*$
- Como $L^* \subseteq (L^*)^*$ (pois $L^* \subseteq (L^*)^1 \subseteq (L^*)^*$), temos a igualdade

**Resposta:** **VERDADEIRO**

**Propriedade 4: Se $\epsilon \in L$, então $L^+ = L^*$?**

No nosso caso, $L = \{a\}$ e $\epsilon \notin L$, então a premissa é falsa.

Mas vamos analisar o caso geral: se $\epsilon \in L$, então:
- $L^* = L^0 \cup L^1 \cup L^2 \cup \ldots$
- $L^+ = L^1 \cup L^2 \cup L^3 \cup \ldots$
- Como $\epsilon \in L = L^1$, temos $\epsilon \in L^+$
- Como $\epsilon \in L^0$ também, e $L^+ \supseteq L^1$, de fato $L^+ = L^*$

**Resposta:** **VERDADEIRO** (propriedade geral válida)

**Para nosso caso específico:** A propriedade não se aplica pois $\epsilon \notin \{a\}$.

# Exercícios 4: @sec-ex-regex

1. **Solução:**

**$r_1 = a \cup b$**

Aplicando a regra indutiva para união:
$$L(r_1) = L(a \cup b) = L(a) \cup L(b) = \{a\} \cup \{b\} = \{a, b\}$$

**$r_2 = (a \cup b)(a \cup b)$**

Aplicando as regras de concatenação e união:
$$L(r_2) = L(a \cup b) \cdot L(a \cup b) = \{a, b\} \cdot \{a, b\}$$

Calculando o produto cartesiano:
$$L(r_2) = \{aa, ab, ba, bb\}$$

**$r_3 = a^*b$**

Aplicando as regras de fechamento de Kleene e concatenação:
$$L(r_3) = L(a^*) \cdot L(b) = L(a)^* \cdot \{b\} = \{a\}^* \cdot \{b\}$$

Como $\{a\}^* = \{\epsilon, a, aa, aaa, \ldots\} = \{a^n \mid n \geq 0\}$:
$$L(r_3) = \{a^n b \mid n \geq 0\} = \{b, ab, aab, aaab, \ldots\}$$

**$r_4 = (ab)^*$**

Aplicando a regra do fechamento de Kleene:
$$L(r_4) = L(ab)^* = \{ab\}^*$$

Como visto no exercício anterior:
$$L(r_4) = \{(ab)^n \mid n \geq 0\} = \{\epsilon, ab, abab, ababab, \ldots\}$$

2. **Solução:**

Lembrando a ordem de precedência (maior para menor): **Kleene ($*$)** → **Concatenação ($\cdot$)** → **União ($\cup$)**

**$ab^* \cup c$**

1. Primeiro, o fechamento de Kleene: $b^*$
2. Depois, a concatenação: $a(b^*)$  
3. Por fim, a união: $(a(b^*)) \cup c$

**Resultado:** $((a(b^*)) \cup c)$

**$a \cup bc^*$**

1. Primeiro, o fechamento de Kleene: $c^*$
2. Depois, a concatenação: $b(c^*)$
3. Por fim, a união: $a \cup (b(c^*))$

**Resultado:** $(a \cup (b(c^*)))$

**$ab \cup cd^*e$**

1. Primeiro, o fechamento de Kleene: $d^*$
2. Depois, as concatenações (da esquerda para direita): $(ab)$ e $(c(d^*)e)$
3. Por fim, a união: $(ab) \cup ((c(d^*))e)$

**Resultado:** $((ab) \cup (c((d^*)e)))$

**$a^*b^* \cup c^*$**

1. Primeiro, os fechamentos de Kleene: $a^*$, $b^*$, $c^*$
2. Depois, a concatenação: $(a^*)(b^*)$
3. Por fim, a união: $((a^*)(b^*)) \cup (c^*)$

**Resultado:** $(((a^*)(b^*)) \cup (c^*))$

3. **Solução:**

**Para $r = a^*ba^*$ e strings $\{ab, ba, aba, baa, bb\}$:**

$L(a^*ba^*) = \{a^i b a^j \mid i, j \geq 0\}$ (strings com exatamente um $b$, podendo ter qualquer quantidade de $a$'s antes e depois)

- **$ab$:** $ab = a^1 b a^0$ ∈ $L(r)$ 
- **$ba$:** $ba = a^0 b a^1$ ∈ $L(r)$   
- **$aba$:** $aba = a^1 b a^1$ ∈ $L(r)$ 
- **$baa$:** $baa = a^0 b a^2$ ∈ $L(r)$ 
- **$bb$:** Contém dois $b$'s, não pode ser expressa como $a^i b a^j$ ∉ $L(r)$ 

**Para $r = (a \cup b)^*b$ e strings $\{b, ab, ba, abb, bbb\}$:**

$L((a \cup b)^*b) = \{w b \mid w \in \{a,b\}^*\}$ (strings terminando com $b$)

- **$b$:** $b = \epsilon \cdot b$ ∈ $L(r)$ 
- **$ab$:** $ab = a \cdot b$ ∈ $L(r)$ 
- **$ba$:** Termina com $a$, não com $b$ ∉ $L(r)$ 
- **$abb$:** $abb = ab \cdot b$ ∈ $L(r)$   
- **$bbb$:** $bbb = bb \cdot b$ ∈ $L(r)$ 

4. **Solução:**
  
**Objetivo:** Calcular $L((a \cup b)c)$ usando a definição indutiva.

**Casos base identificados:**
- $L(a) = \{a\}$
- $L(b) = \{b\}$  
- $L(c) = \{c\}$

**Aplicação das regras indutivas:**

**Passo 1:** Calcular $L(a \cup b)$

Usando a regra da união: $L(r \cup s) = L(r) \cup L(s)$
$$L(a \cup b) = L(a) \cup L(b) = \{a\} \cup \{b\} = \{a, b\}$$

**Passo 2:** Calcular $L((a \cup b)c)$

Usando a regla da concatenação: $L(rs) = L(r) \cdot L(s)$
$$L((a \cup b)c) = L(a \cup b) \cdot L(c) = \{a, b\} \cdot \{c\}$$

**Passo 3:** Calcular o produto cartesiano
$$\{a, b\} \cdot \{c\} = \{ac, bc\}$$

**Resultado final:**
$$L((a \cup b)c) = \{ac, bc\}$$

5. **Solução:**

**$L_1 = \{a, b, aa, bb\}$**

Analisando o padrão: strings $a$ ou $b$, e strings $aa$ ou $bb$.

**Estratégia:** $(a \cup b) \cup (aa \cup bb) = (a \cup b) \cup (a \cup b)(a \cup b)$

Podemos fatorar: $(a \cup b)(1 \cup (a \cup b))$, mas isso não é uma expressão regular válida.

**Solução direta:**
$$r_1 = a \cup b \cup aa \cup bb$$

**Versão mais concisa:**
$$r_1 = (a \cup b) \cup (a \cup b)^2$$

**$L_2 = \{\epsilon, a, aa, aaa\}$**

Analisando: $\epsilon$, $a^1$, $a^2$, $a^3$.

**Estratégia:** União de potências específicas de $a$.
$$r_2 = \epsilon \cup a \cup a^2 \cup a^3$$

**Observação:** Não há uma forma mais concisa usando apenas as três operações básicas, pois precisamos limitar a 3 repetições de $a$.

**$L_3 = \{w \in \{a,b\}^* \mid w \text{ termina com } a\}$**

**Análise:** Qualquer sequência de $a$'s e $b$'s seguida obrigatoriamente por um $a$.

**Estratégia:** $(a \cup b)^* a$

**Verificação:**
- $L((a \cup b)^* a) = \{wa \mid w \in \{a,b\}^*\}$ 
- Isso corresponde exatamente a todas as strings sobre $\{a,b\}$ terminando com $a$

$$r_3 = (a \cup b)^*a$$

**Verificação com exemplos:**
- $a = \epsilon \cdot a$ ∈ $L(r_3)$ 
- $ba = b \cdot a$ ∈ $L(r_3)$   
- $aba = ab \cdot a$ ∈ $L(r_3)$ 
- $ab = a \cdot b$ ∉ $L(r_3)$  (não termina com $a$)

### Exercícios 5: @sec-ex-regex2

1. **Solução:**

**Strings terminando em $10$:**
$$r_1 = (0 \cup 1)^*10$$

**Verificação:** Qualquer sequência de 0's e 1's seguida obrigatoriamente por $10$.

**Strings começando com $01$:**
$$r_2 = 01(0 \cup 1)^*$$

**Verificação:** A string deve iniciar com $01$ seguido por qualquer sequência de 0's e 1's.

**Strings que contêm $01$ como substring:**
$$r_3 = (0 \cup 1)^*01(0 \cup 1)^*$$

**Verificação:** Qualquer sequência antes, $01$ obrigatório no meio, qualquer sequência depois.

**Strings que NÃO contêm $01$:**

**Análise:** Uma string não contém $01$ se nunca há um $0$ seguido diretamente por um $1$.

**Estratégia:** A string pode ter apenas:
- Sequências de $1$'s seguidas de sequências de $0$'s
- Ou apenas $1$'s
- Ou apenas $0$'s  
- Ou a string vazia

$$r_4 = 1^*0^*$$

**Justificativa:** Se há algum $0$ seguido de $1$, violaria o padrão $1^*0^*$.

2. **Solução:**

**Strings com número ímpar de $a$'s sobre $\{a,b\}$:**

**Estratégia:** Modificar o padrão do número par. Para ter número ímpar, precisamos de um número ímpar de grupos "um $a$".

$$r_1 = b^*a(b^*ab^*ab^*)^*b^*$$

**Explicação:**
- $b^*$: pode começar com $b$'s
- $a$: o primeiro $a$ (garantindo número ímpar)
- $(b^*ab^*ab^*)^*$: grupos de dois $a$'s (mantém a paridade ímpar)
- $b^*$: pode terminar com $b$'s

**Strings com número múltiplo de 3 de $a$'s:**

**Estratégia:** Agrupar os $a$'s de três em três.

$$r_2 = b^*(ab^*ab^*ab^*)^*b^*$$

**Explicação:**
- O grupo $(ab^*ab^*ab^*)$ contém exatamente 3 $a$'s
- A repetição $(...)^*$ permite 0, 3, 6, 9, ... $a$'s

**Strings com pelo menos dois $a$'s:**

**Estratégia:** Primeiro $a$, depois segundo $a$, depois qualquer coisa.

$$r_3 = (a \cup b)^*a(a \cup b)^*a(a \cup b)^*$$

**Simplificação alternativa:**
$$r_3 = b^*ab^*a(a \cup b)^*$$

3. **Solução:**

**Permitir underscores em qualquer posição:**

Alfabeto expandido: $\{a, \ldots, z, A, \ldots, Z, 0, \ldots, 9, \_\}$

$$r_1 = [a-zA-Z\_][a-zA-Z0-9\_]^*$$

**Proibir dígitos na primeira e última posições:**

**Estratégia:** 
- Primeiro: apenas letra ou underscore
- Meio: qualquer coisa permitida
- Último: apenas letra ou underscore

Para identificadores de 1 caractere:
$$\text{Caso 1: } [a-zA-Z\_]$$

Para identificadores de 2+ caracteres:
$$\text{Caso 2: } [a-zA-Z\_][a-zA-Z0-9\_]^*[a-zA-Z\_]$$

**Combinando:**
$$r_2 = [a-zA-Z\_] \cup [a-zA-Z\_][a-zA-Z0-9\_]^*[a-zA-Z\_]$$

**Identificadores entre 3 e 8 caracteres:**

$$r_3 = [a-zA-Z\_][a-zA-Z0-9\_]\{2,7\}$$

**Explicação:**
- $[a-zA-Z\_]$: primeiro caractere (1 caractere)
- $[a-zA-Z0-9\_]\{2,7\}$: de 2 a 7 caracteres adicionais
- Total: 3 a 8 caracteres

4. **Solução:**

**Números decimais (com ponto decimal):**

$$r_1 = (\epsilon \cup + \cup -)[0-9]^*\.[0-9]^+$$

**Análise:**
- Sinal opcional: $(\epsilon \cup + \cup -)$
- Parte inteira opcional: $[0-9]^*$ 
- Ponto obrigatório: $\.$
- Parte decimal obrigatória: $[0-9]^+$

**Versão mais robusta (evitando apenas ".123"):**
$$r_1' = (\epsilon \cup + \cup -)([0-9]^+\.[0-9]^* \cup [0-9]^*\.[0-9]^+)$$

**Notação científica simples ($1e5$, $2e-3$):**

$$r_2 = (\epsilon \cup + \cup -)[0-9]^+e(\epsilon \cup + \cup -)[0-9]^+$$

**Explicação:**
- Sinal opcional: $(\epsilon \cup + \cup -)$
- Mantissa: $[0-9]^+$ (pelo menos um dígito)
- Literal 'e': $e$
- Sinal do expoente opcional: $(\epsilon \cup + \cup -)$
- Expoente: $[0-9]^+$

**Números hexadecimais com prefixo $0x$:**

$$r_3 = 0x[0-9a-fA-F]^+$$

**Explicação:**
- Prefixo obrigatório: $0x$
- Dígitos hex: $[0-9a-fA-F]^+$ (pelo menos um)

5. **Solução:**

**Verificação para "termina em 10" ($r = (0 \cup 1)^*10$):**

- **$101$:** Termina em $01$, não em $10$ → **NÃO** pertence
- **$1010$:** Termina em $10$ → **SIM** pertence  
- **$0101$:** Termina em $01$, não em $10$ → **NÃO** pertence

**Verificação para número ímpar de $a$'s ($r = b^*a(b^*ab^*ab^*)^*b^*$):**

- **$aab$:** 
  - Contagem de $a$'s: 2 (par) → **NÃO** pertence
  
- **$baba$:** 
  - Contagem de $a$'s: 2 (par) → **NÃO** pertence
  
- **$ababa$:** 
  - Contagem de $a$'s: 3 (ímpar) → **SIM** pertence

**Verificação para identificadores com underscores ($r = [a-zA-Z\_][a-zA-Z0-9\_]^*$):**

- **$var\_1$:**
  - Primeiro: $v$ (letra) 
  - Resto: $ar\_1$ (letras, underscore, dígito) 
  - → **SIM** é válido
  
- **$\_temp$:**
  - Primeiro: $\_$ (underscore)   
  - Resto: $temp$ (letras) 
  - → **SIM** é válido
  
- **$item2\_$:**
  - Primeiro: $i$ (letra) 
  - Resto: $tem2\_$ (letras, dígito, underscore) 
  - → **SIM** é válido

**Resumo dos resultados:**

| String | Termina em 10 | Ímpar de $a$'s | ID com underscore |
|--------|---------------|----------------|-------------------|
| $101$ |  | - | - |
| $1010$ |  | - | - |  
| $0101$ |  | - | - |
| $aab$ | - |  | - |
| $baba$ | - |  | - |
| $ababa$ | - |  | - |
| $var\_1$ | - | - |  |
| $\_temp$ | - | - |  |
| $item2\_$ | - | - |  |

### Exercícios 6: {@sec-ex-regex3}

1. **Solução:**

**$(a \cup \emptyset)b$**

Aplicando a lei do elemento neutro da união: $r \cup \emptyset \equiv r$
$$(a \cup \emptyset)b \equiv ab$$

**$a(\epsilon \cup b)$**

Aplicando a distributividade: $r(s \cup t) \equiv rs \cup rt$
$$a(\epsilon \cup b) \equiv a\epsilon \cup ab$$

Aplicando a lei do elemento neutro da concatenação: $r\epsilon \equiv r$
$$a\epsilon \cup ab \equiv a \cup ab$$

**$(a \cup a)^*$**

Aplicando a idempotência da união: $r \cup r \equiv r$
$$(a \cup a)^* \equiv a^*$$

**$a \cup ab^*a$**

Aplicando a distributividade: $rs \cup rt \equiv r(s \cup t)$

Primeiro, fatoramos $a$:
$$a \cup ab^*a \equiv a\epsilon \cup ab^*a \equiv a(\epsilon \cup b^*a)$$

Como $\epsilon \cup b^*a$ não pode ser simplificado usando apenas as leis básicas, a expressão mais simples é:
$$a \cup ab^*a$$

**Nota:** Esta expressão pode ser simplificada para $ab^*a$ usando propriedades mais avançadas, pois $\epsilon \in b^*$.

2. **Solução:**

**Objetivo:** Simplificar $((a \cup b)a) \cup (aa)$

**Expressão inicial:**
$$((a \cup b)a) \cup (aa)$$

**Passo 1:** Aplicar distributividade em $(a \cup b)a$
$$((a \cup b)a) = (aa \cup ba)$$

**Passo 2:** Substituir na expressão original
$$(aa \cup ba) \cup (aa)$$

**Passo 3:** Aplicar associatividade da união
$$aa \cup ba \cup aa$$

**Passo 4:** Aplicar comutatividade para agrupar termos iguais
$$aa \cup aa \cup ba$$

**Passo 5:** Aplicar idempotência da união: $r \cup r \equiv r$
$$aa \cup ba$$

**Passo 6:** Aplicar distributividade reversa
$$aa \cup ba \equiv (a \cup b)a$$

**Resultado final:**
$$((a \cup b)a) \cup (aa) \equiv (a \cup b)a$$

**Verificação com strings específicas:**
- Original aceita: $\{aa, ba\}$
- Simplificada aceita: $\{aa, ba\}$ 

3. **Solução:**

**$a^*a$ e $aa^*$**

**Demonstração:**

Para $a^*a$:
$$L(a^*a) = L(a^*) \cdot L(a) = \{a^n \mid n \geq 0\} \cdot \{a\} = \{a^{n+1} \mid n \geq 0\} = \{a^m \mid m \geq 1\}$$

Para $aa^*$:
$$L(aa^*) = L(a) \cdot L(a^*) = \{a\} \cdot \{a^n \mid n \geq 0\} = \{a^{1+n} \mid n \geq 0\} = \{a^m \mid m \geq 1\}$$

Como $L(a^*a) = L(aa^*) = \{a^m \mid m \geq 1\}$, temos:
$$a^*a \equiv aa^*$$

**$(a \cup b)^*$ e $\epsilon \cup (a \cup b)(a \cup b)^*$**

**Demonstração:**

Para o lado direito, aplicando a definição recursiva do fechamento de Kleene:
$$L^* = \epsilon \cup LL^*$$

Substituindo $L = (a \cup b)$:
$$L((a \cup b)^*) = \{\epsilon\} \cup L(a \cup b) \cdot L((a \cup b)^*)$$
$$= \{\epsilon\} \cup L((a \cup b)(a \cup b)^*)$$
$$= L(\epsilon \cup (a \cup b)(a \cup b)^*)$$

Portanto:
$$(a \cup b)^* \equiv \epsilon \cup (a \cup b)(a \cup b)^*$$

**$a^*b^*$ e $(a \cup b)^*$ - esta é FALSA**

**Contraexemplo:**
- $ab \in L((a \cup b)^*)$ (qualquer intercalação de $a$'s e $b$'s)
- $ab \notin L(a^*b^*)$ (pois $a^*b^*$ só aceita todos os $a$'s seguidos de todos os $b$'s)

Portanto: $a^*b^* \not\equiv (a \cup b)^*$

4. **Solução:**

**$(a^*)^*$**

Aplicando a lei do fechamento do fechamento: $(r^*)^* \equiv r^*$
$$(a^*)^* \equiv a^*$$

**$\epsilon^* \cup a^*$**

Aplicando a lei: $\epsilon^* \equiv \epsilon$
$$\epsilon^* \cup a^* \equiv \epsilon \cup a^*$$

Como $\epsilon \in L(a^*)$ (pois $a^* = \{a^n \mid n \geq 0\}$ e $\epsilon = a^0$):
$$\epsilon \cup a^* \equiv a^*$$

**$\emptyset^* \cup a$**

Aplicando a lei: $\emptyset^* \equiv \epsilon$
$$\emptyset^* \cup a \equiv \epsilon \cup a$$

Esta expressão não pode ser simplificada mais.

**$(a \cup \epsilon)^*$**

Como $\epsilon \in L(a \cup \epsilon)$, pela propriedade do fechamento de Kleene quando $\epsilon$ está presente:
$$L((a \cup \epsilon)^*) = L(a^*)$$

Portanto:
$$(a \cup \epsilon)^* \equiv a^*$$

5. **Solução:**

**Objetivo:** Simplificar $ab^* \cup abb^* \cup abbb^*$

**Identificação do padrão comum:**

Todos os termos começam com $a$ seguido de pelo menos um $b$:
- $ab^* = a(b^*)$ contém $ab^0, ab^1, ab^2, \ldots$
- $abb^* = a(bb^*)$ contém $ab^1, ab^2, ab^3, \ldots$  
- $abbb^* = a(bbb^*)$ contém $ab^2, ab^3, ab^4, \ldots$

**Análise dos conjuntos:**
- $L(ab^*) = \{a, ab, abb, abbb, \ldots\}$
- $L(abb^*) = \{ab, abb, abbb, \ldots\}$  
- $L(abbb^*) = \{abb, abbb, abbbb, \ldots\}$

**Observação:** $L(abb^*) \subseteq L(ab^*)$ e $L(abbb^*) \subseteq L(ab^*)$

**Aplicação da distributividade:**

$$ab^* \cup abb^* \cup abbb^* \equiv a(b^* \cup bb^* \cup bbb^*)$$

**Simplificação do termo entre parênteses:**

Como $bb^* \subseteq b^*$ e $bbb^* \subseteq b^*$:
$$b^* \cup bb^* \cup bbb^* \equiv b^*$$

**Resultado final:**
$$ab^* \cup abb^* \cup abbb^* \equiv ab^*$$

**Verificação da equivalência:**

**Linguagem original:**
$$L(ab^* \cup abb^* \cup abbb^*) = L(ab^*) \cup L(abb^*) \cup L(abbb^*)$$
$$= \{a, ab, abb, \ldots\} \cup \{ab, abb, \ldots\} \cup \{abb, abbb, \ldots\}$$
$$= \{a, ab, abb, abbb, \ldots\}$$

**Linguagem simplificada:**
$$L(ab^*) = \{a, ab, abb, abbb, \ldots\}$$

Como os conjuntos são idênticos, a simplificação está correta.

**Benefício da otimização:**
- **Expressão original:** 3 termos unidos
- **Expressão otimizada:** 1 termo simples
- **Eficiência:** Redução significativa na complexidade de avaliação

### Exercícios 7: {@sec-ex-regex4}

1. **Solução:**

**$a^+$**

Por definição: $r^+ \equiv rr^*$
$$a^+ \equiv aa^*$$

**$b?$**

Por definição: $r? \equiv (\epsilon \cup r)$
$$b? \equiv (\epsilon \cup b)$$

**$[abc]$**

Classes de caracteres são equivalentes à união:
$$[abc] \equiv (a \cup b \cup c)$$

**$a\{3\}$**

Repetição exata significa concatenação repetida:
$$a\{3\} \equiv aaa$$

**$b\{2,4\}$**

Repetição de 2 a 4 vezes:
$$b\{2,4\} \equiv bb \cup bbb \cup bbbb$$

Ou usando concatenação e opcionalidade:
$$b\{2,4\} \equiv bb(\epsilon \cup b)(\epsilon \cup b)$$

2. **Solução:**

**Qualquer dígito: $[0-9]$**

$$[0-9] \equiv (0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)$$

**Qualquer letra minúscula: $[a-z]$**

$$[a-z] \equiv (a \cup b \cup c \cup \ldots \cup z)$$

**Qualquer caractere que não seja espaço: $[^ ]$**

Assumindo um alfabeto básico ASCII $\Sigma = \{a, b, \ldots, z, A, B, \ldots, Z, 0, 1, \ldots, 9, \text{ }, !, @, \#, \ldots\}$:

$$[^ ] \equiv (a \cup b \cup \ldots \cup z \cup A \cup \ldots \cup Z \cup 0 \cup \ldots \cup 9 \cup ! \cup @ \cup \ldots)$$

**Nota:** Esta seria a união de todos os símbolos do alfabeto exceto o espaço.

**Qualquer caractere alfanumérico: $[a-zA-Z0-9]$**

$$[a-zA-Z0-9] \equiv (a \cup b \cup \ldots \cup z \cup A \cup B \cup \ldots \cup Z \cup 0 \cup 1 \cup \ldots \cup 9)$$

3. **Solução:**

**CEP brasileiro no formato $99999-999$:**

$$r_1 = [0-9]\{5\}-[0-9]\{3\}$$

**Expandindo:**
$$r_1 \equiv [0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9]$$

**Placa de carro brasileira antiga $AAA-9999$:**

$$r_2 = [A-Z]\{3\}-[0-9]\{4\}$$

**Expandindo:**
$$r_2 \equiv [A-Z][A-Z][A-Z]-[0-9][0-9][0-9][0-9]$$

**Senha com exatamente 8 caracteres alfanuméricos:**

$$r_3 = [a-zA-Z0-9]\{8\}$$

**Expandindo:**
$$r_3 \equiv [a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9]$$

**Código de área de telefone com 2 ou 3 dígitos:**

$$r_4 = [0-9]\{2,3\}$$

**Expandindo:**
$$r_4 \equiv [0-9][0-9] \cup [0-9][0-9][0-9]$$

4. **Solução:**

**URL simples começando com $http$ ou $https$:**

$$r_1 = https?://[a-zA-Z0-9.-]^+$$

**Expandindo:**
$$r_1 \equiv (http \cup https)://[a-zA-Z0-9.-]^+$$
$$\equiv http(\epsilon \cup s)://[a-zA-Z0-9.-]^+$$

**Data no formato $dd/mm/aaaa$ (versão simples):**

$$r_2 = [0-9]\{2\}/[0-9]\{2\}/[0-9]\{4\}$$

**Expandindo:**
$$r_2 \equiv [0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]$$

**Horário no formato $hh:mm$ (24 horas):**

$$r_3 = ([01][0-9] \cup 2[0-3]):[0-5][0-9]$$

**Explicação:**
- $([01][0-9] \cup 2[0-3])$: horas de 00-19 ou 20-23
- $:[0-5][0-9]$: minutos de 00-59

**Número de CPF no formato $999.999.999-99$:**

$$r_4 = [0-9]\{3\}\.[0-9]\{3\}\.[0-9]\{3\}-[0-9]\{2\}$$

**Expandindo:**
$$r_4 \equiv [0-9][0-9][0-9]\.[0-9][0-9][0-9]\.[0-9][0-9][0-9]-[0-9][0-9]$$

5. **Solução:**

**$(a \cup b \cup c \cup d)(a \cup b \cup c \cup d)^*$**

**Usando classes de caracteres:**
$$[abcd][abcd]^*$$

**Usando fechamento positivo:**
$$[abcd]^+$$

**Expandindo $[abcd]^+$:**
$$[abcd]^+ \equiv [abcd][abcd]^* \equiv [abcd](\epsilon \cup [abcd][abcd]^*)$$

**$a(\epsilon \cup b)$**

**Usando opcionalidade:**
$$ab?$$

**Expandindo:**
$$ab? \equiv a(\epsilon \cup b)$$

**$(0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)(0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)^*$**

**Usando classes de caracteres:**
$$[0-9][0-9]^*$$

**Usando fechamento positivo:**
$$[0-9]^+$$

**Comparação das otimizações:**

| Expressão Original | Versão Otimizada | Redução |
|-------------------|------------------|---------|
| $(a \cup b \cup c \cup d)(a \cup b \cup c \cup d)^*$ | $[abcd]^+$ | 90% |
| $a(\epsilon \cup b)$ | $ab?$ | 70% |
| $(0 \cup 1 \cup \ldots \cup 9)(0 \cup 1 \cup \ldots \cup 9)^*$ | $[0-9]^+$ | 95% |

**Benefícios da otimização:**

1. **Legibilidade:** As notações convencionais são muito mais fáceis de ler e entender
2. **Manutenibilidade:** Modificações (como adicionar novos caracteres) são mais simples
3. **Eficiência:** Implementações podem otimizar melhor as notações convencionais
4. **Menos propenso a erros:** Reduz a chance de esquecer casos em uniões longas

**Exemplo prático:**

Para aceitar qualquer letra maiúscula ou minúscula:

**Versão expandida (52 termos!):**
$$(A \cup B \cup C \cup \ldots \cup Z \cup a \cup b \cup c \cup \ldots \cup z)$$

**Versão otimizada:**
$$[a-zA-Z]$$

A redução é de aproximadamente **98%** no tamanho da expressão!

### Exercícios 8: {@sec-ex-regex5}

1. **Solução:**

**Palavras-chave: $\{\text{if}, \text{then}, \text{else}, \text{while}, \text{do}\}$**

$$r_1 = \text{if} \cup \text{then} \cup \text{else} \cup \text{while} \cup \text{do}$$

**Implementação mais eficiente:**
$$r_1 = \text{if} \cup \text{then} \cup \text{else} \cup \text{while} \cup \text{do}$$

**Números inteiros (incluindo negativos):**

$$r_2 = -?([1-9][0-9]^* \cup 0)$$

**Explicação:**
- $-?$: sinal negativo opcional
- $([1-9][0-9]^* \cup 0)$: número sem zeros à esquerda ou apenas zero

**Comentários de linha iniciados por $//$ até o final da linha:**

$$r_3 = //[^\n]^*$$

**Explicação:**
- $//$ literal
- $[^\n]^*$: qualquer caractere exceto nova linha, zero ou mais vezes

**Operadores relacionais: $\{<, >, <=, >=, ==, !=\}$**

$$r_4 = <= \cup >= \cup == \cup != \cup < \cup >$$

**Observação:** A ordem é importante - operadores de dois caracteres devem vir antes dos de um caractere para evitar conflitos durante o parsing.

2. **Solução:**

**Telefone celular: $(11) 99999-9999$**

$$r_1 = \([0-9]\{2\} [0-9]\{5\}-[0-9]\{4\}$$

**Versão mais flexível (com espaço opcional):**
$$r_1' = \([0-9]\{2\) ?[0-9]\{5\}-[0-9]\{4\}$$

**RG: $99.999.999-9$**

$$r_2 = [0-9]\{2\}\.[0-9]\{3\}\.[0-9]\{3\}-[0-9]$$

**CNPJ: $99.999.999/9999-99$**

$$r_3 = [0-9]\{2\}\.[0-9]\{3\}\.[0-9]\{3\}/[0-9]\{4\}-[0-9]\{2\}$$

**CEP: $99999-999$ ou $99.999-999$**

$$r_4 = [0-9]\{5\}[-.]?[0-9]\{3\}$$

**Explicação:**
- $[0-9]\{5\}$: cinco dígitos iniciais
- $[-.]?$: hífen ou ponto opcional (alguns CEPs não têm separador)
- $[0-9]\{3\}$: três dígitos finais

3. **Solução:**

**Endereços de email em um texto:**

$$r_1 = [a-zA-Z0-9._%+-]^+@[a-zA-Z0-9.-]^+\.[a-zA-Z]\{2,\}$$

**Explicação:**
- $[a-zA-Z0-9._%+-]^+$: parte local (antes do @)
- $@$: símbolo obrigatório
- $[a-zA-Z0-9.-]^+$: domínio
- $\.$: ponto literal
- $[a-zA-Z]\{2,\}$: extensão com pelo menos 2 letras

**Valores monetários no formato $R\$ 99,99$:**

$$r_2 = R\$ ?[0-9]^+,[0-9]\{2\}$$

**Versão mais robusta:**
$$r_2' = R\$ ?[0-9]\{1,3\}(\.[0-9]\{3\})^*,[0-9]\{2\}$$

**Explicação da versão robusta:**
- $[0-9]\{1,3\}$: 1 a 3 dígitos iniciais
- $(\.[0-9]\{3\})^*$: grupos de 3 dígitos separados por ponto (milhares)
- $,[0-9]\{2\}$: vírgula e centavos

**Datas em formatos variados: $dd/mm/aaaa$, $dd-mm-aaaa$, $dd.mm.aaaa$**

$$r_3 = [0-9]\{2\}[/.-][0-9]\{2\}[/.-][0-9]\{4\}$$

**Versão mais específica (garantindo consistência do separador):**
$$r_3' = ([0-9]\{2\}/[0-9]\{2\}/[0-9]\{4\}) \cup ([0-9]\{2\}-[0-9]\{2\}-[0-9]\{4\}) \cup ([0-9]\{2\}\.[0-9]\{2\}\.[0-9]\{4\})$$

**Números de cartão de crédito (formato $9999-9999-9999-9999$):**

$$r_4 = [0-9]\{4\}-[0-9]\{4\}-[0-9]\{4\}-[0-9]\{4\}$$

**Versão flexível (com separadores opcionais):**
$$r_4' = [0-9]\{4\} ?-? ?[0-9]\{4\} ?-? ?[0-9]\{4\} ?-? ?[0-9]\{4\}$$

4. **Solução:**

**Para validar email: $[a-z]+@[a-z]+.[a-z]+$ (problema: ponto literal)**

**Problema identificado:** O ponto $.$ é um metacaractere que corresponde a "qualquer caractere". Para representar um ponto literal, deve ser escapado.

**Correção:**
$$[a-z]^+@[a-z]^+\.[a-z]^+$$

**Melhorias adicionais:**
- Incluir maiúsculas e números: $[a-zA-Z0-9]^+@[a-zA-Z0-9]^+\.[a-zA-Z]\{2,\}$
- Permitir caracteres especiais válidos: $[a-zA-Z0-9._%+-]^+@[a-zA-Z0-9.-]^+\.[a-zA-Z]\{2,\}$

**Para números decimais: $[0-9]*.[0-9]*$ (problema: pontos opcionais)**

**Problemas identificados:**
1. Ponto não escapado (deveria ser $\.$)
2. Ambas as partes são opcionais (aceita strings como "." vazia)

**Correção:**
$$[0-9]^+\.[0-9]^+ \cup [0-9]^+\. \cup \.[0-9]^+$$

**Versão mais simples:**
$$([0-9]^+\.[0-9]^*) \cup ([0-9]^*\.[0-9]^+)$$

**Para identificadores: $[a-zA-Z][a-zA-Z0-9]?$ (problema: comprimento mínimo)**

**Problema identificado:** O $?$ torna o segundo caractere opcional, permitindo identificadores de apenas 1 caractere, mas limitando a 2 caracteres no máximo.

**Correção para identificadores normais:**
$$[a-zA-Z][a-zA-Z0-9]^*$$

**Se realmente quiser 1-2 caracteres apenas:**
$$[a-zA-Z][a-zA-Z0-9]?$$

5. **Solução:**

**$(abc|abd|abe) \rightarrow ab(c|d|e)$**

**Análise:** Fatoração do prefixo comum $ab$.

**Verificação da equivalência:**
- Original: $\{abc, abd, abe\}$
- Otimizada: $ab(c \cup d \cup e) = ab \{c, d, e\} = \{abc, abd, abe\}$ 

**Benefício:** Reduz backtracking em implementações, pois $ab$ só precisa ser verificado uma vez.

**$[0-9][0-9][0-9][0-9] \rightarrow [0-9]\{4\}$**

**Análise:** Uso de quantificador para repetição.

**Verificação da equivalência:**
- Ambas aceitam exatamente sequências de 4 dígitos 

**Benefício:** Mais conciso, e muitas implementações otimizam quantificadores internamente.

**$(a^*b^*|b^*a^*) \rightarrow (a|b)^*$ - VERIFICAÇÃO NECESSÁRIA**

**Análise da equivalência:**

**Lado esquerdo:** $(a^*b^*) \cup (b^*a^*)$
- $a^*b^*$: zero ou mais $a$'s seguidos de zero ou mais $b$'s
- $b^*a^*$: zero ou mais $b$'s seguidos de zero ou mais $a$'s
- União: strings da forma $a^i b^j$ ou $b^k a^l$

**Lado direito:** $(a \cup b)^*$
- Qualquer sequência de $a$'s e $b$'s em qualquer ordem

**Contraexemplo:** A string $aba$
- $aba \in L((a|b)^*)$ 
- $aba \notin L(a^*b^*)$ (pois tem $a$ após $b$)
- $aba \notin L(b^*a^*)$ (pois tem $b$ entre $a$'s)
- Portanto: $aba \notin L((a^*b^*|b^*a^*))$

**Conclusão:** As expressões **NÃO** são equivalentes.

**Análise de performance:**

| Expressão | Eficiência | Observações |
|-----------|------------|-------------|
| $ab(c\|d\|e)$ | ⭐⭐⭐⭐⭐ | Evita backtracking desnecessário |
| $[0-9]\{4\}$ | ⭐⭐⭐⭐⭐ | Otimização interna comum |
| $(a\|b)^*$ vs $(a^*b^*\|b^*a^*)$ | ⭐⭐⭐ vs ⭐⭐ | Primeira é mais eficiente, mas não equivalente |

**Recomendações gerais para performance:**

1. **Fatore prefixos comuns** para reduzir backtracking
2. **Use quantificadores** em vez de repetição manual
3. **Evite alternativas desnecessárias** quando uma expressão mais simples serve
4. **Coloque alternativas mais prováveis primeiro** em uniões
5. **Use classes de caracteres** em vez de uniões longas de caracteres individuais

**Exemplo de otimização completa:**

**Antes:** $(http|https)://[a-z][a-z][a-z]*\.(com|org|net|edu)$

**Depois:** $https?://[a-z]^+\.(com|org|net|edu)$

Benefícios: prefixo comum fatorado, quantificador usado, expressão mais concisa.
