# Solução dos Exercícios

## Capítulo: @sec-alfabeto-linguagem-string

### Exercícios 1: @sec-ex-alfabeto

1. **Solução:**

- **$\Sigma_1 = \{a, b, c, +, -, *, /, (, )\}$**
  
  Contando cada símbolo: $a, b, c, +, -, *, /, (, )$
  
  $$|\Sigma_1| = 9$$

- **$\Sigma_2 = \{0, 1, 2, \ldots, 9, A, B, C, D, E, F\}$ (hexadecimal)**
  
  Dígitos decimais: $\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$ → 10 símbolos
  
  Letras hexadecimais: $\{A, B, C, D, E, F\}$ → 6 símbolos
  
  $$|\Sigma_2| = 10 + 6 = 16$$

- **$\Sigma_3 = \{\text{verdadeiro}, \text{falso}, \land, \lor, \neg, (, )\}$**
  
  Contando cada símbolo: $\text{verdadeiro}, \text{falso}, \land, \lor, \neg, (, )$
  
  $$|\Sigma_3| = 7$$

2. **Solução:**

- **Expressões lógicas booleanas simples com variáveis $p$, $q$, $r$:**
  
  $$\Sigma_{\text{bool}} = \{p, q, r, \land, \lor, \neg, (, )\}$$
  
  **Justificativa:** Inclui as três variáveis proposicionais, os conectivos lógicos básicos (conjunção, disjunção, negação) e parênteses para agrupamento.

- **Números em notação científica (ex: $1.23 \times 10^{-4}$):**
  
  $$\Sigma_{\text{cient}} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, -, ., \times, ^{}, 1, 0\}$$
  
  Ou de forma mais concisa:
  
  $$\Sigma_{\text{cient}} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, -, ., \times, ^\}$$
  
  **Justificativa:** Inclui dígitos para o número base, sinais para número e expoente, ponto decimal, símbolo de multiplicação e símbolo de potência.

- **Coordenadas cartesianas no formato $(x, y)$:**
  
  $$\Sigma_{\text{coord}} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, -, ., (, ), ,\}$$
  
  **Justificativa:** Inclui dígitos para números, sinais, ponto decimal, parênteses para delimitação e vírgula como separador.

3. **Solução:**

- **$A = \emptyset$**
  
  **NÃO é um alfabeto válido.**
  
  **Justificativa:** A definição formal exige que um alfabeto seja um conjunto finito **não-vazio**. Como $A$ é o conjunto vazio, ele viola a condição $n \geq 1$.

- **$B = \{\epsilon\}$**
  
  **É um alfabeto válido.**
  
  **Justificativa:** É um conjunto finito ($|B| = 1$) e não-vazio. O símbolo $\epsilon$ pode ser tratado como um símbolo atômico qualquer para fins de definição de alfabeto.

- **$C = \{1, 2, 3, \ldots\}$**
  
  **NÃO é um alfabeto válido.**
  
  **Justificativa:** Este é o conjunto dos números naturais positivos, que é infinito ($|C| = \infty$). A definição de alfabeto exige finitude.

- **$D = \{a, b, a\}$**
  
  **É um alfabeto válido, mas equivalente a $\{a, b\}$.**
  
  **Justificativa:** Como conjuntos não possuem elementos repetidos, $D = \{a, b\}$. É finito ($|D| = 2$) e não-vazio, portanto é um alfabeto válido.

4. **Solução:**

Dado $S = \{\text{if}, \text{then}, \text{else}, \text{fi}\}$, precisamos encontrar todos os símbolos que aparecem nas strings:

- $\text{if}$: símbolos $i, f$
- $\text{then}$: símbolos $t, h, e, n$  
- $\text{else}$: símbolos $e, l, s, e$ (note que $e$ se repete)
- $\text{fi}$: símbolos $f, i$

Coletando todos os símbolos únicos:

$$\Sigma_{\text{mín}} = \{e, f, h, i, l, n, s, t\}$$

**Cardinalidade:** $|\Sigma_{\text{mín}}| = 8$

**Verificação:** Todas as strings em $S$ podem ser formadas usando apenas estes símbolos, e nenhum símbolo pode ser removido sem impossibilitar a formação de pelo menos uma string.

5. **Solução:**

Comparando $\Sigma_A = \{0, 1\}$ e $\Sigma_B = \{a, b, c\}$:

**Cardinalidade:**
- $|\Sigma_A| = 2$
- $|\Sigma_B| = 3$

**Número de strings de comprimento 3:**

Para um alfabeto de tamanho $n$, o número de strings de comprimento $k$ é $n^k$.

- Para $\Sigma_A$: $|\Sigma_A|^3 = 2^3 = 8$ strings
  
  Strings: $\{000, 001, 010, 011, 100, 101, 110, 111\}$

- Para $\Sigma_B$: $|\Sigma_B|^3 = 3^3 = 27$ strings
  
  Exemplos: $\{aaa, aab, aac, aba, abb, abc, \ldots, ccc\}$

**Aplicabilidade para representar números binários:**

- **$\Sigma_A$:** Perfeitamente adequado para representação binária, pois contém exatamente os símbolos $0$ e $1$ necessários.

- **$\Sigma_B$:** Inadequado para representação binária direta. Seria necessário estabelecer uma convenção de mapeamento (por exemplo, $a \rightarrow 0$, $b \rightarrow 1$, e $c$ seria um símbolo extra não utilizado).

**Conclusão:** $\Sigma_A$ é mais eficiente para representação binária, enquanto $\Sigma_B$ oferece maior capacidade expressiva para outras aplicações devido ao seu maior tamanho.

### Exercícios 2: @sec-ex-strings

1. **Solução:**

**Dado:** $x = ab$ e $y = cd$

**Concatenações:**
- $xy = ab \cdot cd = abcd$
- $yx = cd \cdot ab = cdab$

**Observação:** Note que $xy \neq yx$, demonstrando que a concatenação não é comutativa.

**Potências:**
- $x^3 = (ab)^3 = ab \cdot ab \cdot ab = ababab$
- $y^2 = (cd)^2 = cd \cdot cd = cdcd$

**Potências de concatenações:**
- $(xy)^2 = (abcd)^2 = abcd \cdot abcd = abcdabcd$
- $x^2y^2 = (ab)^2(cd)^2 = abab \cdot cdcd = ababcdcd$

**Observação:** $(xy)^2 \neq x^2y^2$, mostrando que $(uv)^n \neq u^nv^n$ em geral.

**Comprimento de $x^n$:**

Como $|x| = |ab| = 2$, temos:

$$|x^n| = n \cdot |x| = n \cdot 2 = 2n$$

**Verificação:** $|x^3| = |ababab| = 6 = 2 \cdot 3$ 

2. **Solução:**

**Aplicando a definição recursiva $\epsilon^R = \epsilon$ e $(wa)^R = aw^R$:**

- **$w_1 = abcde$**
  
  Aplicando passo a passo:
  $$w_1^R = (abcde)^R = e(abcd)^R = ed(abc)^R = edc(ab)^R = edcb(a)^R = edcba$$

- **$w_2 = palindromo$**
  
  $$w_2^R = (palindromo)^R = omordnilap$$

- **$w_3 = \epsilon$ (string vazia)**
  
  $$w_3^R = \epsilon^R = \epsilon$$

**Prova de que $(\epsilon)^R = \epsilon$:**

**Demonstração:** Pela definição recursiva, o caso base estabelece diretamente que $\epsilon^R = \epsilon$. Isso é consistente, pois a string vazia não possui símbolos para inverter, mantendo-se inalterada.

3. **Solução:**

**Associatividade:** $(xy)z = x(yz)$ para $x = a$, $y = bc$, $z = d$

$$\text{Lado esquerdo: } (xy)z = (a \cdot bc)d = (abc)d = abcd$$
$$\text{Lado direito: } x(yz) = a(bc \cdot d) = a(bcd) = abcd$$

$$\therefore (xy)z = x(yz) = abcd$$

**Elemento neutro:** $w\epsilon = \epsilon w = w$ para $w = abc$

$$w\epsilon = abc \cdot \epsilon = abc$$
$$\epsilon w = \epsilon \cdot abc = abc$$

$$\therefore w\epsilon = \epsilon w = w = abc$$

**Não-comutatividade:** Encontrar $x$ e $y$ tais que $xy \neq yx$

**Exemplo:** $x = a$ e $y = b$

$$xy = a \cdot b = ab$$
$$yx = b \cdot a = ba$$

Como $ab \neq ba$, a concatenação não é comutativa.

4. **Solução:**

**Dado:** $w = compilador$

**Prefixos próprios** (todos os prefixos exceto a própria string):

$$\{\epsilon, c, co, com, comp, compi, compil, compila, compilado\}$$

**Total de prefixos próprios:** 9

**Sufixos próprios** (todos os sufixos exceto a própria string):

$$\{\epsilon, r, or, dor, ador, lador, ilador, pilador, mpilador\}$$

**Total de sufixos próprios:** 9

**Substrings de comprimento 4:**

Posições possíveis para substrings de comprimento 4 em uma string de comprimento 10:

$$\{comp, ompi, mpil, pila, ilad, lado, ador\}$$

**Total de substrings de comprimento 4:** 7

**Contagem total:**
- **Prefixos totais:** 10 (incluindo $\epsilon$ e a própria string)
- **Sufixos totais:** 10 (incluindo $\epsilon$ e a própria string)

**Fórmula geral:** Para uma string de comprimento $n$, existem $n+1$ prefixos e $n+1$ sufixos.

5. **Solução:**

**Dado:** $w = aba$

**Cálculo de $w^R$:**
$$w^R = (aba)^R = a(ba)^R = ab(a)^R = aba$$

**Observação:** $w = aba$ é um palíndromo, logo $w^R = w$.

**$(w^R)^2$:**
$$w^R = aba$$
$$(w^R)^2 = (aba)^2 = aba \cdot aba = abaaba$$

**$(w^2)^R$:**
$$w^2 = aba \cdot aba = abaaba$$
$$(w^2)^R = (abaaba)^R = abaaba$$

**$w^R w$:**
$$w^R w = aba \cdot aba = abaaba$$

**Verificação se $(w^2)^R = (w^R)^2$:**

$$\text{Lado esquerdo: } (w^2)^R = abaaba$$
$$\text{Lado direito: } (w^R)^2 = abaaba$$

$$\therefore (w^2)^R = (w^R)^2$$

**Explicação:** Esta igualdade vale neste caso específico porque $w$ é um palíndromo ($w = w^R$). Em geral, para strings arbitrárias, $(w^n)^R = (w^R)^n$, que se reduz a $w^n = w^n$ quando $w$ é um palíndromo.

**Propriedade geral:** Para qualquer string $u$ e inteiro positivo $n$:
$$(u^n)^R = (u^R)^n$$

No nosso caso, como $w^R = w$, ambos os lados se tornam $w^2 = abaaba$.

### Exercícios 3: @sec-ex-linguagens2

1. **Solução:**

**Dado:** $L_1 = \{a, ab, b\}$ e $L_2 = \{b, ba, \epsilon\}$

**União:** $L_1 \cup L_2$
$$L_1 \cup L_2 = \{a, ab, b\} \cup \{b, ba, \epsilon\} = \{a, ab, b, ba, \epsilon\}$$

**Interseção:** $L_1 \cap L_2$
$$L_1 \cap L_2 = \{a, ab, b\} \cap \{b, ba, \epsilon\} = \{b\}$$

**Diferença:** $L_1 - L_2$
$$L_1 - L_2 = \{a, ab, b\} - \{b, ba, \epsilon\} = \{a, ab\}$$

**Cardinalidades:**
- $|L_1 \cup L_2| = |\{a, ab, b, ba, \epsilon\}| = 5$
- $|L_1 \cap L_2| = |\{b\}| = 1$

**Verificação:** $|L_1| + |L_2| - |L_1 \cap L_2| = 3 + 3 - 1 = 5 = |L_1 \cup L_2|$ 

2. **Solução:**

**Dado:** $L_1 = \{a, bb\}$ e $L_2 = \{c, dd\}$

**$L_1 \cdot L_2$:**

Aplicando a definição $L_1 \cdot L_2 = \{xy \mid x \in L_1 \text{ e } y \in L_2\}$:

$$L_1 \cdot L_2 = \{ac, add, bbc, bbdd\}$$

**Cálculo detalhado:**
- $a \cdot c = ac$
- $a \cdot dd = add$  
- $bb \cdot c = bbc$
- $bb \cdot dd = bbdd$

**$L_2 \cdot L_1$:**

$$L_2 \cdot L_1 = \{ca, cbb, dda, ddbb\}$$

**Cálculo detalhado:**
- $c \cdot a = ca$
- $c \cdot bb = cbb$
- $dd \cdot a = dda$
- $dd \cdot bb = ddbb$

**Cardinalidade:**
$$|L_1 \cdot L_2| = |L_1| \times |L_2| = 2 \times 2 = 4$$
$$|L_2 \cdot L_1| = |L_2| \times |L_1| = 2 \times 2 = 4$$

**Verificação de comutatividade:**
$$L_1 \cdot L_2 = \{ac, add, bbc, bbdd\}$$
$$L_2 \cdot L_1 = \{ca, cbb, dda, ddbb\}$$

Como os conjuntos são distintos, $L_1 \cdot L_2 \neq L_2 \cdot L_1$. A concatenação de linguagens **não é comutativa**.

3. **Solução:**

**Dado:** $L = \{a, b\}$

**$L^0$:**
Por definição, $L^0 = \{\epsilon\}$ para qualquer linguagem $L$.

**$L^1$:**
$$L^1 = L = \{a, b\}$$

**$L^2$:**
$$L^2 = L \cdot L = \{xy \mid x \in L \text{ e } y \in L\}$$
$$L^2 = \{aa, ab, ba, bb\}$$

**Cálculo detalhado de $L^2$:**
- $a \cdot a = aa$
- $a \cdot b = ab$
- $b \cdot a = ba$ 
- $b \cdot b = bb$

**Fórmula para $|L^n|$:**

Como $|L| = 2$, temos:
$$|L^n| = |L|^n = 2^n$$

**Verificação:**
- $|L^0| = |\{\epsilon\}| = 1 = 2^0$ 
- $|L^1| = |\{a, b\}| = 2 = 2^1$   
- $|L^2| = |\{aa, ab, ba, bb\}| = 4 = 2^2$ 

**Três primeiras strings de $L^3$ em ordem lexicográfica:**

$L^3$ contém todas as strings de comprimento 3 sobre $\{a, b\}$.

Em ordem lexicográfica: $\{aaa, aab, aba, abb, baa, bab, bba, bbb\}$

**Três primeiras:** $aaa, aab, aba$

4. **Solução:**

**Dado:** $L = \{ab\}$

**Elementos de $L^*$ até strings de comprimento 6:**

Pela definição: $L^* = L^0 \cup L^1 \cup L^2 \cup L^3 \cup \ldots$

- $L^0 = \{\epsilon\}$
- $L^1 = \{ab\}$ (comprimento 2)
- $L^2 = \{ab \cdot ab\} = \{abab\}$ (comprimento 4)  
- $L^3 = \{ab \cdot ab \cdot ab\} = \{ababab\}$ (comprimento 6)

$$L^* \text{ até comprimento 6} = \{\epsilon, ab, abab, ababab\}$$

**$L^+$:**
$$L^+ = L^1 \cup L^2 \cup L^3 \cup \ldots = L^* - \{\epsilon\}$$
$$L^+ = \{ab, abab, ababab, abababab, \ldots\}$$

**Verificações:**

**$\epsilon \in L^*$?**
Sim, pois $\epsilon \in L^0$ e $L^0 \subseteq L^*$.

**$\epsilon \in L^+$?**
Não, pois $L^+ = L^1 \cup L^2 \cup \ldots$ e $\epsilon \notin L^n$ para $n \geq 1$ quando $L = \{ab\}$.

**Padrão geral:**
Como $L = \{ab\}$ contém apenas uma string de comprimento 2, temos:
$$L^* = \{\epsilon, ab, (ab)^2, (ab)^3, \ldots\} = \{(ab)^n \mid n \geq 0\}$$
$$L^+ = \{ab, (ab)^2, (ab)^3, \ldots\} = \{(ab)^n \mid n \geq 1\}$$

5. **Solução:**

**Dado:** $L = \{a\}$

**Propriedade 1: $L^* = L^+$?**

$$L^* = \{\epsilon, a, aa, aaa, \ldots\} = \{a^n \mid n \geq 0\}$$
$$L^+ = \{a, aa, aaa, \ldots\} = \{a^n \mid n \geq 1\}$$

Como $\epsilon \in L^*$ mas $\epsilon \notin L^+$, temos $L^* \neq L^+$.

**Resposta:** **FALSO**

**Propriedade 2: $L^* \cup L^+ = L^*$?**

Como $L^+ \subseteq L^*$ (pela definição $L^+ = L^* - \{\epsilon\}$ quando $\epsilon \notin L$), temos:
$$L^* \cup L^+ = L^*$$

**Resposta:** **VERDADEIRO**

**Propriedade 3: $(L^*)^* = L^*$?**

Esta é uma propriedade geral do fechamento de Kleene. 

**Demonstração:** 
- $(L^*)^*$ contém todas as concatenações possíveis de elementos de $L^*$
- Como $L^* = \{a^n \mid n \geq 0\}$, qualquer concatenação de elementos de $L^*$ resulta em $a^k$ para algum $k \geq 0$
- Portanto, $(L^*)^* \subseteq L^*$
- Como $L^* \subseteq (L^*)^*$ (pois $L^* \subseteq (L^*)^1 \subseteq (L^*)^*$), temos a igualdade

**Resposta:** **VERDADEIRO**

**Propriedade 4: Se $\epsilon \in L$, então $L^+ = L^*$?**

No nosso caso, $L = \{a\}$ e $\epsilon \notin L$, então a premissa é falsa.

Mas vamos analisar o caso geral: se $\epsilon \in L$, então:
- $L^* = L^0 \cup L^1 \cup L^2 \cup \ldots$
- $L^+ = L^1 \cup L^2 \cup L^3 \cup \ldots$
- Como $\epsilon \in L = L^1$, temos $\epsilon \in L^+$
- Como $\epsilon \in L^0$ também, e $L^+ \supseteq L^1$, de fato $L^+ = L^*$

**Resposta:** **VERDADEIRO** (propriedade geral válida)

**Para nosso caso específico:** A propriedade não se aplica pois $\epsilon \notin \{a\}$.

# Exercícios 4: @sec-ex-regex

1. **Solução:**

**$r_1 = a \cup b$**

Aplicando a regra indutiva para união:
$$L(r_1) = L(a \cup b) = L(a) \cup L(b) = \{a\} \cup \{b\} = \{a, b\}$$

**$r_2 = (a \cup b)(a \cup b)$**

Aplicando as regras de concatenação e união:
$$L(r_2) = L(a \cup b) \cdot L(a \cup b) = \{a, b\} \cdot \{a, b\}$$

Calculando o produto cartesiano:
$$L(r_2) = \{aa, ab, ba, bb\}$$

**$r_3 = a^*b$**

Aplicando as regras de fechamento de Kleene e concatenação:
$$L(r_3) = L(a^*) \cdot L(b) = L(a)^* \cdot \{b\} = \{a\}^* \cdot \{b\}$$

Como $\{a\}^* = \{\epsilon, a, aa, aaa, \ldots\} = \{a^n \mid n \geq 0\}$:
$$L(r_3) = \{a^n b \mid n \geq 0\} = \{b, ab, aab, aaab, \ldots\}$$

**$r_4 = (ab)^*$**

Aplicando a regra do fechamento de Kleene:
$$L(r_4) = L(ab)^* = \{ab\}^*$$

Como visto no exercício anterior:
$$L(r_4) = \{(ab)^n \mid n \geq 0\} = \{\epsilon, ab, abab, ababab, \ldots\}$$

2. **Solução:**

Lembrando a ordem de precedência (maior para menor): **Kleene ($*$)** → **Concatenação ($\cdot$)** → **União ($\cup$)**

**$ab^* \cup c$**

1. Primeiro, o fechamento de Kleene: $b^*$
2. Depois, a concatenação: $a(b^*)$  
3. Por fim, a união: $(a(b^*)) \cup c$

**Resultado:** $((a(b^*)) \cup c)$

**$a \cup bc^*$**

1. Primeiro, o fechamento de Kleene: $c^*$
2. Depois, a concatenação: $b(c^*)$
3. Por fim, a união: $a \cup (b(c^*))$

**Resultado:** $(a \cup (b(c^*)))$

**$ab \cup cd^*e$**

1. Primeiro, o fechamento de Kleene: $d^*$
2. Depois, as concatenações (da esquerda para direita): $(ab)$ e $(c(d^*)e)$
3. Por fim, a união: $(ab) \cup ((c(d^*))e)$

**Resultado:** $((ab) \cup (c((d^*)e)))$

**$a^*b^* \cup c^*$**

1. Primeiro, os fechamentos de Kleene: $a^*$, $b^*$, $c^*$
2. Depois, a concatenação: $(a^*)(b^*)$
3. Por fim, a união: $((a^*)(b^*)) \cup (c^*)$

**Resultado:** $(((a^*)(b^*)) \cup (c^*))$

3. **Solução:**

**Para $r = a^*ba^*$ e strings $\{ab, ba, aba, baa, bb\}$:**

$L(a^*ba^*) = \{a^i b a^j \mid i, j \geq 0\}$ (strings com exatamente um $b$, podendo ter qualquer quantidade de $a$'s antes e depois)

- **$ab$:** $ab = a^1 b a^0$ ∈ $L(r)$ 
- **$ba$:** $ba = a^0 b a^1$ ∈ $L(r)$   
- **$aba$:** $aba = a^1 b a^1$ ∈ $L(r)$ 
- **$baa$:** $baa = a^0 b a^2$ ∈ $L(r)$ 
- **$bb$:** Contém dois $b$'s, não pode ser expressa como $a^i b a^j$ ∉ $L(r)$ 

**Para $r = (a \cup b)^*b$ e strings $\{b, ab, ba, abb, bbb\}$:**

$L((a \cup b)^*b) = \{w b \mid w \in \{a,b\}^*\}$ (strings terminando com $b$)

- **$b$:** $b = \epsilon \cdot b$ ∈ $L(r)$ 
- **$ab$:** $ab = a \cdot b$ ∈ $L(r)$ 
- **$ba$:** Termina com $a$, não com $b$ ∉ $L(r)$ 
- **$abb$:** $abb = ab \cdot b$ ∈ $L(r)$   
- **$bbb$:** $bbb = bb \cdot b$ ∈ $L(r)$ 

4. **Solução:**
  
**Objetivo:** Calcular $L((a \cup b)c)$ usando a definição indutiva.

**Casos base identificados:**
- $L(a) = \{a\}$
- $L(b) = \{b\}$  
- $L(c) = \{c\}$

**Aplicação das regras indutivas:**

**Passo 1:** Calcular $L(a \cup b)$

Usando a regra da união: $L(r \cup s) = L(r) \cup L(s)$
$$L(a \cup b) = L(a) \cup L(b) = \{a\} \cup \{b\} = \{a, b\}$$

**Passo 2:** Calcular $L((a \cup b)c)$

Usando a regla da concatenação: $L(rs) = L(r) \cdot L(s)$
$$L((a \cup b)c) = L(a \cup b) \cdot L(c) = \{a, b\} \cdot \{c\}$$

**Passo 3:** Calcular o produto cartesiano
$$\{a, b\} \cdot \{c\} = \{ac, bc\}$$

**Resultado final:**
$$L((a \cup b)c) = \{ac, bc\}$$

5. **Solução:**

**$L_1 = \{a, b, aa, bb\}$**

Analisando o padrão: strings $a$ ou $b$, e strings $aa$ ou $bb$.

**Estratégia:** $(a \cup b) \cup (aa \cup bb) = (a \cup b) \cup (a \cup b)(a \cup b)$

Podemos fatorar: $(a \cup b)(1 \cup (a \cup b))$, mas isso não é uma expressão regular válida.

**Solução direta:**
$$r_1 = a \cup b \cup aa \cup bb$$

**Versão mais concisa:**
$$r_1 = (a \cup b) \cup (a \cup b)^2$$

**$L_2 = \{\epsilon, a, aa, aaa\}$**

Analisando: $\epsilon$, $a^1$, $a^2$, $a^3$.

**Estratégia:** União de potências específicas de $a$.
$$r_2 = \epsilon \cup a \cup a^2 \cup a^3$$

**Observação:** Não há uma forma mais concisa usando apenas as três operações básicas, pois precisamos limitar a 3 repetições de $a$.

**$L_3 = \{w \in \{a,b\}^* \mid w \text{ termina com } a\}$**

**Análise:** Qualquer sequência de $a$'s e $b$'s seguida obrigatoriamente por um $a$.

**Estratégia:** $(a \cup b)^* a$

**Verificação:**
- $L((a \cup b)^* a) = \{wa \mid w \in \{a,b\}^*\}$ 
- Isso corresponde exatamente a todas as strings sobre $\{a,b\}$ terminando com $a$

$$r_3 = (a \cup b)^*a$$

**Verificação com exemplos:**
- $a = \epsilon \cdot a$ ∈ $L(r_3)$ 
- $ba = b \cdot a$ ∈ $L(r_3)$   
- $aba = ab \cdot a$ ∈ $L(r_3)$ 
- $ab = a \cdot b$ ∉ $L(r_3)$  (não termina com $a$)

### Exercícios 5: @sec-ex-regex2

1. **Solução:**

**Strings terminando em $10$:**
$$r_1 = (0 \cup 1)^*10$$

**Verificação:** Qualquer sequência de 0's e 1's seguida obrigatoriamente por $10$.

**Strings começando com $01$:**
$$r_2 = 01(0 \cup 1)^*$$

**Verificação:** A string deve iniciar com $01$ seguido por qualquer sequência de 0's e 1's.

**Strings que contêm $01$ como substring:**
$$r_3 = (0 \cup 1)^*01(0 \cup 1)^*$$

**Verificação:** Qualquer sequência antes, $01$ obrigatório no meio, qualquer sequência depois.

**Strings que NÃO contêm $01$:**

**Análise:** Uma string não contém $01$ se nunca há um $0$ seguido diretamente por um $1$.

**Estratégia:** A string pode ter apenas:
- Sequências de $1$'s seguidas de sequências de $0$'s
- Ou apenas $1$'s
- Ou apenas $0$'s  
- Ou a string vazia

$$r_4 = 1^*0^*$$

**Justificativa:** Se há algum $0$ seguido de $1$, violaria o padrão $1^*0^*$.

2. **Solução:**

**Strings com número ímpar de $a$'s sobre $\{a,b\}$:**

**Estratégia:** Modificar o padrão do número par. Para ter número ímpar, precisamos de um número ímpar de grupos "um $a$".

$$r_1 = b^*a(b^*ab^*ab^*)^*b^*$$

**Explicação:**
- $b^*$: pode começar com $b$'s
- $a$: o primeiro $a$ (garantindo número ímpar)
- $(b^*ab^*ab^*)^*$: grupos de dois $a$'s (mantém a paridade ímpar)
- $b^*$: pode terminar com $b$'s

**Strings com número múltiplo de 3 de $a$'s:**

**Estratégia:** Agrupar os $a$'s de três em três.

$$r_2 = b^*(ab^*ab^*ab^*)^*b^*$$

**Explicação:**
- O grupo $(ab^*ab^*ab^*)$ contém exatamente 3 $a$'s
- A repetição $(...)^*$ permite 0, 3, 6, 9, ... $a$'s

**Strings com pelo menos dois $a$'s:**

**Estratégia:** Primeiro $a$, depois segundo $a$, depois qualquer coisa.

$$r_3 = (a \cup b)^*a(a \cup b)^*a(a \cup b)^*$$

**Simplificação alternativa:**
$$r_3 = b^*ab^*a(a \cup b)^*$$

3. **Solução:**

**Permitir underscores em qualquer posição:**

Alfabeto expandido: $\{a, \ldots, z, A, \ldots, Z, 0, \ldots, 9, \_\}$

$$r_1 = [a-zA-Z\_][a-zA-Z0-9\_]^*$$

**Proibir dígitos na primeira e última posições:**

**Estratégia:** 
- Primeiro: apenas letra ou underscore
- Meio: qualquer coisa permitida
- Último: apenas letra ou underscore

Para identificadores de 1 caractere:
$$\text{Caso 1: } [a-zA-Z\_]$$

Para identificadores de 2+ caracteres:
$$\text{Caso 2: } [a-zA-Z\_][a-zA-Z0-9\_]^*[a-zA-Z\_]$$

**Combinando:**
$$r_2 = [a-zA-Z\_] \cup [a-zA-Z\_][a-zA-Z0-9\_]^*[a-zA-Z\_]$$

**Identificadores entre 3 e 8 caracteres:**

$$r_3 = [a-zA-Z\_][a-zA-Z0-9\_]\{2,7\}$$

**Explicação:**
- $[a-zA-Z\_]$: primeiro caractere (1 caractere)
- $[a-zA-Z0-9\_]\{2,7\}$: de 2 a 7 caracteres adicionais
- Total: 3 a 8 caracteres

4. **Solução:**

**Números decimais (com ponto decimal):**

$$r_1 = (\epsilon \cup + \cup -)[0-9]^*\.[0-9]^+$$

**Análise:**
- Sinal opcional: $(\epsilon \cup + \cup -)$
- Parte inteira opcional: $[0-9]^*$ 
- Ponto obrigatório: $\.$
- Parte decimal obrigatória: $[0-9]^+$

**Versão mais robusta (evitando apenas ".123"):**
$$r_1' = (\epsilon \cup + \cup -)([0-9]^+\.[0-9]^* \cup [0-9]^*\.[0-9]^+)$$

**Notação científica simples ($1e5$, $2e-3$):**

$$r_2 = (\epsilon \cup + \cup -)[0-9]^+e(\epsilon \cup + \cup -)[0-9]^+$$

**Explicação:**
- Sinal opcional: $(\epsilon \cup + \cup -)$
- Mantissa: $[0-9]^+$ (pelo menos um dígito)
- Literal 'e': $e$
- Sinal do expoente opcional: $(\epsilon \cup + \cup -)$
- Expoente: $[0-9]^+$

**Números hexadecimais com prefixo $0x$:**

$$r_3 = 0x[0-9a-fA-F]^+$$

**Explicação:**
- Prefixo obrigatório: $0x$
- Dígitos hex: $[0-9a-fA-F]^+$ (pelo menos um)

5. **Solução:**

**Verificação para "termina em 10" ($r = (0 \cup 1)^*10$):**

- **$101$:** Termina em $01$, não em $10$ → **NÃO** pertence
- **$1010$:** Termina em $10$ → **SIM** pertence  
- **$0101$:** Termina em $01$, não em $10$ → **NÃO** pertence

**Verificação para número ímpar de $a$'s ($r = b^*a(b^*ab^*ab^*)^*b^*$):**

- **$aab$:** 
  - Contagem de $a$'s: 2 (par) → **NÃO** pertence
  
- **$baba$:** 
  - Contagem de $a$'s: 2 (par) → **NÃO** pertence
  
- **$ababa$:** 
  - Contagem de $a$'s: 3 (ímpar) → **SIM** pertence

**Verificação para identificadores com underscores ($r = [a-zA-Z\_][a-zA-Z0-9\_]^*$):**

- **$var\_1$:**
  - Primeiro: $v$ (letra) 
  - Resto: $ar\_1$ (letras, underscore, dígito) 
  - → **SIM** é válido
  
- **$\_temp$:**
  - Primeiro: $\_$ (underscore)   
  - Resto: $temp$ (letras) 
  - → **SIM** é válido
  
- **$item2\_$:**
  - Primeiro: $i$ (letra) 
  - Resto: $tem2\_$ (letras, dígito, underscore) 
  - → **SIM** é válido

**Resumo dos resultados:**

| String | Termina em 10 | Ímpar de $a$'s | ID com underscore |
|--------|---------------|----------------|-------------------|
| $101$ |  | - | - |
| $1010$ |  | - | - |  
| $0101$ |  | - | - |
| $aab$ | - |  | - |
| $baba$ | - |  | - |
| $ababa$ | - |  | - |
| $var\_1$ | - | - |  |
| $\_temp$ | - | - |  |
| $item2\_$ | - | - |  |

### Exercícios 6: {@sec-ex-regex3}

1. **Solução:**

**$(a \cup \emptyset)b$**

Aplicando a lei do elemento neutro da união: $r \cup \emptyset \equiv r$
$$(a \cup \emptyset)b \equiv ab$$

**$a(\epsilon \cup b)$**

Aplicando a distributividade: $r(s \cup t) \equiv rs \cup rt$
$$a(\epsilon \cup b) \equiv a\epsilon \cup ab$$

Aplicando a lei do elemento neutro da concatenação: $r\epsilon \equiv r$
$$a\epsilon \cup ab \equiv a \cup ab$$

**$(a \cup a)^*$**

Aplicando a idempotência da união: $r \cup r \equiv r$
$$(a \cup a)^* \equiv a^*$$

**$a \cup ab^*a$**

Aplicando a distributividade: $rs \cup rt \equiv r(s \cup t)$

Primeiro, fatoramos $a$:
$$a \cup ab^*a \equiv a\epsilon \cup ab^*a \equiv a(\epsilon \cup b^*a)$$

Como $\epsilon \cup b^*a$ não pode ser simplificado usando apenas as leis básicas, a expressão mais simples é:
$$a \cup ab^*a$$

**Nota:** Esta expressão pode ser simplificada para $ab^*a$ usando propriedades mais avançadas, pois $\epsilon \in b^*$.

2. **Solução:**

**Objetivo:** Simplificar $((a \cup b)a) \cup (aa)$

**Expressão inicial:**
$$((a \cup b)a) \cup (aa)$$

**Passo 1:** Aplicar distributividade em $(a \cup b)a$
$$((a \cup b)a) = (aa \cup ba)$$

**Passo 2:** Substituir na expressão original
$$(aa \cup ba) \cup (aa)$$

**Passo 3:** Aplicar associatividade da união
$$aa \cup ba \cup aa$$

**Passo 4:** Aplicar comutatividade para agrupar termos iguais
$$aa \cup aa \cup ba$$

**Passo 5:** Aplicar idempotência da união: $r \cup r \equiv r$
$$aa \cup ba$$

**Passo 6:** Aplicar distributividade reversa
$$aa \cup ba \equiv (a \cup b)a$$

**Resultado final:**
$$((a \cup b)a) \cup (aa) \equiv (a \cup b)a$$

**Verificação com strings específicas:**
- Original aceita: $\{aa, ba\}$
- Simplificada aceita: $\{aa, ba\}$ 

3. **Solução:**

**$a^*a$ e $aa^*$**

**Demonstração:**

Para $a^*a$:
$$L(a^*a) = L(a^*) \cdot L(a) = \{a^n \mid n \geq 0\} \cdot \{a\} = \{a^{n+1} \mid n \geq 0\} = \{a^m \mid m \geq 1\}$$

Para $aa^*$:
$$L(aa^*) = L(a) \cdot L(a^*) = \{a\} \cdot \{a^n \mid n \geq 0\} = \{a^{1+n} \mid n \geq 0\} = \{a^m \mid m \geq 1\}$$

Como $L(a^*a) = L(aa^*) = \{a^m \mid m \geq 1\}$, temos:
$$a^*a \equiv aa^*$$

**$(a \cup b)^*$ e $\epsilon \cup (a \cup b)(a \cup b)^*$**

**Demonstração:**

Para o lado direito, aplicando a definição recursiva do fechamento de Kleene:
$$L^* = \epsilon \cup LL^*$$

Substituindo $L = (a \cup b)$:
$$L((a \cup b)^*) = \{\epsilon\} \cup L(a \cup b) \cdot L((a \cup b)^*)$$
$$= \{\epsilon\} \cup L((a \cup b)(a \cup b)^*)$$
$$= L(\epsilon \cup (a \cup b)(a \cup b)^*)$$

Portanto:
$$(a \cup b)^* \equiv \epsilon \cup (a \cup b)(a \cup b)^*$$

**$a^*b^*$ e $(a \cup b)^*$ - esta é FALSA**

**Contraexemplo:**
- $ab \in L((a \cup b)^*)$ (qualquer intercalação de $a$'s e $b$'s)
- $ab \notin L(a^*b^*)$ (pois $a^*b^*$ só aceita todos os $a$'s seguidos de todos os $b$'s)

Portanto: $a^*b^* \not\equiv (a \cup b)^*$

4. **Solução:**

**$(a^*)^*$**

Aplicando a lei do fechamento do fechamento: $(r^*)^* \equiv r^*$
$$(a^*)^* \equiv a^*$$

**$\epsilon^* \cup a^*$**

Aplicando a lei: $\epsilon^* \equiv \epsilon$
$$\epsilon^* \cup a^* \equiv \epsilon \cup a^*$$

Como $\epsilon \in L(a^*)$ (pois $a^* = \{a^n \mid n \geq 0\}$ e $\epsilon = a^0$):
$$\epsilon \cup a^* \equiv a^*$$

**$\emptyset^* \cup a$**

Aplicando a lei: $\emptyset^* \equiv \epsilon$
$$\emptyset^* \cup a \equiv \epsilon \cup a$$

Esta expressão não pode ser simplificada mais.

**$(a \cup \epsilon)^*$**

Como $\epsilon \in L(a \cup \epsilon)$, pela propriedade do fechamento de Kleene quando $\epsilon$ está presente:
$$L((a \cup \epsilon)^*) = L(a^*)$$

Portanto:
$$(a \cup \epsilon)^* \equiv a^*$$

5. **Solução:**

**Objetivo:** Simplificar $ab^* \cup abb^* \cup abbb^*$

**Identificação do padrão comum:**

Todos os termos começam com $a$ seguido de pelo menos um $b$:
- $ab^* = a(b^*)$ contém $ab^0, ab^1, ab^2, \ldots$
- $abb^* = a(bb^*)$ contém $ab^1, ab^2, ab^3, \ldots$  
- $abbb^* = a(bbb^*)$ contém $ab^2, ab^3, ab^4, \ldots$

**Análise dos conjuntos:**
- $L(ab^*) = \{a, ab, abb, abbb, \ldots\}$
- $L(abb^*) = \{ab, abb, abbb, \ldots\}$  
- $L(abbb^*) = \{abb, abbb, abbbb, \ldots\}$

**Observação:** $L(abb^*) \subseteq L(ab^*)$ e $L(abbb^*) \subseteq L(ab^*)$

**Aplicação da distributividade:**

$$ab^* \cup abb^* \cup abbb^* \equiv a(b^* \cup bb^* \cup bbb^*)$$

**Simplificação do termo entre parênteses:**

Como $bb^* \subseteq b^*$ e $bbb^* \subseteq b^*$:
$$b^* \cup bb^* \cup bbb^* \equiv b^*$$

**Resultado final:**
$$ab^* \cup abb^* \cup abbb^* \equiv ab^*$$

**Verificação da equivalência:**

**Linguagem original:**
$$L(ab^* \cup abb^* \cup abbb^*) = L(ab^*) \cup L(abb^*) \cup L(abbb^*)$$
$$= \{a, ab, abb, \ldots\} \cup \{ab, abb, \ldots\} \cup \{abb, abbb, \ldots\}$$
$$= \{a, ab, abb, abbb, \ldots\}$$

**Linguagem simplificada:**
$$L(ab^*) = \{a, ab, abb, abbb, \ldots\}$$

Como os conjuntos são idênticos, a simplificação está correta.

**Benefício da otimização:**
- **Expressão original:** 3 termos unidos
- **Expressão otimizada:** 1 termo simples
- **Eficiência:** Redução significativa na complexidade de avaliação

### Exercícios 7: {@sec-ex-regex4}

1. **Solução:**

**$a^+$**

Por definição: $r^+ \equiv rr^*$
$$a^+ \equiv aa^*$$

**$b?$**

Por definição: $r? \equiv (\epsilon \cup r)$
$$b? \equiv (\epsilon \cup b)$$

**$[abc]$**

Classes de caracteres são equivalentes à união:
$$[abc] \equiv (a \cup b \cup c)$$

**$a\{3\}$**

Repetição exata significa concatenação repetida:
$$a\{3\} \equiv aaa$$

**$b\{2,4\}$**

Repetição de 2 a 4 vezes:
$$b\{2,4\} \equiv bb \cup bbb \cup bbbb$$

Ou usando concatenação e opcionalidade:
$$b\{2,4\} \equiv bb(\epsilon \cup b)(\epsilon \cup b)$$

2. **Solução:**

**Qualquer dígito: $[0-9]$**

$$[0-9] \equiv (0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)$$

**Qualquer letra minúscula: $[a-z]$**

$$[a-z] \equiv (a \cup b \cup c \cup \ldots \cup z)$$

**Qualquer caractere que não seja espaço: $[^ ]$**

Assumindo um alfabeto básico ASCII $\Sigma = \{a, b, \ldots, z, A, B, \ldots, Z, 0, 1, \ldots, 9, \text{ }, !, @, \#, \ldots\}$:

$$[^ ] \equiv (a \cup b \cup \ldots \cup z \cup A \cup \ldots \cup Z \cup 0 \cup \ldots \cup 9 \cup ! \cup @ \cup \ldots)$$

**Nota:** Esta seria a união de todos os símbolos do alfabeto exceto o espaço.

**Qualquer caractere alfanumérico: $[a-zA-Z0-9]$**

$$[a-zA-Z0-9] \equiv (a \cup b \cup \ldots \cup z \cup A \cup B \cup \ldots \cup Z \cup 0 \cup 1 \cup \ldots \cup 9)$$

3. **Solução:**

**CEP brasileiro no formato $99999-999$:**

$$r_1 = [0-9]\{5\}-[0-9]\{3\}$$

**Expandindo:**
$$r_1 \equiv [0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9]$$

**Placa de carro brasileira antiga $AAA-9999$:**

$$r_2 = [A-Z]\{3\}-[0-9]\{4\}$$

**Expandindo:**
$$r_2 \equiv [A-Z][A-Z][A-Z]-[0-9][0-9][0-9][0-9]$$

**Senha com exatamente 8 caracteres alfanuméricos:**

$$r_3 = [a-zA-Z0-9]\{8\}$$

**Expandindo:**
$$r_3 \equiv [a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9]$$

**Código de área de telefone com 2 ou 3 dígitos:**

$$r_4 = [0-9]\{2,3\}$$

**Expandindo:**
$$r_4 \equiv [0-9][0-9] \cup [0-9][0-9][0-9]$$

4. **Solução:**

**URL simples começando com $http$ ou $https$:**

$$r_1 = https?://[a-zA-Z0-9.-]^+$$

**Expandindo:**
$$r_1 \equiv (http \cup https)://[a-zA-Z0-9.-]^+$$
$$\equiv http(\epsilon \cup s)://[a-zA-Z0-9.-]^+$$

**Data no formato $dd/mm/aaaa$ (versão simples):**

$$r_2 = [0-9]\{2\}/[0-9]\{2\}/[0-9]\{4\}$$

**Expandindo:**
$$r_2 \equiv [0-9][0-9]/[0-9][0-9]/[0-9][0-9][0-9][0-9]$$

**Horário no formato $hh:mm$ (24 horas):**

$$r_3 = ([01][0-9] \cup 2[0-3]):[0-5][0-9]$$

**Explicação:**
- $([01][0-9] \cup 2[0-3])$: horas de 00-19 ou 20-23
- $:[0-5][0-9]$: minutos de 00-59

**Número de CPF no formato $999.999.999-99$:**

$$r_4 = [0-9]\{3\}\.[0-9]\{3\}\.[0-9]\{3\}-[0-9]\{2\}$$

**Expandindo:**
$$r_4 \equiv [0-9][0-9][0-9]\.[0-9][0-9][0-9]\.[0-9][0-9][0-9]-[0-9][0-9]$$

5. **Solução:**

**$(a \cup b \cup c \cup d)(a \cup b \cup c \cup d)^*$**

**Usando classes de caracteres:**
$$[abcd][abcd]^*$$

**Usando fechamento positivo:**
$$[abcd]^+$$

**Expandindo $[abcd]^+$:**
$$[abcd]^+ \equiv [abcd][abcd]^* \equiv [abcd](\epsilon \cup [abcd][abcd]^*)$$

**$a(\epsilon \cup b)$**

**Usando opcionalidade:**
$$ab?$$

**Expandindo:**
$$ab? \equiv a(\epsilon \cup b)$$

**$(0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)(0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)^*$**

**Usando classes de caracteres:**
$$[0-9][0-9]^*$$

**Usando fechamento positivo:**
$$[0-9]^+$$

**Comparação das otimizações:**

| Expressão Original | Versão Otimizada | Redução |
|-------------------|------------------|---------|
| $(a \cup b \cup c \cup d)(a \cup b \cup c \cup d)^*$ | $[abcd]^+$ | 90% |
| $a(\epsilon \cup b)$ | $ab?$ | 70% |
| $(0 \cup 1 \cup \ldots \cup 9)(0 \cup 1 \cup \ldots \cup 9)^*$ | $[0-9]^+$ | 95% |

**Benefícios da otimização:**

1. **Legibilidade:** As notações convencionais são muito mais fáceis de ler e entender
2. **Manutenibilidade:** Modificações (como adicionar novos caracteres) são mais simples
3. **Eficiência:** Implementações podem otimizar melhor as notações convencionais
4. **Menos propenso a erros:** Reduz a chance de esquecer casos em uniões longas

**Exemplo prático:**

Para aceitar qualquer letra maiúscula ou minúscula:

**Versão expandida (52 termos!):**
$$(A \cup B \cup C \cup \ldots \cup Z \cup a \cup b \cup c \cup \ldots \cup z)$$

**Versão otimizada:**
$$[a-zA-Z]$$

A redução é de aproximadamente **98%** no tamanho da expressão!

### Exercícios 8: {@sec-ex-regex5}

1. **Solução:**

**Palavras-chave: $\{\text{if}, \text{then}, \text{else}, \text{while}, \text{do}\}$**

$$r_1 = \text{if} \cup \text{then} \cup \text{else} \cup \text{while} \cup \text{do}$$

**Implementação mais eficiente:**
$$r_1 = \text{if} \cup \text{then} \cup \text{else} \cup \text{while} \cup \text{do}$$

**Números inteiros (incluindo negativos):**

$$r_2 = -?([1-9][0-9]^* \cup 0)$$

**Explicação:**
- $-?$: sinal negativo opcional
- $([1-9][0-9]^* \cup 0)$: número sem zeros à esquerda ou apenas zero

**Comentários de linha iniciados por $//$ até o final da linha:**

$$r_3 = //[^\n]^*$$

**Explicação:**
- $//$ literal
- $[^\n]^*$: qualquer caractere exceto nova linha, zero ou mais vezes

**Operadores relacionais: $\{<, >, <=, >=, ==, !=\}$**

$$r_4 = <= \cup >= \cup == \cup != \cup < \cup >$$

**Observação:** A ordem é importante - operadores de dois caracteres devem vir antes dos de um caractere para evitar conflitos durante o parsing.

2. **Solução:**

**Telefone celular: $(11) 99999-9999$**

$$r_1 = \([0-9]\{2\} [0-9]\{5\}-[0-9]\{4\}$$

**Versão mais flexível (com espaço opcional):**
$$r_1' = \([0-9]\{2\) ?[0-9]\{5\}-[0-9]\{4\}$$

**RG: $99.999.999-9$**

$$r_2 = [0-9]\{2\}\.[0-9]\{3\}\.[0-9]\{3\}-[0-9]$$

**CNPJ: $99.999.999/9999-99$**

$$r_3 = [0-9]\{2\}\.[0-9]\{3\}\.[0-9]\{3\}/[0-9]\{4\}-[0-9]\{2\}$$

**CEP: $99999-999$ ou $99.999-999$**

$$r_4 = [0-9]\{5\}[-.]?[0-9]\{3\}$$

**Explicação:**
- $[0-9]\{5\}$: cinco dígitos iniciais
- $[-.]?$: hífen ou ponto opcional (alguns CEPs não têm separador)
- $[0-9]\{3\}$: três dígitos finais

3. **Solução:**

**Endereços de email em um texto:**

$$r_1 = [a-zA-Z0-9._%+-]^+@[a-zA-Z0-9.-]^+\.[a-zA-Z]\{2,\}$$

**Explicação:**
- $[a-zA-Z0-9._%+-]^+$: parte local (antes do @)
- $@$: símbolo obrigatório
- $[a-zA-Z0-9.-]^+$: domínio
- $\.$: ponto literal
- $[a-zA-Z]\{2,\}$: extensão com pelo menos 2 letras

**Valores monetários no formato $R\$ 99,99$:**

$$r_2 = R\$ ?[0-9]^+,[0-9]\{2\}$$

**Versão mais robusta:**
$$r_2' = R\$ ?[0-9]\{1,3\}(\.[0-9]\{3\})^*,[0-9]\{2\}$$

**Explicação da versão robusta:**
- $[0-9]\{1,3\}$: 1 a 3 dígitos iniciais
- $(\.[0-9]\{3\})^*$: grupos de 3 dígitos separados por ponto (milhares)
- $,[0-9]\{2\}$: vírgula e centavos

**Datas em formatos variados: $dd/mm/aaaa$, $dd-mm-aaaa$, $dd.mm.aaaa$**

$$r_3 = [0-9]\{2\}[/.-][0-9]\{2\}[/.-][0-9]\{4\}$$

**Versão mais específica (garantindo consistência do separador):**
$$r_3' = ([0-9]\{2\}/[0-9]\{2\}/[0-9]\{4\}) \cup ([0-9]\{2\}-[0-9]\{2\}-[0-9]\{4\}) \cup ([0-9]\{2\}\.[0-9]\{2\}\.[0-9]\{4\})$$

**Números de cartão de crédito (formato $9999-9999-9999-9999$):**

$$r_4 = [0-9]\{4\}-[0-9]\{4\}-[0-9]\{4\}-[0-9]\{4\}$$

**Versão flexível (com separadores opcionais):**
$$r_4' = [0-9]\{4\} ?-? ?[0-9]\{4\} ?-? ?[0-9]\{4\} ?-? ?[0-9]\{4\}$$

4. **Solução:**

**Para validar email: $[a-z]+@[a-z]+.[a-z]+$ (problema: ponto literal)**

**Problema identificado:** O ponto $.$ é um metacaractere que corresponde a "qualquer caractere". Para representar um ponto literal, deve ser escapado.

**Correção:**
$$[a-z]^+@[a-z]^+\.[a-z]^+$$

**Melhorias adicionais:**
- Incluir maiúsculas e números: $[a-zA-Z0-9]^+@[a-zA-Z0-9]^+\.[a-zA-Z]\{2,\}$
- Permitir caracteres especiais válidos: $[a-zA-Z0-9._%+-]^+@[a-zA-Z0-9.-]^+\.[a-zA-Z]\{2,\}$

**Para números decimais: $[0-9]*.[0-9]*$ (problema: pontos opcionais)**

**Problemas identificados:**
1. Ponto não escapado (deveria ser $\.$)
2. Ambas as partes são opcionais (aceita strings como "." vazia)

**Correção:**
$$[0-9]^+\.[0-9]^+ \cup [0-9]^+\. \cup \.[0-9]^+$$

**Versão mais simples:**
$$([0-9]^+\.[0-9]^*) \cup ([0-9]^*\.[0-9]^+)$$

**Para identificadores: $[a-zA-Z][a-zA-Z0-9]?$ (problema: comprimento mínimo)**

**Problema identificado:** O $?$ torna o segundo caractere opcional, permitindo identificadores de apenas 1 caractere, mas limitando a 2 caracteres no máximo.

**Correção para identificadores normais:**
$$[a-zA-Z][a-zA-Z0-9]^*$$

**Se realmente quiser 1-2 caracteres apenas:**
$$[a-zA-Z][a-zA-Z0-9]?$$

5. **Solução:**

**$(abc|abd|abe) \rightarrow ab(c|d|e)$**

**Análise:** Fatoração do prefixo comum $ab$.

**Verificação da equivalência:**
- Original: $\{abc, abd, abe\}$
- Otimizada: $ab(c \cup d \cup e) = ab \{c, d, e\} = \{abc, abd, abe\}$ 

**Benefício:** Reduz backtracking em implementações, pois $ab$ só precisa ser verificado uma vez.

**$[0-9][0-9][0-9][0-9] \rightarrow [0-9]\{4\}$**

**Análise:** Uso de quantificador para repetição.

**Verificação da equivalência:**
- Ambas aceitam exatamente sequências de 4 dígitos 

**Benefício:** Mais conciso, e muitas implementações otimizam quantificadores internamente.

**$(a^*b^*|b^*a^*) \rightarrow (a|b)^*$ - VERIFICAÇÃO NECESSÁRIA**

**Análise da equivalência:**

**Lado esquerdo:** $(a^*b^*) \cup (b^*a^*)$
- $a^*b^*$: zero ou mais $a$'s seguidos de zero ou mais $b$'s
- $b^*a^*$: zero ou mais $b$'s seguidos de zero ou mais $a$'s
- União: strings da forma $a^i b^j$ ou $b^k a^l$

**Lado direito:** $(a \cup b)^*$
- Qualquer sequência de $a$'s e $b$'s em qualquer ordem

**Contraexemplo:** A string $aba$
- $aba \in L((a|b)^*)$ 
- $aba \notin L(a^*b^*)$ (pois tem $a$ após $b$)
- $aba \notin L(b^*a^*)$ (pois tem $b$ entre $a$'s)
- Portanto: $aba \notin L((a^*b^*|b^*a^*))$

**Conclusão:** As expressões **NÃO** são equivalentes.

**Análise de performance:**

| Expressão | Eficiência | Observações |
|-----------|------------|-------------|
| $ab(c\|d\|e)$ | ⭐⭐⭐⭐⭐ | Evita backtracking desnecessário |
| $[0-9]\{4\}$ | ⭐⭐⭐⭐⭐ | Otimização interna comum |
| $(a\|b)^*$ vs $(a^*b^*\|b^*a^*)$ | ⭐⭐⭐ vs ⭐⭐ | Primeira é mais eficiente, mas não equivalente |

**Recomendações gerais para performance:**

1. **Fatore prefixos comuns** para reduzir backtracking
2. **Use quantificadores** em vez de repetição manual
3. **Evite alternativas desnecessárias** quando uma expressão mais simples serve
4. **Coloque alternativas mais prováveis primeiro** em uniões
5. **Use classes de caracteres** em vez de uniões longas de caracteres individuais

**Exemplo de otimização completa:**

**Antes:** $(http|https)://[a-z][a-z][a-z]*\.(com|org|net|edu)$

**Depois:** $https?://[a-z]^+\.(com|org|net|edu)$

Benefícios: prefixo comum fatorado, quantificador usado, expressão mais concisa.

## Capítulo sec-aut-finitos-deterministicos 

### Exercícios 1 {@sec-definicao-formal}

**1.**

* Q=s\_0,s\_1,s\_2,s\_3: O conjunto finito de estados.  
* Sigma=a,b: O alfabeto de entrada.  
* delta: A função de transição, que mapeia pares de estado e símbolo para um estado de destino (ex: delta(s\_0,a)=s\_1).  
* s\_0: O estado inicial único.  
* F=s\_0,s\_3: O conjunto de estados de aceitação (ou finais).

**2.** Não, o modelo não representa um AFD válido. A justificativa é que o conjunto de estados de aceitação F=q\_2 contém um estado, q\_2, que não pertence ao conjunto de estados da máquina, Q=q\_0,q\_1. A definição formal exige que FsubseteqQ.

**3.** O domínio da função de transição é QtimesSigma. O número de pares nesse domínio é o produto das cardinalidades dos conjuntos, ou seja, ∣Q∣times∣Sigma∣=3times4=12.

**4.** Sim, é possível. Se F=Q, significa que todo estado do autômato é um estado de aceitação. Isso implica que, independentemente da sequência de transições, o estado final será sempre de aceitação. Portanto, o autômato reconheceria todas as *strings* possíveis sobre seu alfabeto, incluindo a *string* vazia. A linguagem reconhecida seria Sigma\\\*.

**5.** Sim, é perfeitamente possível. Se o estado inicial q\_0 também é um estado de aceitação (q\_0inF), isso significa que a computação que começa e termina em q\_0 sem consumir nenhum símbolo é uma computação de aceitação. Portanto, a *string* vazia (epsilon) é aceita pelo autômato.

### Exercícios 2 {@exercicios-2}

**1.** Não, o autômato não é completo. Faltam transições para o símbolo 'd' a partir de q\_0 e para o símbolo 'l' a partir de q\_1. Para completá-lo, adicionamos q\_e:

* delta(q\_0,l)=q\_1 (existente)  
* delta(q\_0,d)=q\_e (nova)  
* delta(q\_1,d)=q\_1 (existente)  
* delta(q\_1,l)=q\_e (nova)  
* delta(q\_e,l)=q\_e (nova)  
* delta(q\_e,d)=q\_e (nova)

**2.** A propriedade determinística garante que para qualquer estado atual e qualquer símbolo de entrada, há apenas um único próximo estado possível. Isso elimina qualquer ambiguidade. Em uma implementação, isso se traduz em uma operação muito rápida e simples: uma única consulta a uma tabela (ou uma instrução switch) para determinar o próximo estado. Não há necessidade de explorar múltiplos caminhos, voltar atrás (backtracking) ou gerenciar escolhas, tornando o processamento da *string* de entrada linear e extremamente eficiente.

**3.** Não. A função de um estado de erro é capturar permanentemente qualquer sequência de entrada que desvie de um padrão válido. Por definição, uma *string* que leva a um estado de erro deve ser rejeitada. Se o estado de erro fosse também um estado de aceitação, ele aceitaria *strings* que deveriam ser rejeitadas, contradizendo seu propósito.

**4.** Assume-se que as transições não mostradas levam a um estado de erro implícito, não desenhado. A partir desse estado de erro, todas as transições subsequentes (para qualquer símbolo do alfabeto) apontam de volta para ele mesmo. Isso é feito para manter os diagramas mais limpos e legíveis.

**2.5.** Sim, é muito comum. Isso é chamado de auto-loop ou laço. Significa que, ao ler um determinado símbolo, a máquina não precisa mudar a informação que está armazenando (representada pelo estado). Exemplo prático: no autômato que reconhece números com paridade par de '1's, a transição delta(q\_par,0)=q\_par indica que ler um '0' não muda a paridade, então a máquina permanece no mesmo estado.

### Exercícios 3: {@exercicios-3}

**1.** O diagrama de transições é o seguinte:

* Três nós: q\_A,q\_B,q\_C.  
* q\_A tem uma seta de entrada "do nada" (estado inicial).  
* q\_C é um círculo duplo (estado de aceitação).  
* Setas:  
  * De q\_A para q\_B com rótulo '0'.  
  * Um laço em q\_A com rótulo '1'.  
  * Um laço em q\_B com rótulo '0'.  
  * De q\_B para q\_C com rótulo '1'.  
  * De q\_C para q\_B com rótulo '0'.  
  * De q\_C para q\_A com rótulo '1'.

**2.**

* Q=q\_pp,q\_ip,q\_pi,q\_ii (par-par, ímpar-par, etc.)  
* Sigma=a,b  
* q\_0=q\_pp  
* F=q\_pp  
* delta é definida por:  
  * delta(q\_pp,a)=q\_ip, delta(q\_pp,b)=q\_pi  
  * delta(q\_ip,a)=q\_pp, delta(q\_ip,b)=q\_ii  
  * delta(q\_pi,a)=q\_ii, delta(q\_pi,b)=q\_pp  
  * delta(q\_ii,a)=q\_pi, delta(q\_ii,b)=q\_ip

**3.**

| Estado | a | b | r | e | x |
| :---- | :---- | :---- | :---- | :---- | :---- |
| rightarrowq\_0 | q\_1 | q\_e | q\_e | q\_e | q\_e |
| q\_1 | q\_e | q\_2 | q\_e | q\_e | q\_e |
| q\_2 | q\_e | q\_e | q\_3 | q\_e | q\_e |
| q\_3 | q\_e | q\_e | q\_e | q\_4 | q\_e |
| \\\*q\_4 | q\_e | q\_e | q\_e | q\_e | q\_e |
| q\_e | q\_e | q\_e | q\_e | q\_e | q\_e |

**4.**

* **Para depurar:** A **representação gráfica (diagrama)** é geralmente a mais útil, pois oferece uma visualização intuitiva do fluxo de controle. É fácil seguir os caminhos e entender como diferentes *strings* são processadas.  
* **Para implementar:** A **representação tabular (tabela de transições)** é a mais direta para implementação. Ela mapeia naturalmente para uma estrutura de dados como um array 2D ou um dicionário de dicionários, permitindo acesso O(1) ao próximo estado.

**3.5.** Para aceitar *strings* que terminam com "010", precisamos de um novo estado final. Podemos adicionar um estado q\_D e modificar as transições.

| Estado | 0 | 1 |
| :---- | :---- | :---- |
| rightarrowq\_A | q\_B | q\_A |
| q\_B | q\_B | q\_C |
| q\_C | \\\*q\_D | q\_A |
| \\\*q\_D | q\_B | q\_A |

### Exercícios 4: {@exercicios-4}

**1.**

1. Começa em q\_A.  
2. Lê '0': q\_Arightarrowq\_B. Estado atual: q\_B.  
3. Lê '1': q\_Brightarrowq\_C. Estado atual: q\_C.  
4. Lê '1': q\_Crightarrowq\_A. Estado atual: q\_A.  
5. Lê '0': q\_Arightarrowq\_B. Estado atual: q\_B.  
6. Lê '1': q\_Brightarrowq\_C. Estado atual: q\_C.  
   A computação termina em q\_C, que é um estado de aceitação. Portanto, a string 01101 é aceita.

**2.**

1. Começa em q\_0.  
2. Lê '\<': q\_0rightarrowq\_\\\<. Estado atual: q\_\\\<.  
3. Lê '=': q\_\\\<rightarrowq\_leq. Estado atual: q\_leq.  
   A computação termina em q\_leq, que é um estado de aceitação. A string \<= é aceita.

**3.**

* Para \!=: q\_0xrightarrowq\_xrightarrow=q\_neq. Termina em q\_neq (aceitação). **Aceita**.  
* Para \=\!: q\_0xrightarrow=q\_=xrightarrowq\_erro. Termina em q\_erro (rejeição). **Rejeitada**.

**4.** Não. A definição formal de aceitação exige que o estado final, após o processamento de **toda** a *string*, pertença ao conjunto F. Passar por um estado de aceitação no meio do caminho é irrelevante para a decisão final.

**5.**

* **Aceita:** ababa. Caminho: q\_ppxrightarrowaq\_ipxrightarrowbq\_iixrightarrowaq\_pixrightarrowbq\_ppxrightarrowaq\_ip. Ops, essa é rejeitada. Vamos tentar aabb.  
  * **Aceita:** aabb. Caminho: q\_ppxrightarrowaq\_ipxrightarrowaq\_ppxrightarrowbq\_pixrightarrowbq\_pp. Termina em q\_ppinF. Aceita.  
* **Rejeitada:** ababa. Caminho: q\_ppxrightarrowaq\_ipxrightarrowbq\_iixrightarrowaq\_pixrightarrowbq\_ppxrightarrowaq\_ip. Termina em q\_ipnotinF. Rejeitada.

### Exercícios 5: {@exercicios-5}

**1.** Diagrama para "aba":

* q\_0xrightarrowbq\_0  
* q\_0xrightarrowaq\_1  
* q\_1xrightarrowaq\_1  
* q\_1xrightarrowbq\_2  
* q\_2xrightarrowbq\_0  
* q\_2xrightarrowaq\_3  
* q\_3 é estado de aceitação (círculo duplo) com laços para 'a' e 'b' (delta(q\_3,a)=q\_3,delta(q\_3,b)=q\_3).

**2.** Diagrama para múltiplos de 3:

* Estados: q\_0 (resto 0), q\_1 (resto 1), q\_2 (resto 2).  
* q\_0 é inicial e de aceitação.  
* Transições:  
  * delta(q\_0,0)=q\_0, delta(q\_0,1)=q\_1  
  * delta(q\_1,0)=q\_2, delta(q\_1,1)=q\_0  
  * delta(q\_2,0)=q\_1, delta(q\_2,1)=q\_2

**3.** Tabela de transições para //:

| Estado | / | c |
| :---- | :---- | :---- |
| rightarrowq\_0 | q\_1 | q\_e |
| q\_1 | \\\*q\_2 | q\_e |
| \\\*q\_2 | \\\*q\_2 | \\\*q\_2 |
| q\_e | q\_e | q\_e |

**4.** Diagrama para comprimento ímpar e termina com 'a':

* Estados: q\_0 (par), q\_1 (ímpar, termina 'a'), q\_2 (ímpar, termina 'b'), q\_e (erro).  
* q\_0 é inicial. q\_1 é de aceitação.  
* delta(q\_0,a)=q\_1, delta(q\_0,b)=q\_2  
* delta(q\_1,a)=q\_0, delta(q\_1,b)=q\_0  
* delta(q\_2,a)=q\_0, delta(q\_2,b)=q\_0  
  (Uma versão mais simples pode combinar os estados de paridade e o último caractere).

**5.** Diagrama para cat ou car:

* q\_0xrightarrowcq\_1  
* q\_1xrightarrowaq\_2  
* q\_2xrightarrowtq\_3 (q\_3 é de aceitação)  
* q\_2xrightarrowrq\_4 (q\_4 é de aceitação)  
* Todas as outras transições levam a um estado de erro q\_e.

### Exercícios 6: {@Exercicios-6  }

**1.**

* M\_1: Q\_1=p\_0,p\_1 (par, ímpar), q\_01=p\_0, F\_1=p\_0.  
* M\_2: Q\_2=r\_0,r\_1 (não termina 'b', termina 'b'), q\_02=r\_0, F\_2=r\_1.  
* Q=Q\_1timesQ\_2=(p\_0,r\_0),(p\_0,r\_1),(p\_1,r\_0),(p\_1,r\_1).

| Estado | a | b |
| :---- | :---- | :---- |
| rightarrow(p\_0,r\_0) | (p\_1,r\_0) | (p\_0,r\_1) |
| (p\_0,r\_1) | (p\_1,r\_0) | (p\_0,r\_1) |
| (p\_1,r\_0) | (p\_0,r\_0) | (p\_1,r\_1) |
| (p\_1,r\_1) | (p\_0,r\_0) | (p\_1,r\_1) |

**2.**

* **Estado Inicial**: (p\_0,r\_0).  
* **Estados de Aceitação (União)**: Um estado (p\_i,r\_j) é final se p\_iinF\_1 OU r\_jinF\_2.  
  * F\_1=p\_0, F\_2=r\_1.  
  * F=(p\_0,r\_0),(p\_0,r\_1),(p\_1,r\_1).

**3.** O autômato produto terá ∣Q\_1∣times∣Q\_2∣=3times4=12 estados.

**4.** A linguagem reconhecida seria a mesma, L(M\_1)cupL(M\_1)=L(M\_1). O autômato produto resultante, no entanto, teria ∣Q\_1∣times∣Q\_1∣ estados. Este novo autômato seria equivalente ao original, mas não seria mínimo. Ele poderia ser minimizado de volta para M\_1.

**5.** Sim. A função de transição do produto é definida como delta((q\_1,q\_2),a)=(delta\_1(q\_1,a),delta\_2(q\_2,a)). Se M\_1 e M\_2 são completos, então delta\_1(q\_1,a) e delta\_2(q\_2,a) estão definidos para todos os pares. Consequentemente, a transição delta do autômato produto também estará definida para todos os pares, tornando-o completo.

### Exercícios 7: {@Exercios-7}

**1.** A tabela de transições é idêntica à da união (exercício 6.1). A única diferença está nos estados de aceitação.

| Estado | a | b |
| :---- | :---- | :---- |
| rightarrow(p\_0,r\_0) | (p\_1,r\_0) | (p\_0,r\_1) |
| (p\_0,r\_1) | (p\_1,r\_0) | (p\_0,r\_1) |
| (p\_1,r\_0) | (p\_0,r\_0) | (p\_1,r\_1) |
| (p\_1,r\_1) | (p\_0,r\_0) | (p\_1,r\_1) |

**2.** Para a interseção, um estado (p\_i,r\_j) é final se p\_iinF\_1 E r\_jinF\_2.

* F\_1=p\_0, F\_2=r\_1.  
* F=F\_1timesF\_2=(p\_0,r\_1).

**3.** O autômato complemento M′ terá a mesma estrutura, mas com os estados finais e não finais trocados.

* M′=(q\_0,q\_1,a,b,delta,q\_0,q\_0).  
* L(M) é a linguagem das *strings* com pelo menos um 'a'.  
* overlineL(M) é a linguagem das *strings* sem nenhum 'a', ou seja, *strings* compostas apenas por 'b's (b\\\*). O autômato M′ reconhece exatamente isso: ele só fica em q\_0 (que agora é final) se ler apenas 'b's. Ao ler um 'a', ele vai para q\_1 (agora não final) e nunca mais sai.

**4.** Se o autômato for incompleto, ele possui transições indefinidas que implicitamente levam a um estado de erro e rejeição. Se simplesmente invertermos os estados finais, essas transições indefinidas ainda levam à rejeição. No entanto, no complemento, essas *strings* deveriam ser aceitas. Por exemplo, uma *string* que trava o autômato incompleto é rejeitada. No complemento, ela também seria rejeitada (pois não termina em um estado final), mas a linguagem complemento deveria aceitá-la. Completar o autômato primeiro garante que toda *string* termine em algum estado (seja ele de aceitação, não-aceitação ou erro), permitindo que a simples inversão funcione corretamente.

**5.** Sim. Se L é regular, overlineL é regular. O complemento do complemento, overlineoverlineL, é a própria linguagem original L. Como overlineL é regular, seu complemento (overlineoverlineL=L) também deve ser regular, pelo mesmo teorema.

