# Alfabetos, Linguagens e Strings: Fundamentos Matemáticos {#sec-alfabeto-linguagem-string}

A teoria da computação repousa sobre fundamentos matemáticos que, embora abstratos, fornecem uma base precisa para a compreensão de como as máquinas processam informações. Entre estes fundamentos, os conceitos de **alfabeto**, **linguagem** e **_string_** ocupam uma posição central, formando a estrutura conceitual sobre a qual se ergue toda a teoria de linguagens formais e, consequentemente, a engenharia de compiladores.

Estes conceitos, aparentemente simples à primeira vista, revelam-se ferramentas matemáticas poderosas capazes de capturar a essência da comunicação entre humanos e máquinas. A curiosa leitora descobrirá que a formalização matemática destes conceitos elementares permite modelar desde a estrutura de uma palavra até a complexidade de uma linguagem de programação completa.

Neste capítulo, vamos explorar como a matemática dos conjuntos se entrelaça com a intuição linguística. Começaremos com os blocos mais básicos, os símbolos e alfabetos, progredindo por meio das _strings_ e linguagens, até chegarmos às expressões regulares, uma notação concisa e poderosa para descrever conjuntos infinitos de _strings_.

## Alfabetos: Os Blocos Fundamentais

Um **alfabeto** constitui o artefato fundamental da teoria de linguagens formais. Matematicamente, um alfabeto é um conjunto finito não-vazio de símbolos, denotado convencionalmente pela letra grega $\Sigma$, o sigma maiúsculo. Neste contexto, um alfabeto será definido como:

$$\Sigma = \{a_1, a_2, \ldots, a_n\} \text{ tal que } |\Sigma| = n < \infty \text{ e } n \geq 1$$

Como esse é o nosso primeiro contato a cuidadosa leitora deve observar que a definição elegante e formal de alfabeto pode ser decomposta em partes mais simples:

- $\Sigma = \{a_1, a_2, \ldots, a_n\}$: o alfabeto é um conjunto formado por $n$ símbolos distintos ($a_1$ até $a_n$).
- $|\Sigma| = n$: o tamanho do alfabeto (número de símbolos) é $n$.
- $n < \infty$: o alfabeto é **finito** (não possui infinitos símbolos).
- $n \geq 1$: o alfabeto é **não vazio**, ou seja, contém pelo menos um símbolo.

A natureza dos símbolos que compõem um alfabeto é irrelevante para a teoria matemática subjacente. Um símbolo pode ser uma letra, um dígito, um caractere especial, ou qualquer entidade atômica que possa ser distinguida de outras. A única exigência é que os símbolos sejam mutuamente distintos e que o conjunto seja finito.

### Exemplos de Alfabetos

A teoria ganha vida por meio de exemplos concretos. Considere os seguintes alfabetos frequentemente utilizados na ciência da computação:

1. **Alfabeto binário**: $\Sigma_{\text{bin}} = \{0, 1\}$. Este alfabeto fundamental aparece em representações binárias, lógica booleana e circuitos digitais. A cardinalidade deste alfabeto é $|\Sigma_{\text{bin}}| = 2$.

2. **Alfabeto das letras minúsculas**: $\Sigma_{\text{abc}} = \{a, b, c, \ldots, z\}$. Usado para modelar identificadores em linguagens de programação e texto em linguagem natural. Sua cardinalidade é $|\Sigma_{\text{abc}}| = 26$.

3. **Alfabeto para representação de números decimais**: $\Sigma_{\text{dec}} = \{+, -, ., 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$. Fundamental para a representação de números em notação decimal. Incluindo números reais, positivos e negativos, considerando o símbolo '.' como separador decimal. A cardinalidade é $|\Sigma_{\text{dec}}| = 13$.

4. **Alfabeto ASCII para Expressões Aritméticas**: $\Sigma_{\text{arit}} = \{a, b, \ldots, z, 0, 1, \ldots, 9, +, -, *, /\}$. Este exemplo define um subconjunto concreto e útil do ASCII, adequado para modelar identificadores de uma única letra e operações aritméticas simples. O uso de $\ldots$ (elipses) aqui é uma notação concisa para representar todos os caracteres dentro de um intervalo sequencial bem definido, neste caso, as letras minúsculas de 'a' a 'z' e os dígitos de '0' a '9'. Ao contrário de uma definição com uma cardinalidade ambígua, esta abordagem permite um cálculo exato do tamanho do alfabeto considerando letras = ${a, b, \ldots, z}$ (26), dígitos = ${0, 1, \ldots, 9}$ (10), operadores = ${+, -, *, /}$ seria:

$$|\Sigma_{\text{arit}}| = \text{(letras)} + \text{(dígitos)} + \text{(operadores)} = 26 + 10 + 4 = 40$$

### Propriedades Matemáticas dos Alfabetos

A definição formal de alfabeto como conjunto finito implica que precisaremos considerar três propriedades importantes:

1. **Finitude**: todo alfabeto possui um número finito de símbolos. Esta restrição não é uma limitação prática, mas sim uma necessidade teórica que garante a decidibilidade de muitos problemas computacionais. Decidibilidade, neste contexto, refere-se à capacidade de determinar se uma _string_ pertence a uma linguagem definida sobre um alfabeto.

2. **Distinção**: cada símbolo em um alfabeto é único e distinguível. Formalmente, se $a, b \in \Sigma$ e $a \neq b$, então $a$ e $b$ são símbolos diferentes.

3. **Não-ordenação inerente**: um alfabeto, sendo um conjunto matemático, não possui uma ordenação natural. Qualquer ordenação, como a ordem alfabética, é uma convenção externa imposta para conveniência.

### Exercícios 1 {#sec-ex-alfabeto}

1. Determine a cardinalidade dos seguintes alfabetos:
   a. $\Sigma_1 = \{a, b, c, +, -, *, /, (, )\}$;
   b. $\Sigma_2 = \{0, 1, 2, \ldots, 9, A, B, C, D, E, F\}$ (hexadecimal);
   c. $\Sigma_3 = \{\text{verdadeiro}, \text{falso}, \land, \lor, \neg, (, )\}$.

2. Construa alfabetos apropriados para os seguintes contextos:
   a. Expressões lógicas booleanas simples com variáveis $p$, $q$, $r$;
   b. Números em notação científica (ex: $1.23 \times 10^{-4}$);
   c. Coordenadas cartesianas no formato $(x, y)$.

3. Determine quais dos seguintes conjuntos são alfabetos válidos segundo a definição formal. Justifique sua resposta:
   a. $A = \emptyset$;
   b. $B = \{\epsilon\}$;
   c. $C = \{1, 2, 3, \ldots\}$;
   d. $D = \{a, b, a\}$.

4. Dado o conjunto de _strings_ $S = \{\text{if}, \text{then}, \text{else}, \text{fi}\}$, determine o menor alfabeto $\Sigma$ tal que todas as _strings_ em $S$ possam ser formadas usando símbolos de $\Sigma$.

5. Compare os alfabetos $\Sigma_A = \{0, 1\}$ e $\Sigma_B = \{a, b, c\}$ em termos de:
   a. Cardinalidade;
   b. Número de _strings_ de comprimento 3 que podem ser formadas;
   c. Aplicabilidade para representar números binários.

## Strings: Sequências Sobre Alfabetos

Uma **_string_** (ou **cadeia**) sobre um alfabeto $\Sigma$ é uma sequência finita de símbolos escolhidos de $\Sigma$. Formalmente, uma _string_ $w$ de comprimento $n$ pode ser representada como:

$$w = a_1a_2\ldots a_n \text{ tal que } a_i \in \Sigma \text{ para } i = 1, 2, \ldots, n$$

Na qual, temos:

- $w = a_1a_2\ldots a_n$: uma **_string_** $w$ é uma sequência finita de símbolos concatenados.
- $a_i \in \Sigma \quad \text{para} \quad i = 1, 2, \ldots, n$: cada elemento $a_i$ na _string_ pertence ao alfabeto $\Sigma$.
- A _string_ possui comprimento $|w| = n$ (número de símbolos na sequência). Por exemplo, se $w = abc$, então $|w| = 3$.

### A _string_ Vazia

Um caso especial é a **_string_ vazia**, denotada por $\epsilon$, letra grega épsilon minúsculo. Esta _string_ existe, não contém símbolos e possui comprimento zero:

$$\epsilon = \text{string vazia tal que } |\epsilon| = 0$$

A _string_ vazia desempenha um papel análogo ao número zero na aritmética, servindo como elemento neutro para a operação de concatenação de _strings_.

### Operações com Strings

Assim como a aritmética define operações como adição e multiplicação sobre o conjunto dos números, a teoria das linguagens formais estabelece operações para manipular e combinar _strings_. Essas operações formam uma espécie de álgebra sobre as _strings_, permitindo-nos construir sequências complexas a partir de componentes mais simples de maneira formal e precisa. A seguir, exploraremos as operações mais importantes, começando pela mais fundamental de todas, que serve como base para quase todas as outras: a **concatenação**.

#### Concatenação

A operação fundamental com _strings_ é a **concatenação**. Para duas _strings_ $x$ e $y$, a concatenação $xy$ é a _string_ formada pela justaposição de $x$ seguida por $y$.

**Definição formal**: se $x = a_1a_2\ldots a_m$ e $y = b_1b_2\ldots b_n$, então:

$$xy = a_1a_2\ldots a_mb_1b_2\ldots b_n$$

Alternativamente, a concatenação pode ser representada com a mesma notação do produto escalar. Assim, a concatenação de $x$ e $y$ pode ser denotada como $x \cdot y$.

**Propriedades da concatenação**:

- **Associatividade**: para _strings_ $x$, $y$, $z$, temos $(xy)z = x(yz)$.
- **Elemento neutro**: para qualquer _string_ $w$, $w\epsilon = \epsilon w = w$.
- **Não-comutatividade**: em geral, $xy \neq yx$.

#### Potências de Strings

Para uma _string_ $w$ e um inteiro não-negativo $n$, a **potência** $w^n$ é definida recursivamente:

$$w^0 = \epsilon$$
$$w^{n+1} = w^n \cdot w \text{ para } n \geq 0$$

Por exemplo, se $w = ab$, então $w^3 = ababab$.

Antes de avançarmos para operações com linguagens, a atenta leitora deve distinguir a operação de **potência de uma _string_** da operação de **Fechamento de Kleene**, que será detalhada adiante. Enquanto a potência $w^n$ aplica-se a uma _única string_ $w$ para produzir como resultado outra _única string_, o Fechamento de Kleene, denotado por um asterisco, como em $L^*$, é uma operação que se aplica a um _conjunto de strings_, uma linguagem, ou a um _conjunto de símbolos_, um alfabeto. O resultado do Fechamento de Kleene não é uma _string_, mas sim um novo _conjunto de strings_, geralmente infinito, representando todas as combinações possíveis de elementos do conjunto original. A potência é, portanto, uma operação sobre elementos individuais, enquanto o Fechamento de Kleene é uma operação sobre conjuntos.

#### Reverso de Strings

O **reverso** de uma _string_ $w$, denotado por $w^R$, é a _string_ obtida invertendo a ordem dos símbolos:

**Definição recursiva**:

- $\epsilon^R = \epsilon$;
- $(wa)^R = aw^R$ para $w \in \Sigma^*$ e $a \in \Sigma$.

Por exemplo, se $w = abc$, então $w^R = cba$.

### Substrings, Prefixos e Sufixos: Entendendo as Partes de uma String

Ao trabalhar com texto e linguagens de programação, raramente tratamos uma _string_ como uma unidade indivisível. Quase sempre precisamos inspecionar, extrair ou analisar suas partes internas. Os conceitos de **substring**, **prefixo** e **sufixo** nos dão um vocabulário formal e preciso para descrever essas partes.

Este vocabulário formado de termos para as partes em que podemos dividir _strings_ será relevante quando: estivermos estudando analisadores léxicos e sintáticos, pois eles frequentemente operam sobre essas partes para identificar padrões, validar estruturas e extrair informações significativas; criando ferramentas de busca e análise de texto, onde precisamos localizar ocorrências de padrões dentro de grandes volumes de texto; ou desenvolvendo algoritmos que manipulam ou processam _strings_ de maneira eficiente; ou ainda, ao implementar funcionalidades de autocompletar em editores de texto e IDEs, onde o sistema sugere palavras ou comandos com base no que o usuário já digitou.

#### Substring

Uma substring é simplesmente um pedaço ou um segmento contínuo de caracteres que está dentro de outra _string_. Formalmente dizemos que uma _string_ `$v$` é uma substring de `$w$` se for possível encontrar duas outras _strings_, `$x$` (a parte que vem antes) e `$y$` (a parte que vem depois), de forma que `$w = xvy$`. As _strings_ `$x$` ou `$y$` podem, inclusive, ser vazias.

**Exemplo**: Para a _string_ `$w = compilador$`, as palavras `pila`, `com`, `dor` e `compilador` são todas substrings válidas. No caso de `pila`, `$x = com$` e `$y = dor$`.

#### Prefixo

Um prefixo é um trecho que começa exatamente no início de uma _string_. Formalmente dizemos que uma _string_ `$v$` é um prefixo de `$w$` se houver uma _string_ `$y$` (o resto da _string_) tal que `$w = vy$`.

**Exemplo**: Para `$w = compilador$`, alguns prefixos são `c`, `com`, `compi` e a própria _string_ `compilador`.

##### Prefixo Próprio

Dizemos que uma _string_ é um prefixo próprio de outra _string_ se for um prefixo que não seja a própria _string_ inteira. Formalmente, um prefixo `$v$` de `$w$` é dito próprio se `$v \neq w$`.

**Exemplo**: Para `$w = compilador$`, `compi` é um prefixo próprio, mas `compilador` não é.

#### Sufixo

Um sufixo é um trecho que termina exatamente no final de uma _string_. Formalmente dizemos que uma _string_ `$v$` é um sufixo de `$w$` se houver uma _string_ `$x$` (a parte inicial) tal que `$w = xv$`.

**Exemplo**: Para `$w = compilador$`, alguns sufixos são `r`, `dor`, `lador` e a própria _string_ `compilador`.

##### Sufixo Próprio

Dizemos que uma _string_ é um sufixo próprio se for qualquer sufixo que não seja a própria _string_ inteira. Formalmente,  um sufixo `$v$` de `$w$` é dito próprio se `$v \neq w$.

**Exemplo**: Para `$w = compilador$`, `lador` é um sufixo próprio, mas `compilador` não é.

Definir formalmente essas _partes_ de uma _string_ é fundamental para a ciência da computação, pois elas são a base para inúmeras operações e algoritmos:

### Exercícios 2 {#sec-ex-strings}

1. Sejam $x = ab$ e $y = cd$. Calcule:
   a. $xy$ e $yx$;
   b. $x^3$ e $y^2$;
   c. $(xy)^2$ e $x^2y^2$;
   d. $|x^n|$ em função de $n$.

2. Para as _strings_ dadas, determine seus reversos:
   a. $w_1 = abcde$;
   b. $w_2 = palíndromo$;
   c. $w_3 = \epsilon$ (string vazia);
   d. Prove que $(\epsilon)^R = \epsilon$.

3. Demonstre as seguintes propriedades usando _strings_ específicas:
   a. Associatividade: $(xy)z = x(yz)$ para $x = a$, $y = bc$, $z = d$;
   b. Elemento neutro: $w\epsilon = \epsilon w = w$ para $w = abc$;
   c. Não-comutatividade: encontre $x$ e $y$ tais que $xy \neq yx$.

4. Para a _string_ $w = compilador$:
   a. Liste todos os prefixos próprios;
   b. Liste todos os sufixos próprios;
   c. Identifique todas as substrings de comprimento 4;
   d. Determine quantos prefixos e sufixos $w$ possui no total.

5. Seja $w = aba$. Calcule:
   a. $(w^R)^2$;
   b. $(w^2)^R$;
   c. $w^R w$;
   d. Verifique se $(w^2)^R = (w^R)^2$.

## Linguagens: Conjuntos de Strings

Uma **linguagem** sobre um alfabeto $\Sigma$ é simplesmente um conjunto de _strings_ formadas a partir de símbolos de $\Sigma$. Formalmente:

$$L \subseteq \Sigma^*$$

na qual $\Sigma^*$ denota o conjunto de todas as _strings_ possíveis sobre $\Sigma$, incluindo a _string_ vazia $\epsilon$.

### O Conjunto Universal $\Sigma^*$

O conjunto $\Sigma^*$ (lê-se _sigma estrela_ ou _fechamento de Kleene de $\Sigma$_) é definido como:

$$\Sigma^* = \Sigma^0 \cup \Sigma^1 \cup \Sigma^2 \cup \Sigma^3 \cup \ldots$$

na qual:

- $\Sigma^0 = \{\epsilon\}$;
- $\Sigma^1 = \Sigma = \{a_1, a_2, \ldots, a_n\}$;
- $\Sigma^2 = \{xy \mid x, y \in \Sigma\}$;
- $\Sigma^k = \{w \mid |w| = k \text{ e } w \text{ é string sobre } \Sigma\}$.
  
Dessa forma, $\Sigma^k$ é o conjunto de todas as _strings_ de comprimento $k$ formadas por símbolos de $\Sigma$

Para o alfabeto binário $\Sigma = \{0, 1\}$:

$$\Sigma^* = \{\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, 101, 110, 111, \ldots\}$$

### Exemplos de Linguagens

1. **Linguagem vazia**: $L_{\emptyset} = \emptyset$. A linguagem que não contém nenhuma _string_. É importante distinguir da linguagem que contém apenas a _string_ vazia.

2. **Linguagem contendo apenas a _string_ vazia**: $L_{\epsilon} = \{\epsilon\}$. Uma linguagem com exatamente um elemento, a _string_ vazia.

3. **Linguagem de todas as _strings_ binárias**: $L_{\text{todas}} = \{0, 1\}^*$. Esta linguagem contém todas as _strings_ possíveis sobre o alfabeto binário.

4. **Linguagem de _strings_ binárias de comprimento par**:
$$L_{\text{par}} = \{w \in \{0, 1\}^* \mid |w| \text{ é par}\}$$

**Linguagem de identificadores válidos**: para modelar identificadores em uma linguagem de programação:
$$L_{\text{id}} = \{w \in \{a, \ldots, z, A, \ldots, Z, 0, \ldots, 9, \_\}^* \mid w \text{ inicia com letra ou } \_\}$$

### Operações com Linguagens

Da mesma forma que operamos com _strings_ individuais, podemos realizar operações com linguagens inteiras para construir novas linguagens a partir de outras. Uma vez que uma linguagem é, por definição, um conjunto de _strings_ ($L \subseteq \Sigma^*$), ela herda naturalmente as operações fundamentais da teoria dos conjuntos. Adicionalmente, estenderemos as operações que vimos para _strings_, como a concatenação, para que se apliquem a conjuntos inteiros de _strings_. Iniciaremos nossa exploração com as operações que derivam diretamente da natureza das linguagens como conjuntos.

#### União de Linguagens

A **união** representa a operação mais natural e intuitiva entre linguagens, capturando a essência da **escolha** ou **alternativa**. Quando unimos duas linguagens, criamos uma nova linguagem que aceita qualquer _string_ que pertença a pelo menos uma das linguagens originais. É como estabelecer uma regra de aceitação do tipo _ou isto, ou aquilo, ou ambos_.

Esta operação herda diretamente da teoria dos conjuntos, mas seu significado em linguagens formais transcende a mera manipulação de conjuntos, tornando-se uma ferramenta fundamental para expressar alternativas em especificações de linguagens.

**União**: A união de duas linguagens $L_1$ e $L_2$ é:

$$L_1 \cup L_2 = \{w \mid w \in L_1 \text{ ou } w \in L_2\}$$

A palavra _ou_ aqui é inclusiva: uma _string_ pertence à união se está em $L_1$, ou em $L_2$, ou em ambas.

##### Exemplos de União

**Exemplo 1**: Linguagens de Tokens Simples

- $L_{\text{num}} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$ (dígitos);
- $L_{\text{op}} = \{+, -, *, /\}$ (operadores);
- $L_{\text{token}} = L_{\text{num}} \cup L_{\text{op}} = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, -, *, /\}$.

Esta união modela os tokens básicos de uma calculadora simples.

**Exemplo 2**: Linguagens de Comprimentos Específicos

- $L_{\text{par}} = \{w \in \{a, b\}^* \mid |w| \text{ é par}\}$;
- $L_{\text{ímpar}} = \{w \in \{a, b\}^* \mid |w| \text{ é ímpar}\}$;  
- $L_{\text{par}} \cup L_{\text{ímpar}} = \{a, b\}^*$ (todas as _strings_ sobre $\{a, b\}$).

**Exemplo 3**: Linguagens Sobrepostas

- $L_1 = \{a, ab, abc\}$;
- $L_2 = \{ab, bc, c\}$;
- $L_1 \cup L_2 = \{a, ab, abc, bc, c\}$.

Note que $ab$ aparece em ambas as linguagens, mas na união aparece apenas uma vez, seguindo a definição de conjunto.

##### Propriedades Algébricas da União

A união satisfaz propriedades fundamentais que a tornam uma operação bem-comportada:

**1. Comutatividade**:
$$L_1 \cup L_2 = L_2 \cup L_1$$

A ordem das linguagens na união não importa.

**2. Associatividade**:
$$(L_1 \cup L_2) \cup L_3 = L_1 \cup (L_2 \cup L_3)$$

Podemos agrupar uniões de qualquer forma, permitindo escrever $L_1 \cup L_2 \cup L_3$ sem ambiguidade.

**3. Elemento Neutro**:
$$L \cup \emptyset = \emptyset \cup L = L$$

A linguagem vazia não adiciona elementos a qualquer união.

**4. Idempotência**:
$$L \cup L = L$$

Unir uma linguagem consigo mesma não a modifica.

**5. Absorção**:
$$L \cup \Sigma^* = \Sigma^*$$

Unir qualquer linguagem com a linguagem universal resulta na linguagem universal.

##### Aplicações Práticas da União

**1. Definição de Alfabetos Estendidos**: em linguagens de programação, frequentemente definimos categorias de caracteres como:

- Letras: $L_{\text{letras}} = \{a, b, \ldots, z, A, B, \ldots, Z\}$;
- Dígitos: $L_{\text{dígitos}} = \{0, 1, \ldots, 9\}$;  
- Alfanuméricos: $L_{\text{alfanum}} = L_{\text{letras}} \cup L_{\text{dígitos}}$.

**2. Validação de Formatos Alternativos**: para aceitar diferentes formatos de data:

- $L_{\text{br}} = \{dd/mm/aaaa\}$ (formato brasileiro);
- $L_{\text{us}} = \{mm/dd/aaaa\}$ (formato americano);
- $L_{\text{iso}} = \{aaaa-mm-dd\}$ (formato ISO);
- $L_{\text{data}} = L_{\text{br}} \cup L_{\text{us}} \cup L_{\text{iso}}$.

**3. Tratamento de Variações Lexicais**: em processamento de linguagem natural:

- $L_{\text{sim}} = \{\text{sim}, \text{yes}, \text{oui}, \text{sí}\}$;
- $L_{\text{não}} = \{\text{não}, \text{no}, \text{non}\}$;
- $L_{\text{resposta}} = L_{\text{sim}} \cup L_{\text{não}}$.

#### Concatenação de Linguagens

A **concatenação** captura a essência da **composição sequencial**: formar novas _strings_ justapondo elementos de duas linguagens em uma ordem específica. É como estabelecer uma regra de construção do tipo _primeiro algo de $L_1$, depois algo de $L_2$_.

Esta operação estende naturalmente a concatenação de _strings_ individuais para conjuntos inteiros de _strings_, criando um mecanismo fundamental para a construção de linguagens complexas a partir de componentes mais simples.

**Concatenação**: A concatenação de duas linguagens $L_1$ e $L_2$ é:

$$L_1 \cdot L_2 = \{xy \mid x \in L_1 \text{ e } y \in L_2\}$$

O resultado é o conjunto de todas as _strings_ possíveis formadas escolhendo-se uma _string_ de $L_1$ seguida por uma _string_ de $L_2$.

##### Exemplos de Concatenação

**Exemplo 1**: construção de Identificadores

- $L_{\text{letra}} = \{a, b, c, \ldots, z\}$;
- $L_{\text{dígito}} = \{0, 1, 2, \ldots, 9\}$;
- $L_{\text{letra}} \cdot L_{\text{dígito}} = \{a0, a1, \ldots, a9, b0, b1, \ldots, z9\}$.

Esta concatenação gera todos os identificadores de exatamente dois caracteres que começam com uma letra seguida de um dígito.

**Exemplo 2**: Construção Passo a Passo

- $L_1 = \{a, bb\}$;
- $L_2 = \{c, dd\}$;
- $L_1 \cdot L_2 = \{ac, add, bbc, bbdd\}$.

Cálculo detalhado:

- $a \in L_1, c \in L_2 \Rightarrow ac \in L_1 \cdot L_2$
- $a \in L_1, dd \in L_2 \Rightarrow add \in L_1 \cdot L_2$  
- $bb \in L_1, c \in L_2 \Rightarrow bbc \in L_1 \cdot L_2$
- $bb \in L_1, dd \in L_2 \Rightarrow bbdd \in L_1 \cdot L_2$

**Exemplo 3**: Concatenação com Linguagem Unitária

- $L = \{hello, hi\}$;
- $\{!\} = \{!\}$;
- $L \cdot \{!\} = \{hello!, hi!\}$.

##### Propriedades Algébricas da Concatenação

A concatenação possui um conjunto distinto de propriedades que a diferenciam significativamente da união:

**1. Associatividade**:
$$(L_1 \cdot L_2) \cdot L_3 = L_1 \cdot (L_2 \cdot L_3)$$

Podemos agrupar concatenações de qualquer forma, permitindo escrever $L_1 \cdot L_2 \cdot L_3$ sem ambiguidade.

**2. Elemento Neutro**:
$$L \cdot \{\epsilon\} = \{\epsilon\} \cdot L = L$$

A linguagem contendo apenas a _string_ vazia atua como elemento neutro para a concatenação.

**3. Elemento Anulador**:
$$L \cdot \emptyset = \emptyset \cdot L = \emptyset$$

A linguagem vazia anula qualquer concatenação.

**4. Não-Comutatividade** (propriedade crucial):
$$L_1 \cdot L_2 \neq L_2 \cdot L_1 \text{ (em geral)}$$

A ordem na concatenação importa fundamentalmente. Do exemplo anterior:

- $L_1 \cdot L_2 = \{ac, add, bbc, bbdd\}$;
- $L_2 \cdot L_1 = \{ca, cbb, dda, ddbb\}$;

**5. Distributividade sobre União**:
$$L_1 \cdot (L_2 \cup L_3) = L_1 \cdot L_2 \cup L_1 \cdot L_3$$
$$(L_1 \cup L_2) \cdot L_3 = L_1 \cdot L_3 \cup L_2 \cdot L_3$$

Esta propriedade é fundamental para simplificação de expressões regulares.

##### Casos Especiais da Concatenação

**1. Concatenação com a Linguagem Universal**:
$$L \cdot \Sigma^* = \{xy \mid x \in L, y \in \Sigma^*\}$$

Resulta em todas as _strings_ que começam com algum elemento de $L$.

**2. Autoconcatenação**:
$$L \cdot L = L^2 = \{xy \mid x, y \in L\}$$

Base para a definição de potências de linguagens.

**3. Concatenação de Linguagens Infinitas**:

Se $L_1$ tem $m$ elementos e $L_2$ tem $n$ elementos, então $|L_1 \cdot L_2| \leq mn$, com igualdade quando todas as concatenações resultam em _strings_ distintas.

##### Aplicações Práticas da Concatenação

**1. Construção de Padrões Estruturados**: Para validar endereços de email (versão muito simplificada):

- $L_{\text{usuário}} = \{[a-zA-Z0-9]+\}$;
- $L_{\text{domínio}} = \{[a-zA-Z0-9.-]+\}$;
- $L_{\text{ext}} = \{[a-zA-Z]{2,}\}$;
- $L_{\text{email}} = L_{\text{usuário}} \cdot \{@\} \cdot L_{\text{domínio}} \cdot \{.\} \cdot L_{\text{ext}}$.

**2. Análise Sintática**: Em linguagens de programação:

- $L_{\text{tipo}} = \{int, float, string\}$;
- $L_{\text{id}} = \{[a-zA-Z][a-zA-Z0-9]*\}$;
- $L_{\text{declaração}} = L_{\text{tipo}} \cdot \{$ $\} \cdot L_{\text{id}}$.

**3. Protocolos de Comunicação**:

- $L_{\text{header}} = \{HTTP/1.1, HTTP/2.0\}$;
- $L_{\text{método}} = \{GET, POST, PUT, DELETE\}$;
- $L_{\text{requisição}} = L_{\text{método}} \cdot \{$ $\} \cdot L_{\text{URL}} \cdot \{$ $\} \cdot L_{\text{header}}$.

##### Autômatos e Complexidade

A concatenação de linguagens finitas tem complexidade $O(|L_1| \times |L_2|)$ no caso geral, mas pode ser otimizada quando as linguagens têm estruturas específicas. Esta consideração é crucial em implementações práticas de analisadores léxicos e sintáticos.

Na teoria de autômatos, a concatenação corresponde à construção sequencial: aceitar uma _string_ em $L_1 \cdot L_2$ significa processar uma parte inicial com um autômato para $L_1$ e a parte restante com um autômato para $L_2$. Esta intuição será fundamental para construções como a de Thompson para expressões regulares.

A concatenação, portanto, não é apenas uma operação matemática, mas a operação que captura a essência da **sequencialidade** na computação e na especificação de linguagens.

#### Interseção e Complemento

Além das operações que derivam diretamente da teoria dos conjuntos (união) e das que estendem conceitos de _strings_ (concatenação), duas operações adicionais desempenham papéis fundamentais na teoria de linguagens formais: a **interseção** e o **complemento**. Estas operações, embora não sejam diretamente expressáveis por expressões regulares simples, são cruciais para compreender o poder e as limitações das Linguagens Regulares.

**Interseção**: a interseção de duas linguagens $L_1$ e $L_2$ será dada por:

$$L_1 \cap L_2 = \{w \mid w \in L_1 \text{ e } w \in L_2\}$$

A interseção captura as _strings_ que pertencem simultaneamente a ambas as linguagens. Esta operação é particularmente útil para construir linguagens que devem satisfazer múltiplas condições.

**Exemplo prático**: Considere uma linguagem de programação onde queremos definir identificadores que:

a. Comecem com letra: $L_1 = \{w \in \{a, \ldots, z, 0, \ldots, 9\}^* \mid w \text{ inicia com letra}\}$
b. Tenham comprimento par: $L_2 = \{w \in \{a, \ldots, z, 0, \ldots, 9\}^* \mid |w| \text{ é par}\}$

A interseção $L_1 \cap L_2$ contém exatamente os identificadores que começam com letra **e** têm comprimento par.

**Complemento**: O complemento de uma linguagem $L$ sobre um alfabeto $\Sigma$ é:

$$\overline{L} = \Sigma^* - L = \{w \in \Sigma^* \mid w \notin L\}$$

O complemento de $L$ contém todas as _strings_ possíveis sobre $\Sigma$ **exceto** aquelas que pertencem a $L$. Esta operação é fundamental para expressar condições negativas.

**Exemplo prático**: Se $L$ é a linguagem de todas as _strings_ binárias que contêm a substring $01$, então $\overline{L}$ é a linguagem de todas as _strings_ binárias que **não** contêm $01$ como substring — exatamente o padrão que vimos nos exemplos anteriores ser descrito pela expressão $1^*0^*$.

Na prática, interseção e complemento aparecem frequentemente em:

1. **Validação de dados**: Verificar que uma entrada satisfaz múltiplas condições simultaneamente
2. **Análise de segurança**: Definir padrões de tráfego permitido como complemento de padrões maliciosos
3. **Processamento de linguagens naturais**: Filtrar textos que pertencem a uma categoria mas não a outra
4. **Otimização de compiladores**: Análise de fluxo de dados onde certas condições devem ser simultaneamente satisfeitas

Estas operações, embora mais abstratas que concatenação e união, formam uma base teórica sólida que será fundamental quando explorarmos autômatos finitos e técnicas mais avançadas de análise de linguagens.

#### Potências de Linguagens

Para uma linguagem $L$ e um inteiro não-negativo $n$:

$$L^0 = \{\epsilon\}$$
$$L^{n+1} = L^n \cdot L \text{ para } n \geq 0$$

#### Fechamento de Kleene e Fechamento Positivo

Entre todas as operações com linguagens, o **fechamento de Kleene** destaca-se como uma das mais poderosas e fundamentais. Nomeada em homenagem ao matemático Stephen Kleene, esta operação captura a essência da **repetição arbitrária** — um conceito central tanto na teoria formal quanto nas aplicações práticas da computação.

Intuitivamente, o fechamento de Kleene de uma linguagem $L$ representa todas as possíveis concatenações de zero ou mais elementos de $L$. É como se perguntássemos: _Que _strings_ podemos formar se nos for permitido escolher elementos de $L$ quantas vezes quisermos, incluindo a possibilidade de não escolher nenhum?_

**Fechamento de Kleene**: O fechamento de Kleene de uma linguagem $L$ é:

$$L^* = L^0 \cup L^1 \cup L^2 \cup L^3 \cup \ldots = \bigcup_{i=0}^{\infty} L^i$$

Esta definição revela uma estrutura elegante: $L^*$ é construído pela união de todas as potências possíveis de $L$, começando de $L^0 = \{\epsilon\}$ (a linguagem contendo apenas a _string_ vazia) e estendendo-se infinitamente.

**Fechamento Positivo**: O fechamento positivo de $L$ é uma variação que exclui a possibilidade de _não escolher nada_:

$$L^+ = L^1 \cup L^2 \cup L^3 \cup \ldots = \bigcup_{i=1}^{\infty} L^i = L \cdot L^*$$

A diferença fundamental é que $L^+$ exige **pelo menos uma** escolha de $L$, enquanto $L^*$ permite zero escolhas.

A relação entre fechamento de Kleene e o fechamento positivo depende crucialmente de um fator: se a _string_ vazia $\epsilon$ pertence ou não à linguagem original $L$.

**Caso 1**: Se $\epsilon \notin L$, então:
$$L^+ = L^* - \{\epsilon\}$$

Neste caso, como $\epsilon \notin L$, ela só pode aparecer em $L^*$ através de $L^0 = \{\epsilon\}$. Todas as outras potências $L^i$ para $i \geq 1$ não contêm $\epsilon$, pois são formadas por concatenações de elementos de $L$ que não incluem $\epsilon$.

**Caso 2**: Se $\epsilon \in L$, então:
$$L^+ = L^*$$

Neste caso, se $\epsilon \in L = L^1$, então $\epsilon \in L^+$. Como $\epsilon$ também está em $L^*$ (via $L^0$), e ambos contêm todas as outras potências, os conjuntos são idênticos.

##### Exemplos

**Exemplo 1**: $L = \{a\}$

- $L^* = \{\epsilon, a, aa, aaa, aaaa, \ldots\} = \{a^n \mid n \geq 0\}$
- $L^+ = \{a, aa, aaa, aaaa, \ldots\} = \{a^n \mid n \geq 1\}$
- Como $\epsilon \notin L$, temos $L^+ = L^* - \{\epsilon\}$

**Exemplo 2**: $L = \{ab, cd\}$  

- $L^* = \{\epsilon, ab, cd, abab, abcd, cdab, cdcd, ababab, \ldots\}$
- $L^+ = \{ab, cd, abab, abcd, cdab, cdcd, ababab, \ldots\}$
- Novamente, $L^+ = L^* - \{\epsilon\}$

**Exemplo 3**: $L = \{\epsilon, a\}$

- $L^* = L^+ = \{\epsilon, a, aa, aaa, \ldots\} = \{a^n \mid n \geq 0\}$
- Como $\epsilon \in L$, ambos os fechamentos são idênticos

##### Propriedades Matemáticas Fundamentais

Os fechamentos de Kleene satisfazem várias propriedades algébricas importantes:

**1. Idempotência do Fechamento de Kleene**:
$$(L^*)^* = L^*$$

**Intuição**: Aplicar o fechamento de Kleene duas vezes não adiciona novos elementos. Se já temos todas as concatenações possíveis de $L$, concatenar essas concatenações não produz nada novo.

**2. Inclusão da Linguagem Original**:
$$L \subseteq L^+ \subseteq L^*$$

**3. Elemento Neutro**:
$$L^* = \{\epsilon\} \cup L^+$$

**4. Relação com Concatenação**:
$$L^* = \{\epsilon\} \cup L \cdot L^*$$

Esta última propriedade fornece uma **definição recursiva** alternativa para o fechamento de Kleene, extremamente útil em demonstrações formais e construções de autômatos.

##### Casos Especiais Importantes

**Linguagem Vazia**: Para $L = \emptyset$:
$$\emptyset^* = \{\epsilon\}$$
$$\emptyset^+ = \emptyset$$

**Justificativa**: Como não podemos escolher elementos de $\emptyset$, a única _concatenação_ possível é a de zero elementos, resultando em $\epsilon$.

**Linguagem com _string_ Vazia**: Para $L = \{\epsilon\}$:
$$\{\epsilon\}^* = \{\epsilon\}$$
$$\{\epsilon\}^+ = \{\epsilon\}$$

**Justificativa**: Concatenar $\epsilon$ consigo mesmo qualquer número de vezes sempre resulta em $\epsilon$.

##### Aplicações Práticas em Ciência da Computação

**1. Análise Léxica**: o padrão `[a-zA-Z][a-zA-Z0-9]*` para identificadores utiliza o fechamento de Kleene implicitamente, onde `[a-zA-Z0-9]*` representa $\Sigma^*$ para o alfabeto alfanumérico.

**2. Expressões Regulares em Editores de Texto**: o operador `*` em expressões regulares corresponde diretamente ao fechamento de Kleene, permitindo buscar padrões com repetições arbitrárias.

**3. Protocolos de Comunicação**: muitos protocolos definem mensagens como sequências de unidades básicas, onde o fechamento de Kleene modela a repetição arbitrária dessas unidades.

**4. Análise de Algoritmos**: estruturas como loops infinitos ou processos iterativos são naturalmente modelados usando fechamentos de Kleene de operações básicas.

##### Conexão com Autômatos Finitos

O fechamento de Kleene possui uma interpretação natural em termos de autômatos finitos: $L^*$ corresponde à linguagem aceita por um autômato que pode _reiniciar_ infinitas vezes após aceitar uma _string_ de $L$. Esta conexão será fundamental quando explorarmos a construção de Thompson para converter expressões regulares em autômatos.

##### Fechamento como Operação Universal

Uma perspectiva interessante é que o fechamento de Kleene pode ser visto como a **menor** solução para a equação:
$$X = \{\epsilon\} \cup L \cdot X$$

Esta caracterização como ponto fixo mínimo conecta os fechamentos de Kleene com áreas avançadas da ciência da computação, incluindo semântica denotacional e análise de programas.

O fechamento de Kleene, portanto, não é apenas uma operação matemática abstrata, mas uma ferramenta conceitual poderosa que captura a essência da computação iterativa e da geração de linguagens através de repetição controlada.

#### Propriedades e Fechamento

Uma propriedade notável das Linguagens Regulares é que elas são **fechadas** sob ambas as operações:

**Teorema (Fechamento das Linguagens Regulares)**:

Se $L_1$ e $L_2$ são Linguagens Regulares sobre um alfabeto $\Sigma$, então:

1. $L_1 \cap L_2$ é uma Linguagem Regular
2. $\overline{L_1}$ é uma Linguagem Regular

Esta propriedade de fechamento é uma das características que tornam as Linguagens Regulares tão robustas e úteis na prática. Ela garante que operações complexas entre Linguagens Regulares sempre produzem linguagens que permanecem dentro da mesma classe de complexidade.

### As Leis de De Morgan em Linguagens Regulares

As Leis de De Morgan são um par de regras fundamentais da teoria dos conjuntos que se aplicam diretamente às linguagens formais, uma vez que linguagens são conjuntos de _strings_. Elas estabelecem uma relação poderosa entre as operações de união, interseção e complemento.

As leis são definidas da seguinte forma:

1. O complemento da união é a interseção dos complementos:
    $$ \overline{L_1 \cup L_2} = \overline{L_1} \cap \overline{L_2} $$

2. O complemento da interseção é a união dos complementos:
    $$ \overline{L_1 \cap L_2} = \overline{L_1} \cup \overline{L_2} $$

A principal importância dessas leis reside na sua capacidade de **simplificar e transformar especificações de linguagens**, especialmente aquelas que envolvem condições negativas (negações). As Leis de De Morgan nos permitem reescrever uma condição complexa de uma forma diferente e, muitas vezes, mais fácil de entender ou construir. A utilidade dessas leis se manifesta em:

1. **Expressar Negações Complexas**: as Leis de De Morgan permitem converter uma negação sobre uma operação complexa (como _não ser (A ou B)_) em operações mais simples sobre negações individuais (_não ser A_ E _não ser B_).

2. **Manipulação Algébrica**: Assim como na álgebra tradicional, as leis permitem manipular formalmente as descrições de linguagens para otimizá-las ou provar equivalências.

Como exemplo, se quisermos uma linguagem que descreva _strings_ que **não** terminam em `$01$` **nem** em `$10$`, estamos descrevendo uma condição `$ \neg (A \lor B) $`. Usando a primeira lei de De Morgan, podemos transformar isso em `$ (\neg A) \land (\neg B) $`:

$$ \overline{L_{01} \cup L_{10}} = \overline{L_{01}} \cap \overline{L_{10}} $$

Isso significa que podemos construir a linguagem procurando por _strings_ que satisfaçam duas condições simultaneamente: não terminar em `$01$` **E** não terminar em `$10$`.

No contexto das Linguagens Regulares, as Leis de De Morgan são mais uma ferramenta **teórica** do que uma sintaxe prática dentro das expressões regulares básicas. As operações de interseção ($`\cap`$) e complemento ($`\overline{L}`$) não possuem operadores diretos nas expressões regulares tradicionais (como `$*$` para Kleene ou `$ \cup $` para união).

O seu uso prático e teórico ocorre principalmente na **teoria dos autômatos finitos**:

1. **Construção de Autômatos**: Sabemos que as Linguagens Regulares são fechadas sob interseção e complemento. Isso significa que se temos autômatos para `$L_1$` e `$L_2$`, podemos construir autômatos para `$L_1 \cap L_2$` e `$ \overline{L_1} $`. As Leis de De Morgan garantem que podemos, por exemplo, construir um autômato para `$ \overline{L_1 \cup L_2} $` construindo autômatos para `$ \overline{L_1} $` e `$ \overline{L_2} $` e depois aplicando o algoritmo de interseção sobre eles.

2. **Provas de Equivalência**: As leis são usadas para provar que duas descrições de linguagens diferentes são, na verdade, equivalentes, o que é fundamental para a otimização de analisadores léxicos.

Em resumo, embora você não escreva `$ \overline{L_1} \cap \overline{L_2} $` diretamente em uma expressão regular comum, as Leis de De Morgan são o fundamento matemático que garante que podemos construir uma máquina (um autômato finito) para reconhecer essa linguagem complexa, validando o poder e a robustez da classe das Linguagens Regulares.

#### Limitações das Expressões Regulares Básicas

É importante observar que, embora as Linguagens Regulares sejam fechadas sob interseção e complemento, essas operações **não são diretamente expressáveis** usando apenas as três operações fundamentais das expressões regulares (união $\cup$, concatenação $\cdot$, e fechamento de Kleene $*$).

Para expressar interseções e complementos, frequentemente precisamos:

a. **Construir autômatos finitos** correspondentes às expressões regulares;
b. **Aplicar algoritmos específicos** para interseção e complemento de autômatos;
c. **Converter o resultado de volta** para uma expressão regular sempre que possível.

Este é um exemplo de como a teoria matemática subjacente (autômatos finitos) pode ser mais expressiva que a notação conveniente (expressões regulares) para certas operações, embora ambas representem exatamente a mesma classe de linguagens.

### Exercícios 3 {#sec-ex-linguagens2}

1. Sejam $L_1 = \{a, ab, b\}$ e $L_2 = \{b, ba, \epsilon\}$. Calcule:
   a. $L_1 \cup L_2$;
   b. $L_1 \cap L_2$;
   c. $L_1 - L_2$ (diferença);
   d. $|L_1 \cup L_2|$ e $|L_1 \cap L_2|$.

2. Para as linguagens $L_1 = \{a, bb\}$ e $L_2 = \{c, dd\}$:
   a. Calcule $L_1 \cdot L_2$ e $L_2 \cdot L_1$;
   b. Determine $|L_1 \cdot L_2|$;
   c. Verifique se $L_1 \cdot L_2 = L_2 \cdot L_1$.

3. Seja $L = \{a, b\}$. Determine:
   a. $L^0$, $L^1$, $L^2$;
   b. $|L^n|$ em função de $n$;
   c. As três primeiras _strings_ em ordem lexicográfica de $L^3$.

4. Para $L = \{ab\}$:
   a. Liste os elementos de $L^*$ até _strings_ de comprimento 6;
   b. Determine $L^+$;
   c. Verifique se $\epsilon \in L^*$ e se $\epsilon \in L^+$.

5. Seja $L = \{a\}$. Prove ou refute:
   a. $L^* = L^+$;
   b. $L^* \cup L^+ = L^*$;
   c. $(L^*)^* = L^*$;
   d. Se $\epsilon \in L$, então $L^+ = L^*$.

## Expressões Regulares: Uma Notação Concisa

As **expressões regulares** fornecem uma notação algébrica concisa e poderosa para descrever linguagens. Esta notação, introduzida por [Stephen Kleene](https://en.wikipedia.org/wiki/Stephen_Cole_Kleene), como vimos na @sec-kleene, permite especificar conjuntos potencialmente infinitos de _strings_ por meio de padrões finitos.

### Definição Indutiva

A definição de uma expressão regular sobre um alfabeto $\Sigma$ possui uma natureza indutiva, o que significa que ela é construída progressivamente, de elementos simples para estruturas complexas. Primeiramente, definimos as expressões regulares mais elementares, que servem como nossos **casos base**. Em seguida, estabelecemos as regras de construção, ou **casos indutivos**, que nos permitem combinar expressões existentes para formar novas:

**Casos base**:

1. $\emptyset$ é uma expressão regular que denota a linguagem vazia;
2. $\epsilon$ é uma expressão regular que denota a linguagem $\{\epsilon\}$;
3. Para cada $a \in \Sigma$, $a$ é uma expressão regular que denota a linguagem $\{a\}$.

**Casos indutivos**: Se $r$ e $s$ são expressões regulares, então:

1. $(r \cup s)$ é uma expressão regular (**união**);
2. $(r \cdot s)$ ou simplesmente $(rs)$ é uma expressão regular (**concatenação**);
3. $(r^*)$ é uma expressão regular (**fechamento de Kleene**).

### Precedência dos Operadores

De forma análoga à precedência de operadores na aritmética, onde a multiplicação (como em $5 \cdot 2$) é executada antes da adição (como em $3 + 5$), as operações em expressões regulares também seguem uma hierarquia de prioridade. Esta convenção é adotada para simplificar a escrita e reduzir o uso excessivo de parênteses, tornando as expressões mais limpas e legíveis. A ordem de precedência, da maior para a menor, é a seguinte:

1. **Fechamento de Kleene** ($*$) - maior precedência
2. **Concatenação** ($\cdot$) - precedência média
3. **União** ($\cup$) - menor precedência

Tomemos como exemplo a expressão $ab^* \cup c$. Para interpretá-la, aplicamos a hierarquia de precedência em etapas:

1. Primeiro, o operador de maior prioridade, o **Fechamento de Kleene** ($*$), é aplicado ao seu argumento imediato à esquerda, $b$, resultando em `(b*)`.
2. Em seguida, a **concatenação** (que tem precedência sobre a união) liga o `a` ao resultado anterior, formando `(a(b*))`.
3. Por fim, o operador de menor prioridade, a **união** ($\cup$), combina os termos adjacentes, levando à interpretação final e inequívoca: $((a(b^*)) \cup c)$.

### Linguagem Denotada por uma Expressão Regular

Até agora, definimos uma expressão regular $r$ como uma sequência de símbolos, ou seja, uma construção puramente **sintática**. Agora, precisamos lhe atribuir um **significado (semântica)**, definindo precisamente qual linguagem ela descreve. Para isso, introduzimos a notação $L(r)$ para representar a linguagem denotada por $r$. A definição de $L(r)$ é indutiva, espelhando perfeitamente a estrutura usada para definir a sintaxe de uma expressão regular:

**Casos base**:

- $L(\emptyset) = \emptyset$
- $L(\epsilon) = \{\epsilon\}$
- $L(a) = \{a\}$ para $a \in \Sigma$

**Casos indutivos**:

- $L(r \cup s) = L(r) \cup L(s)$
- $L(rs) = L(r) \cdot L(s)$
- $L(r^*) = (L(r))^*$

Este processo de definição nos permite _computar_ a linguagem de qualquer expressão. Por exemplo, para decodificar $r = (a \cup b)c$, aplicamos as regras indutivamente: partindo dos casos base $L(a)=\{a\}$, $L(b)=\{b\}$ e $L(c)=\{c\}$, usamos a regra da união para obter $L(a \cup b) = \{a, b\}$. Por fim, a regra da concatenação nos dá o resultado final: $L(r) = L(a \cup b) \cdot L(c) = \{a, b\} \cdot \{c\} = \{ac, bc\}$.

#### Exercícios 4 {#sec-ex-regex}

1. Determine a linguagem denotada pelas seguintes expressões regulares:
   a. $r_1 = a \cup b$;
   b. $r_2 = (a \cup b)(a \cup b)$;
   c. $r_3 = a^*b$;
   d. $r_4 = (ab)^*$.

2. Reescreva as seguintes expressões com parênteses explícitos, respeitando a precedência:
   a. $ab^* \cup c$;
   b. $a \cup bc^*$;
   c. $ab \cup cd^*e$;
   d. $a^*b^* \cup c^*$.

3. Para cada expressão regular, determine se as _strings_ dadas pertencem à linguagem:
   a. $r = a^*ba^*$: _strings_ $\{ab, ba, aba, baa, bb\}$;
   b. $r = (a \cup b)^*b$: _strings_ $\{b, ab, ba, abb, bbb\}$.

4. Use a definição indutiva de $L(r)$ para calcular $L((a \cup b)c)$:
   a. Identifique os casos base aplicáveis;
   b. Aplique as regras indutivas passo a passo;
   c. Apresente o resultado final.

5. Construa expressões regulares que denotem as seguintes linguagens:
   a. $L_1 = \{a, b, aa, bb\}$;
   b. $L_2 = \{\epsilon, a, aa, aaa\}$;
   c. $L_3 = \{w \in \{a,b\}^* \mid w \text{ termina com } a\}$.

### Exemplos de Expressões Regulares

Com os fundamentos teóricos e a semântica de $L(r)$ estabelecidos, a melhor maneira de permitir que a esforçada leitora crie uma intuição sobre o poder expressivo das expressões regulares é por meio da análise de exemplos práticos. Os casos a seguir ilustram como padrões textuais concisos podem descrever com precisão linguagens complexas e, frequentemente, infinitas. Cada exemplo serve para solidificar a conexão entre a notação abstrata e os conjuntos de _strings_ concretos que ela representa.

1. **Exemplo 1**: _strings_ binárias terminando em $01$
   $$r_1 = (0 \cup 1)^*01$$
   $$L(r_1) = \{01, 001, 101, 0001, 0101, 1001, 1101, \ldots\}$$

   **Análise**: Esta expressão é dividida em duas partes. A primeira, `$(0 \cup 1)^*$`, gera qualquer sequência possível de '0's e '1's de qualquer comprimento, incluindo a _string_ vazia $\epsilon$. A segunda parte, `01`, é uma _string_ literal. Ao concatenar as duas, forçamos que qualquer _string_ gerada pela primeira parte seja seguida por `01`, garantindo assim a terminação desejada.

   **$L(r_1)$ contém**: $\{01, 101, 001, 11101, \ldots\}$.
   **$L(r_1)$ não contém**: $\{\epsilon, 0, 1, 10, 010, \ldots\}$.

2. **Exemplo 2**: _strings_ sobre $\{a, b\}$ com número par de $a$'s
   $$r_2 = b^*(ab^*ab^*)^*$$

   **Análise**: esta é uma construção elegante. A parte central é `$(ab^*ab^*)$`. Observe que dentro dos parênteses existem exatamente dois $a$'s. Os $b^*$'s permitem que qualquer número de $b$'s apareçam antes, entre e depois desses $a$'s. O Fechamento de Kleene externo, `$(...)^*`, permite que este bloco contendo dois $a$'s se repita zero ou mais vezes. Se o bloco se repete $k$ vezes, o número total de $a$'s será $2k$, que é sempre um número par (0, 2, 4, ...). O $b^*$ no início permite que a _string_ comece com $b$'s ou, caso o bloco não se repita nenhuma vez, gere _strings_ compostas apenas por $b$'s (que possuem zero $a$'s, e zero é par).

   **$L(r_2)$ contém**: $\{b, bb, abab, aab, baab, bbaabb, \ldots\}$.
   **$L(r_2)$ não contém**: $\{a, bbbab, aaabb, \ldots\}$.

3. **Exemplo 3**: Identificadores que começam com letra
   $$r_3 = (a \cup b \cup \ldots \cup z)(a \cup b \cup \ldots \cup z \cup 0 \cup 1 \cup \ldots \cup 9)^*$$

   **Análise**: Esta expressão regular define uma regra clássica para identificadores (nomes de variáveis, funções, etc.) em muitas linguagens de programação. Ela é composta por duas partes concatenadas que impõem uma estrutura rígida:

   - A primeira parte, `$(a \cup b \cup \ldots \cup z)$`, estabelece a condição para o caractere inicial. Ela exige que a _string_ comece com exatamente uma letra minúscula.
   - A segunda parte, `$(a \cup b \cup \ldots \cup z \cup 0 \cup 1 \cup \ldots \cup 9)^*$`, define os caracteres subsequentes. O Fechamento de Kleene (`$*$`) permite que o caractere inicial seja seguido por uma sequência de zero ou mais caracteres, que podem ser letras minúsculas ou dígitos.

   **$L(r_3)$ contém**: `{x, nome, var1, contador, a1b2c3, ...}`.
   **$L(r_3)$ não contém**: `{1var, _nome, temp-1, $var, ...}`.

4. **Exemplo 4**: Números inteiros com sinal opcional
   $$r_4 = (\epsilon \cup + \cup -)(0 \cup 1 \cup \ldots \cup 9)(0 \cup 1 \cup \ldots \cup 9)^*$$

   **Análise**: Esta expressão é construída em três partes lógicas para capturar a estrutura de um número inteiro:

   1. `$(\epsilon \cup + \cup -)$`: A primeira parte define o prefixo do número. A união com a _string_ vazia (`$\epsilon$`) torna o caractere de sinal (`+` ou `-`) opcional. Isso permite que o número comece diretamente com um dígito.
   2. `$(0 \cup 1 \cup \ldots \cup 9)$`: Esta parte garante que, após o sinal (ou a ausência dele), exista **pelo menos um** dígito. Isso é fundamental para invalidar _strings_ que contenham apenas um sinal, como `+` ou `-`.
   3. `$(0 \cup 1 \cup \ldots \cup 9)^*`: O Fechamento de Kleene na parte final permite que este primeiro dígito seja seguido por uma sequência de zero ou mais dígitos adicionais, formando números de qualquer comprimento.

   **$L(r_4)$ contém**: `{42, -199, +7, 0, 9, 007, ...}`.
   **$L(r_4)$ não contém**: `{\epsilon, +, -, --5, 1+1, 9A, ...}`.

   **Nota sobre a limitação**: é importante que a atenta leitora note que esta expressão regular, embora funcional, aceita números com zeros à esquerda (como `007`), o que pode não ser desejável em todos os contextos de programação ou validação. Expressões mais complexas podem ser criadas para proibir essa característica, por exemplo, tratando o `0` como um caso especial separado de números que começam com `$[1-9]$`.

Esses exemplos demonstram a notável versatilidade das expressões regulares. Com apenas três operações fundamentais — união, concatenação e Fechamento de Kleene — somos capazes de descrever uma vasta gama de padrões, desde sequências simples e finitas até conjuntos infinitos com regras estruturais complexas. Fica evidente como essa ferramenta se torna indispensável na análise léxica, validação de dados e em inúmeras outras tarefas da computação. Contudo, apesar de seu poder, veremos adiante que existem linguagens, até mesmo algumas com descrições aparentemente simples, que transcendem a capacidade expressiva das expressões regulares.

#### Exercícios 5 {#sec-ex-regex2}

1. Baseando-se no exemplo de _strings_ terminando em $01$:
   a. Construa uma expressão para _strings_ terminando em $10$;
   b. Construa uma expressão para _strings_ começando com $01$;
   c. Construa uma expressão para _strings_ que contêm $01$ como substring;
   d. Construa uma expressão para _strings_ que **não** contêm $01$.

2. Inspirando-se no exemplo de número par de $a$'s:
   a. Construa uma expressão para _strings_ com número ímpar de $a$'s sobre $\{a,b\}$;
   b. Construa uma expressão para _strings_ com número múltiplo de 3 de $a$'s;
   c. Construa uma expressão para _strings_ com pelo menos dois $a$'s.

3. Baseando-se no padrão de identificadores:
   a. Modifique para permitir underscores em qualquer posição;
   b. Modifique para proibir dígitos na primeira e última posições;
   c. Crie um padrão para identificadores que devem ter entre 3 e 8 caracteres.

4. Estendendo o exemplo de números inteiros:
   a. Construa uma expressão para números decimais (com ponto decimal);
   b. Construa uma expressão para números em notação científica simples ($1e5$, $2e-3$);
   c. Construa uma expressão para números hexadecimais com prefixo $0x$.

5. Para as expressões construídas nos exercícios anteriores:
   a. Verifique se as _strings_ $\{101, 1010, 0101\}$ pertencem ao padrão _termina em 10_;
   b. Verifique se $\{aab, baba, ababa\}$ têm número ímpar de $a$'s;
   c. Teste se $\{var_1, _temp, item2_\}$ são identificadores válidos com underscores.

### Equivalência de Expressões Regulares e suas Leis Algébricas

Ao explorarmos o poder das expressões regulares, a atenta leitora descobrirá que diferentes expressões podem, na verdade, descrever exatamente a mesma linguagem. De forma análoga à álgebra tradicional, onde $x(y+z)$ e $xy + xz$ são formulações distintas para o mesmo resultado, na teoria das linguagens podemos ter duas expressões sintaticamente diferentes que são semanticamente idênticas. Essa noção de equivalência não é apenas uma curiosidade teórica; ela é fundamental para a otimização e simplificação de padrões, permitindo-nos encontrar a representação mais concisa ou computacionalmente mais eficiente para uma dada linguagem.

A perspicaz leitora perceberá que a capacidade de manipular expressões e transformá-las em formas equivalentes, porém mais simples, é uma habilidade poderosa, especialmente na construção de analisadores léxicos e ferramentas de processamento de texto.

Formalmente, duas expressões regulares $r$ e $s$ são ditas **equivalentes**, o que denotamos por $r \equiv s$, se, e somente se, elas denotam a mesma linguagem. Matematicamente, isso é expresso como:

$$r \equiv s \iff L(r) = L(s)$$

Para manipular e simplificar expressões regulares, contamos com um conjunto de leis algébricas que governam as operações de união, concatenação e fechamento de Kleene. Estas leis são a base para a otimização de padrões.

#### Principais Leis Algébricas

A seguir, apresentamos as identidades mais importantes que as expressões regulares satisfazem. Para expressões regulares $r$, $s$ e $t$:

##### Leis Associativas e Comutativas

Estas leis nos permitem reagrupar e reordenar os termos em operações de união e concatenação.

1. **Comutatividade da União**: a ordem na união não importa.
    $$r \cup s \equiv s \cup r$$

2. **Associatividade da União**: podemos agrupar uniões de qualquer forma.
    $$(r \cup s) \cup t \equiv r \cup (s \cup t)$$

3. **Associatividade da Concatenação**: o agrupamento na concatenação também é flexível. Lembre-se, no entanto, que a concatenação _não é_ comutativa ($rs \not\equiv sr$ em geral).
    $$(rs)t \equiv r(st)$$

##### Leis de Identidade e Anulação

Estas leis definem o papel dos elementos especiais $\epsilon$ (a _string_ vazia) e $\emptyset$ (a linguagem vazia).

1. **Elemento Neutro da Concatenação**: A _string_ vazia é o elemento neutro da concatenação.
    $$r\epsilon \equiv \epsilon r \equiv r$$

2. **Elemento Anulador da Concatenação**: Concatenar com a linguagem vazia resulta na linguagem vazia.
    $$r\emptyset \equiv \emptyset r \equiv \emptyset$$

3. **Elemento Neutro da União**: A linguagem vazia é o elemento neutro da união.
    $$r \cup \emptyset \equiv \emptyset \cup r \equiv r$$

##### Lei Distributiva

Esta lei conecta as operações de concatenação e união, de forma muito semelhante à álgebra numérica.

1. **Distributividade da Concatenação sobre a União**:
    $$r(s \cup t) \equiv rs \cup rt$$ $$(s \cup t)r \equiv sr \cup tr$$

##### Lei da Idempotência

Esta lei estabelece que a união de uma expressão com ela mesma não adiciona nada novo.

1. **Idempotência da União**:
    $$r \cup r \equiv r$$

##### Leis do Fechamento de Kleene

Estas propriedades definem a natureza do operador de fechamento.

1. **Definição Recursiva**: o fechamento de $r$ é a _string_ vazia ou um $r$ seguido por mais _r's_.
    $$r^* \equiv \epsilon \cup rr^*$$

2.**Fechamento do Fechamento**: aplicar o fechamento duas vezes é redundante.

    $$(r^*)^* \equiv r^*$$

3. **Fechamento da Linguagem Vazia**: A única _string_ que pode ser formada por zero ou mais escolhas da linguagem vazia é a _string_ vazia.

   $$\emptyset^* \equiv \epsilon$$

4. **Fechamento da _string_ Vazia**: o mesmo se aplica à linguagem contendo apenas a _string_ vazia.

    $$\epsilon^* \equiv \epsilon$$

#### Exemplo Prático de Simplificação

Para que a atenta leitora possa ver a utilidade dessas leis em ação, vamos simplificar a expressão regular $r = a(b \cup c) \cup ab$. Nosso objetivo é encontrar uma expressão equivalente que seja mais curta.

1. **Expressão Inicial**: $r = a(b \cup c) \cup ab$
2. **Aplicar a Distributividade**: usamos a lei distributiva à esquerda no termo $a(b \cup c)$.

    $$r \equiv (ab \cup ac) \cup ab$$

3. **Aplicar a Comutatividade**: reordenamos os termos da união para agrupar os termos idênticos.

    $$r \equiv ab \cup ab \cup ac$$

4. **Aplicar a Idempotência**: a união de $ab$ com $ab$ é simplesmente $ab$.

    $$r \equiv ab \cup ac$$

5. **Chegamos à expressão**: $s = ab \cup ac$. Como $L(r) = L(s)$.

As expressões são equivalentes ($a(b \cup c) \cup ab \equiv ab \cup ac$), mas a segunda é visivelmente mais simples. Essa capacidade de simplificação tem valor prático no projeto de compiladores e em sistemas de busca de texto.

#### Exercícios 6 {#sec-ex-regex3}

1. Use as leis algébricas para simplificar:
   a. $(a \cup \emptyset)b$;
   b. $a(\epsilon \cup b)$;
   c. $(a \cup a)^*$;
   d. $a \cup ab^*a$.

2. Simplifique a expressão $((a \cup b)a) \cup (aa)$ usando as leis passo a passo:
   a. Identifique que leis podem ser aplicadas;
   b. Mostre cada passo da simplificação;
   c. Verifique o resultado testando _strings_ específicas.

3. Prove que as seguintes expressões são equivalentes:
   a. $a^*a$ e $aa^*$;
   b. $(a \cup b)^*$ e $\epsilon \cup (a \cup b)(a \cup b)^*$;
   c. $a^*b^*$ e $(a \cup b)^*$ (esta é falsa - encontre um contraexemplo).

4. Simplifique usando as leis do fechamento:
   a. $(a^*)^*$;
   b. $\epsilon^* \cup a^*$;
   c. $\emptyset^* \cup a$;
   d. $(a \cup \epsilon)^*$.

5. Para a expressão $ab^* \cup abb^* \cup abbb^*$:
   a. Identifique o padrão comum;
   b. Use a distributividade para fatorar;
   c. Simplifique usando propriedades do fechamento de Kleene;
   d. Verifique que as linguagens são idênticas.

### Notações Convencionais Adicionais

Embora as três operações fundamentais, união ($\cup$), concatenação ($\cdot$) e fechamento de Kleene ($*$), sejam teoricamente suficientes para descrever qualquer Linguagem Regular, na prática, elas podem gerar expressões longas, repetitivas e de difícil leitura. Para contornar essa complexidade, foram introduzidas diversas notações adicionais que funcionam como abreviações ou _macros_.

A criativa leitora pode enxergar estas notações como _funções_ ou _módulos_ predefinidos: elas não adicionam um novo poder teórico ao formalismo, mas aumentam a expressividade e a conveniência da escrita, permitindo construir padrões complexos de forma mais limpa e intuitiva. Dominar estas abreviações é um passo importante para escrever expressões regulares eficazes no mundo real.

A seguir, detalhamos as notações mais comuns.

1. **Fechamento Positivo ($r^+$)**

   - **Definição**: É uma abreviação para _uma ou mais_ ocorrências de $r$. Formalmente, $r^+ \equiv rr^*$.
   - **Análise**: Enquanto $r^*$ corresponde a zero ou mais repetições, $r^+$ exige que o padrão ocorra pelo menos uma vez. É uma das abreviações mais utilizadas.

**Exemplo**: Para descrever números inteiros positivos, podemos usar a expressão $[1-9][0-9]^*$. Usando o fechamento positivo, a expressão para um ou mais dígitos, $[0-9]^+$, pode ser mais intuitiva em certos contextos, embora a primeira seja mais precisa para evitar zeros à esquerda. Um exemplo mais direto é $a^+$, que denota a linguagem $\{a, aa, aaa, \ldots\}$, sendo mais concisa que $aa^*$.

1. **Opcionalidade ($r?$)**

   **Definição**: Indica que a expressão $r$ é opcional, podendo aparecer uma ou nenhuma vez. É um atalho para $(\epsilon \cup r)$.
   **Análise**: Esta notação é perfeita para partes de um padrão que podem ou não estar presentes.

   **Exemplo**: Para validar URLs que podem ser `http` ou `https` (com 's' opcional), usamos a expressão `https?`. Ela corresponde a `http` ou `https`. Outro exemplo seria modelar um número com sinal opcional: $(+ \cup -)? [0-9]^+$.

2. **Classes de Caracteres ($[\ldots]$)**

   **Definição**: Funcionam como uma abreviação para uma união de múltiplos caracteres. Por exemplo, $[abc] \equiv (a \cup b \cup c)$.
   **Análise**: Tornam a expressão muito mais compacta quando precisamos permitir um de vários caracteres possíveis em uma determinada posição.

   **Exemplo**: Para encontrar qualquer vogal minúscula, em vez de escrever $(a \cup e \cup i \cup o \cup u)$, podemos simplesmente usar $[aeiou]$.

3. **Intervalos em Classes de Caracteres ($[a-z]$)**

   **Definição**: Dentro de uma classe de caracteres, o hífen `-` pode ser usado para denotar um intervalo de símbolos com base em uma ordem convencional (como a da tabela ASCII).
   **Análise**: Esta é uma generalização poderosa das classes de caracteres, evitando a necessidade de listar todos os símbolos individualmente.

   **Exemplo**: Para descrever uma letra minúscula qualquer, usamos $[a-z]$. Para um dígito hexadecimal, podemos combinar intervalos: $[0-9a-fA-F]$.

4. **Negação de Classes de Caracteres ($[^\ldots]$)**

   **Definição**: O acento circunflexo `^`, quando é o primeiro símbolo dentro de uma classe, nega o conjunto. A classe passa a corresponder a qualquer caractere do alfabeto $\Sigma$ *exceto* os que estão listados.
   **Análise**: É útil para especificar proibições, ou seja, tudo, exceto um pequeno conjunto de caracteres.

   **Exemplo**: Uma expressão para encontrar uma _string_ que não contenha vogais poderia usar $[^aeiou]$. Para encontrar um caractere que não é um dígito, usamos $[^0-9]$.

5. **Quantificadores de Repetição ($\{n, m\}$)**

   **Definição**: Oferecem um controle preciso sobre o número de repetições de uma expressão $r$.
   **Análise**: Generalizam as operações $?$, $*$ e $+$, permitindo especificar limites exatos, mínimos ou intervalos de ocorrências.
     - $r\{n\}$: $r$ repetido exatamente $n$ vezes.
     - $r\{n,m\}$: $r$ repetido no mínimo $n$ e no máximo $m$ vezes.
     - $r\{n,\}$: $r$ repetido pelo menos $n$ vezes.

   **Exemplos**:
   a. **CEP Brasileiro**: Um CEP no formato `XXXXX-XXX` pode ser descrito por $[0-9]\{5\}-[0-9]\{3\}$.
   b. **Validade de Senha**: Uma regra de senha que exige de $8$ a $16$ caracteres alfanuméricos pode ser modelada por $[a-zA-Z0-9]\{8,16\}$.
   c. **Identificador Mínimo**: Um nome de variável que precisa ter pelo menos $3$ caracteres, começando com uma letra e seguido por letras ou números, pode ser escrito como $[a-zA-Z][a-zA-Z0-9]\{2,\}$.

#### Exercícios 7 {#sec-ex-regex4}

1. Reescreva usando apenas união ($\cup$), concatenação e fechamento de Kleene ($*$):
   a. $a^+$;
   b. $b?$;
   c. $[abc]$;
   d. $a\{3\}$;
   e. $b\{2,4\}$.

2. Construa expressões usando classes de caracteres para:
   a. Qualquer dígito: $[0-9]$;
   b. Qualquer letra minúscula: $[a-z]$;
   c. Qualquer caractere que não seja espaço: $[^ ]$;
   d. Qualquer caractere alfanumérico: $[a-zA-Z0-9]$.

3. Use quantificadores para construir padrões para:
   a. CEP brasileiro no formato $99999-999$;
   b. Placa de carro brasileira antiga $AAA-9999$;
   c. Senha com exatamente 8 caracteres alfanuméricos;
   d. Código de área de telefone com 2 ou 3 dígitos.

4. Construa expressões regulares para validar:
   a. URL simples começando com $http$ ou $https$;
   b. Data no formato $dd/mm/aaaa$ (versão simples);
   c. Horário no formato $hh:mm$ (24 horas);
   d. Número de CPF no formato $999.999.999-99$.

5. Reescreva as seguintes expressões de forma mais concisa:
   a. $(a \cup b \cup c \cup d)(a \cup b \cup c \cup d)^*$;
   b. $a(\epsilon \cup b)$;
   c. $(0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)(0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)^*$;

### Aplicações Práticas

Após a jornada pelos fundamentos matemáticos, a curiosa leitora pode estar se perguntando: onde essa teoria se manifesta no dia a dia da computação? A resposta curta é: em praticamente todos os lugares. As expressões regulares representam um dos casos mais bem-sucedidos de uma teoria matemática que transcendeu a academia e se tornou uma ferramenta indispensável, utilizada diariamente por desenvolvedores de software, administradores de sistemas e cientistas de dados.

Para a resposta longa precisamos abandonar o formalismo puro para ilustrar como as expressões regulares, com suas notações concisas, resolvem problemas concretos.

#### Análise Léxica em Compiladores

A análise léxica é a primeira fase da compilação de um programa. O analisador, chamado de *scanner* ou _lexer_, lê o código-fonte como uma sequência de caracteres e a converte em uma sequência de _tokens_, unidades lexicais como identificadores, palavras-chave, números e operadores. Cada tipo de _token_ é definido precisamente por um padrão, que é, em sua essência, uma expressão regular.

**Exemplo 1: identificadores**: nomes de variáveis, funções, etc..

**Padrão**: `[a-zA-Z_][a-zA-Z0-9_]*`.
**Análise**: Este padrão decreta que um identificador deve começar com uma letra (maiúscula ou minúscula) ou um underscore (`[a-zA-Z_]`), seguido por zero ou mais caracteres que podem ser letras, números ou underscores (`[a-zA-Z0-9_]*`).

**Exemplo 2: números inteiros**:

**Padrão**: `-?[1-9][0-9]*|0`.
**Análise**: Este padrão elegante lida com vários casos. O `-?` torna o sinal de negativo opcional. O trecho `[1-9][0-9]*` garante que números com múltiplos dígitos não comecem com zero (como `042`). Por fim, o `|0` trata o número zero como um caso especial.

#### Validação de Dados de Entrada

Em qualquer aplicação que receba dados de um usuário, é vital garantir que esses dados estejam no formato correto antes de serem processados. As expressões regulares são a ferramenta padrão para essa tarefa de validação.

**Exemplo 1: endereço de e-mail (Muito Simplificado)**:

**Padrão**: `[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`
**Análise**: Embora um padrão de e-mail 100% compatível com as RFCs seja extremamente complexo, esta versão simplificada cobre a maioria dos casos. Ela busca: uma sequência de caracteres de usuário (`[...]+`), o símbolo `@`, uma sequência de caracteres de domínio (`[...]+`), um ponto literal (`\.`) e, por fim, o domínio de topo (TLD) com pelo menos duas letras (`[a-zA-Z]{2,}`).

#### Telefone (Formato Brasileiro)

**Padrão**: `\([0-9]{2}\) ?[0-9]{4,5}-[0-9]{4}`
**Análise**: Este padrão modela um número de telefone comum no Brasil, incluindo o DDD entre parênteses e um espaço opcional e pode ser dividido nas seguintes partes:
  
1. `\(` e `\)`: Correspondem aos parênteses literais. Como `(` e `)` são metacaracteres em expressões regulares, eles precisam ser _escapados_ com uma barra invertida para serem tratados como caracteres literais;
2. `[0-9]{2}`: Exige exatamente dois dígitos numéricos para o código de área (DDD);
3. ` ?`: Permite a existência opcional de um único caractere de espaço após os parênteses do DDD;
4. `[0-9]{4,5}`: Captura a primeira parte do número, que pode ter 4 ou 5 dígitos, acomodando tanto números fixos quanto números móveis que já adotaram o nono dígito;
5. `-[0-9]{4}`: Corresponde ao hífen literal e aos 4 dígitos finais do número.

#### Busca, Extração e Substituição de Texto

Esta é talvez a aplicação mais visível das expressões regulares, formando o coração de ferramentas como `grep` e `sed` em sistemas Unix, e as funcionalidades de _Localizar e Substituir_ em editores de texto e ambientes integrados de edição (IDEs).

**Exemplo 1: busca por Palavras Exatas**:

**Padrão**: `\b[Pp]alavra\b`
**Análise**: O `\b` é uma _âncora_ que corresponde a uma fronteira de palavra (*word boundary*). Isso garante que a busca encontre _palavra_ como uma palavra inteira, e não como parte de _subpalavra_. O `[Pp]` torna a busca insensível a maiúsculas para a primeira letra.

#### Hora (Formato 24h: HH:MM ou HH:MM:SS)

**Padrão**: `([01][0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?`
**Análise**: Este é um excelente exemplo de como expressões regulares podem validar formatos com regras numéricas. Ele valida horas no formato 24h, com segundos opcionais e pode ser dividido
em partes:

1. `([01][0-9]|2[0-3])`: Esta parte valida as horas. A união `|` cria duas possibilidades: ou um dígito de `0` ou `1` seguido por qualquer dígito (`00`-`19`), ou o dígito `2` seguido por um dígito de `0` a `3` (`20`-`23`).
2. `:`: Corresponde ao separador literal.
3. `[0-5][0-9]`: Valida os minutos, garantindo que estejam no intervalo de `00` a `59`.
4. `(:[0-5][0-9])?`: Esta parte torna os segundos opcionais. Os parênteses agrupam o separador `:` e os dígitos dos segundos. O quantificador `?` aplicado a este grupo faz com que toda a seção de segundos (`:SS`) possa aparecer uma ou nenhuma vez.

**$L(r)$ contém**: `{14:30, 09:15, 23:59:59, 00:00}`.
**$L(r)$ não contém**: `{25:00, 12:61, 9:30, 14:30:, 15:10:99}`.

Esses exemplos arranham apenas a superfície, mas demonstram a imensa versatilidade das expressões regulares. Elas formam uma ponte poderosa entre a teoria formal das linguagens e a resolução de problemas práticos e onipresentes no desenvolvimento de software.

### Exercícios 8 {#sec-ex-regex5}

1. Projete expressões regulares para tokens de uma linguagem de programação simples:
   a. Palavras-chave: $\{\text{if}, \text{then}, \text{else}, \text{while}, \text{do}\}$;
   b. Números inteiros (incluindo negativos);
   c. Comentários de linha iniciados por $//$; 
   d. Operadores relacionais: $\{<, >, <=, >=, ==, !=\}$.

2. Construa expressões regulares para validar:
   a. Telefone celular: $(11) 99999-9999$;
   b. RG: $99.999.999-9$;
   c. CNPJ: $99.999.999/9999-99$;
   d. CEP: $99999-999$ ou $99.999-999$.

3. Projete expressões para encontrar:
   a. Endereços de email em um texto;
   b. Valores monetários no formato $R\$ 99,99$;
   c. Datas em formatos variados: $dd/mm/aaaa$, $dd-mm-aaaa$, $dd.mm.aaaa$;
   d. Números de cartão de crédito (formato $9999-9999-9999-9999$).

4. Identifique e corrija os erros nas seguintes expressões:
   a. Para validar email: $[a-z]+@[a-z]+.[a-z]+$ (problema: ponto literal);
   b. Para números decimais: $[0-9]*.[0-9]*$ (problema: pontos opcionais);
   c. Para identificadores: $[a-zA-Z][a-zA-Z0-9]?$ (problema: comprimento mínimo).

5. Para cada expressão, proponha uma versão otimizada:
   a. $(abc|abd|abe)$ → $ab(c|d|e)$;
   b. $[0-9][0-9][0-9][0-9]$ → $[0-9]\{4\}$;
   c. $(a^*b^*|b^*a^*)$ → $(a|b)^*$ (verifique se são realmente equivalentes);
   d. Analise qual versão seria mais eficiente em uma implementação real.

## O Lugar das Linguagens Regulares: Poder e Limitações

Após testemunharmos a versatilidade das expressões regulares em aplicações práticas, uma questão natural emerge: será que elas são capazes de descrever *qualquer* padrão ou linguagem que possamos imaginar? A resposta, embora surpreendente para alguns, é não. As expressões regulares ocupam um lugar específico e bem definido no universo das linguagens formais.

Para compreender essa especificidade, recorremos à **Hierarquia de Chomsky**, um sistema de classificação proposto pelo linguista [Noam Chomsky](https://en.wikipedia.org/wiki/Noam_Chomsky) que organiza as linguagens formais em níveis de complexidade crescente. Neste framework, as expressões regulares definem o primeiro e mais fundamental degrau: a classe das **Linguagens Regulares**. 

A aventureira leitora depois de entender as expressões regulares pode explorar as propriedades que definem o poder desta classe de linguagens e, igualmente importante, as fronteiras que revelam suas limitações.

### A Essência do Poder: Simplicidade e Previsibilidade

O poder das Linguagens Regulares reside em sua simplicidade e previsibilidade. Esse poder é o resultado de um conjunto de propriedades matemáticas e uma correspondência fundamental com um tipo específico de máquina teórica: o Autômato Finito. Vamos explorar essas propriedades que definem o que torna as Linguagens Regulares tão úteis e amplamente aplicáveis.

A curiosa leitora deve saber que existe uma associação clássica entre as Linguagens Regulares e os Autômatos Finitos. De fato, a propriedade mais importante de uma Linguagem Regular é que ela pode ser reconhecida por um Autômato Finito. Um Autômato Finito, como vimos antes no Capítulo @sec-analisadores-lexicos, é uma máquina teórica com uma quantidade _finita_ de memória, representada por seus estados. A máquina lê uma _string_ de entrada, um símbolo por vez, e sem poder voltar atrás, decide se a _string_ pertence ou não à linguagem. A incapacidade de armazenar uma quantidade ilimitada de informações é a característica que define, limita e, ao mesmo tempo, determina o poder das Linguagens Regulares. Veremos Autômatos Finitos mais detalhadamente no Capítulo @sec-aut-finitos-deterministicos.

### Propriedades Fundamentais das Linguagens Regulares

A utilidade prática das linguagens regulares não se limita à sua capacidade de descrever padrões, mas também se baseia em um conjunto de garantias matemáticas. Duas propriedades centrais neste contexto são:

1. **Fechamento sob Operações**: a classe das Linguagens Regulares é fechada sob todas as operações que vimos: **união**, **concatenação**, **fechamento de Kleene**, e também sob **interseção** e **complemento**. Isso significa que se combinarmos Linguagens Regulares usando essas operações, o resultado será *sempre* outra Linguagem Regular. Essa propriedade é de grande valor prático, pois garante que podemos construir sistemas de reconhecimento complexos a partir de componentes simples com a certeza de que o todo permanecerá computacionalmente tratável.

2. **Decidibilidade**: Para as Linguagens Regulares, questões fundamentais são sempre _decidíveis_, ou seja, existe um algoritmo que pode respondê-las em um tempo finito. Podemos sempre construir um programa para determinar, por exemplo:
    a. Se uma _string_ $w$ pertence à linguagem $L(r)$;
    b. Se a linguagem $L(r)$ é vazia;
    c. Se duas expressões, $r$ e $s$, são equivalentes ($L(r) = L(s)$).

A previsibilidade e a eficiência dos algoritmos associados às Linguagens Regulares são características que as destacam em comparação com outras classes de linguagens mais complexas, como as Linguagens Livres de Contexto ou as Linguagens Sensíveis ao Contexto.

### As Fronteiras do Mundo Regular: O Limite da Memória

A principal limitação das Linguagens Regulares está diretamente ligada à memória finita dos autômatos. Tarefas que exigem _contar_ ou _lembrar_ uma quantidade arbitrária e ilimitada de informações estão além de seu alcance. Para reconhecer linguagens que envolvem contagem ou correspondência simétrica, a máquina precisaria de uma memória que pudesse crescer conforme o tamanho da entrada. Como um autômato finito tem um número fixo de estados, ele não consegue realizar essa tarefa.

**Exemplos Clássicos de Linguagens Não-Regulares**:

1. **$L = \{a^n b^n \mid n \geq 0\}$**: Para verificar se uma _string_ pertence a esta linguagem (por exemplo, `aaabbb`), uma máquina precisaria contar todos os $a$'s e depois garantir que o número de $b$'s é exatamente o mesmo. Como $n$ pode ser qualquer número, a contagem exige uma memória potencialmente infinita.

2. **Palíndromos ($L = \{w \mid w = w^R\}$)**: Para reconhecer um palíndromo como `abccba`, a máquina teria que memorizar a primeira metade da _string_ (`abc`) para compará-la com a segunda metade (`cba`). Novamente, o comprimento da _string_ é ilimitado, exigindo memória ilimitada.

3. **Parênteses Balanceados**: A linguagem das expressões com parênteses corretamente aninhados, como `((()))`, exige uma estrutura de _pilha_ para lembrar quantos parênteses foram abertos e ainda não foram fechados. Esta é uma forma de memória mais poderosa do que a disponível para um autômato finito.

### O Lema do Bombeamento: Uma Ferramenta de Prova

Para provar formalmente que uma linguagem *não* é regular, utilizamos uma ferramenta poderosa chamada **Lema do Bombeamento** (*Pumping Lemma*). Em vez de ser uma fórmula, é melhor compreendido como uma propriedade que toda Linguagem Regular deve satisfazer. Se conseguirmos mostrar que uma linguagem viola essa propriedade, então provamos que ela não pode ser regular.

A sua intuição é a seguinte:

Se uma linguagem $L$ é regular, então ela é aceita por um autômato finito com um número fixo de estados, digamos, $p$. Agora, considere uma _string_ $w$ em $L$ que seja suficientemente longa (especificamente, com comprimento $|w| \geq p$). Como a _string_ tem mais símbolos do que o autômato tem estados, o Princípio da Casa dos Pombos nos garante que o autômato **necessariamente revisitará** pelo menos um de seus estados enquanto lê a _string_. Isso significa que o caminho do autômato ao ler $w$ contém um **ciclo**. Podemos, então, dividir a _string_ $w$ em três partes, $w = xyz$:

- `$x$`: a parte da _string_ lida antes do ciclo começar;
- `$y$`: a parte da _string_ lida durante o ciclo. É uma condição fundamental do lema que esta parte **não pode ser vazia** ($|y| > 0$);
- `$z$`: o restante da _string_, lida após o ciclo.

O lema afirma que, como $y$ corresponde a um ciclo, essa porção pode ser _bombeada_: podemos percorrê-la zero vezes (removendo $y$), uma vez (a _string_ original), ou múltiplas vezes. Todas as _strings_ resultantes, da forma $xy^iz$ para qualquer $i \geq 0$, ainda devem ser aceitas pela máquina e, portanto, devem pertencer à linguagem $L$.

Para provar que uma linguagem não é regular, usamos esta propriedade para criar uma contradição: encontramos pelo menos uma _string_ longa na linguagem onde o _bombeamento_ de sua parte cíclica a _quebra_, gerando uma _string_ que **não** pertence à linguagem. Se isso for possível, a linguagem viola o lema e, portanto, não é regular.

### Exemplo do Lema do Bombeamento

Vamos usar o Lema do Bombeamento para provar formalmente que a linguagem $L = \{a^n b^n \mid n \geq 0\}$, uma sequência de $a$'s seguida pelo mesmo número de $b$'s, não é regular. A prova segue um roteiro de contradição cujo passo a passo a atenta leitora pode ver a seguir:

1. **Assunção Inicial (para Contradição)**: assumimos que $L$ **é** uma linguagem regular.
2. **Aplicação do Lema**: se $L$ é regular, então o Lema do Bombeamento deve se aplicar. Isso significa que existe uma constante, o _comprimento de bombeamento_ $p$, para a linguagem $L$.
3. **Escolha da String**: escolhemos uma _string_ $w$ que pertence a $L$ e que seja longa o suficiente, ou seja, $|w| \geq p$. A escolha mais estratégica é $w = a^p b^p$. Esta _string_ claramente pertence a $L$ (pois o número de $a$'s é igual ao de $b$'s) e seu comprimento é $2p$, que é maior ou igual a $p$.
4. **Divisão da String**: de acordo com o lema, $w$ pode ser dividida em três partes, $w=xyz$, que devem satisfazer as seguintes condições:
    a. $|y| > 0$;
    b. $|xy| \leq p$;
    c. $xy^iz \in L$ para todo $i \geq 0$.
5. **Análise da Parte Bombeável ($y$)**: a condição $|xy| \leq p$ é a chave. Como nossa _string_ é $w = \underbrace{a a \ldots a}_{p \text{ vezes}} \underbrace{b b \ldots b}_{p \text{ vezes}}$, a parte $xy$ (com no máximo $p$ caracteres) deve estar inteiramente contida no bloco inicial de $a$'s. Além disso, como $|y| > 0$, a _string_ $y$ deve conter pelo menos um $a$. Portanto, $y$ é da forma $y=a^k$ para algum $k$ onde $1 \leq k \leq p$.
6. **O Bombeamento (A Contradição)**: o lema afirma que qualquer _string_ bombeada $xy^iz$ também deve pertencer a $L$. Vamos testar para $i=2$:
   a. A nova _string_ é $w' = xy^2z$.
   b. Como $x$, $y$ e $z$ juntos formavam $a^p b^p$, e $y$ era $a^k$, a nova _string_ $w'$ terá $k$ $a$'s a mais que a original.
   c. Portanto, $w' = a^{p+k} b^p$.
   d. Como sabemos que $k \geq 1$, o número de $a$'s ($p+k$) não é mais igual ao número de $b$'s ($p$). Logo, a _string_ $w' = a^{p+k} b^p$ **não pertence** a $L$.
7. **Conclusão**: chegamos a uma contradição. Nossa suposição inicial de que $L$ era regular nos levou, através do Lema do Bombeamento, à conclusão de que uma _string_ gerada pelo bombeamento ($w'$) deveria estar em $L$, mas mostramos que ela viola a definição de $L$. Portanto, a suposição inicial estava errada. A linguagem $L = \{a^n b^n \mid n \geq 0\}$ não é regular.

#### Por que o Lema do Bombeamento é Importante?

O Lema do Bombeamento é uma ferramenta diagnóstica fundamental na teoria da computação. Sua importância não está em descrever o que as linguagens regulares _são_, mas sim em fornecer um método rigoroso para provar o que elas *não são*. [cite_start]Ele formaliza a noção de que autômatos finitos possuem _memória finita_. A existência de um ciclo bombeável é a consequência direta dessa memória finita; qualquer tarefa que exija contagem ou memória ilimitada, como garantir que o número de $a$'s é igual ao de $b$'s, irá _quebrar_ sob o bombeamento. Na prática, isso permite aos cientistas da computação e engenheiros de software classificar problemas, entendendo quando uma ferramenta simples (como uma expressão regular) é insuficiente e quando uma abordagem mais poderosa (como um analisador sintático para gramáticas livres de contexto) é necessária.

## Exercícios Desafiadores

### Exercício 1:

Seja $\Sigma = \{a, b, c\}$ e considere a linguagem $L = \{w \in \Sigma^* \mid |w|_a + 2|w|_b = |w|_c\}$, onde $|w|_x$ denota o número de ocorrências do símbolo $x$ na _string_ $w$.

a) Determine se $L$ é uma linguagem regular. Justifique sua resposta.
b) Se $L$ não for regular, use o Lema do Bombeamento para prová-lo formalmente.
c) Construa uma expressão regular para a linguagem $L' = \{w \in \{a,b\}^* \mid |w|_a \leq 3\}$.

**Solução**:

1. A linguagem $L$ **não é regular**. A condição $|w|_a + 2|w|_b = |w|_c$ estabelece uma relação aritmética que requer contagem precisa dos símbolos, algo que excede a capacidade de memória finita dos autômatos finitos.

2. **Prova usando o Lema do Bombeamento**:

Assumimos por contradição que $L$ é regular. Então existe uma constante $p$ tal que qualquer _string_ $w \in L$ com $|w| \geq p$ pode ser dividida como $w = xyz$ satisfazendo:
a. $|y| > 0$;
b. $|xy| \leq p$;
c. $xy^iz \in L$ para todo $i \geq 0$.

Escolhemos $w = a^p c^p \in L$ (pois $p + 2 \cdot 0 = p$). Como $|xy| \leq p$ e $w$ começa com $p$ símbolos $a$, temos que $y = a^k$ para algum $1 \leq k \leq p$.

Para $i = 2$: $w' = xy^2z = a^{p+k}c^p$

Na _string_ $w'$: $|w'|_a = p + k$, $|w'|_b = 0$, $|w'|_c = p$

A condição requer: $(p + k) + 2 \cdot 0 = p$, ou seja, $p + k = p$, logo $k = 0$.

Mas isso contradiz $|y| > 0$, que implica $k \geq 1$.

Portanto, $L$ não é regular.

3. Para $L' = \{w \in \{a,b\}^* \mid |w|_a \leq 3\}$:

$$L' = b^* \cup b^*ab^* \cup b^*ab^*ab^* \cup b^*ab^*ab^*ab^*$$

Forma mais concisa: $L' = b^*(\epsilon \cup ab^* \cup ab^*ab^* \cup ab^*ab^*ab^*)$

## Exercício 2: 

Considere as expressões regulares sobre $\Sigma = \{0, 1\}$:

- $r_1 = (01)^*0(10)^*$
- $r_2 = 0(10)^* \cup (01)^*0$

a) Determine se $r_1 \equiv r_2$ construindo _strings_ específicas que testem a equivalência.
b) Construa uma expressão regular equivalente mais simples.
c) Determine $|L(r_1) \cap \{w \in \{0,1\}^* \mid |w| = 5\}|$.

**Solução Letra a**:

1. **Teste de equivalência por exemplos**:

   $L(r_1) = L((01)^*0(10)^*)$ gera _strings_ que:
   a. Começam com zero ou mais pares $01$;
   b. Têm um $0$ central obrigatório;
   c. Terminam com zero ou mais pares $10$.

   $L(r_2) = L(0(10)^* \cup (01)^*0)$ gera _strings_ que:
   a. Ou começam com $0$ seguido de pares $10$;
   b. Ou começam com pares $01$ e terminam com $0$.

2. **Teste com _strings_ específicas**:
   a. _string_ $010$: Em $r_1$: $(01)^1 \cdot 0 \cdot (10)^0 = 010$. Ok!
   b. _string_ $010$: Em $r_2$: $(01)^1 \cdot 0 = 010$. Ok!
   c. _string_ $0$: Em ambas. Ok!
   d. _string_ $01010$: Em $r_1$: $(01)^1 \cdot 0 \cdot (10)^1 = 01010$. Ok!
   e. _string_ $01010$: Em $r_2$: $(01)^2 \cdot 0 = 01010$. Ok!

3. **Por análise estrutural**, $r_1 \equiv r_2$.

**Solução Letra b**:

A expressão $r_2 = 0(10)^* \cup (01)^*0$ é, de fato, a forma simplificada de $r_1$. A afirmação pode ser mais detalhada da seguinte forma:

1. **Simplificação Estrutural**:
    a. A expressão original, $r_1 = (01)^*0(10)^*$, descreve a linguagem através de uma concatenação de três partes. Isso exige que qualquer _string_ da linguagem seja mentalmente dividida em um prefixo de $(01)^*$, um $0$ central e um sufixo de $(10)^*$.
    b. A expressão $r_2$, já comprovada como equivalente na letra (a), descreve a mesma linguagem como a união de dois padrões mais diretos. Essa forma é frequentemente considerada mais simples, pois representa a linguagem como _strings que pertencem ao padrão A **OU** ao padrão B_, o que pode ser mais fácil de analisar e implementar.

2. **Análise de Minimalidade**:
    a. A expressão $r_2$ é considerada minimal na prática. A linguagem consiste em _strings_ que começam e terminam com $0$ e têm $0$s e $1$s alternados no interior. Existem duas maneiras naturais de gerar tais strings:
        - Começando com um $0$ e adicionando pares de $10$ à direita (padrão $0(10)^*$).
        - Terminando com um $0$ e adicionando pares de $01$ à esquerda (padrão $(01)^*0$).
    b. A união em $r_2$ captura perfeitamente essas duas perspectivas geradoras. Tentar unir os dois padrões em uma única expressão sem o operador de união ($\cup$) muito provavelmente resultaria em uma expressão mais longa, complexa e menos intuitiva.

3. **Conclusão**:pPortanto, embora a prova formal de minimalidade de uma expressão regular seja um problema complexo (geralmente envolvendo autômatos finitos), a expressão $r_2 = 0(10)^* \cup (01)^*0$ é a representação equivalente mais simples e canônica de $r_1$.

**Solução Letra c**:

Contagem para $|w| = 5$:

Strings de $L(r_1)$ têm comprimento ímpar (todas começam e terminam com $0$, com pares no meio).

Para comprimento 5:
a. Caso $0(10)^*$: $0$ seguido de $(10)^k$ onde $1 + 2k = 5$, logo $k = 2$: $01010$. Ok!
b. Caso $(01)^*0$: $(01)^k$ seguido de $0$ onde $2k + 1 = 5$, logo $k = 2$: $01010$. Ok!

Portanto: $|L(r_1) \cap \{w \in \{0,1\}^* \mid |w| = 5\}| = 1$

## Exercício 3: 

Seja $\Sigma$ o alfabeto contendo dígitos de 0 a 9 e os símbolos '(', ')', '-', e o espaço ' '. Defina as seguintes expressões para conjuntos de dígitos:
1. $D = (0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)$;
2. $D_{nz} = (1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)$;
3. $D_{fixo} = (2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8)$.

Com base nessas definições, considere a linguagem $L_{tel}$ de números de telefone brasileiros.

a) Construa expressões regulares separadas para os componentes da linguagem: o DDD e o Número do telefone.
b) Combine as expressões da letra (a) para construir a expressão regular final para a linguagem $L_{tel}$ completa.
c) Demonstre que a _string_ $(11) 99999-9999$ pertence a $L_{tel}$ mostrando sua derivação a partir da expressão final.

**Solução Letra a**:

1. **Componente DDD ($r_{ddd}$)**:
   a. O DDD consiste em dois dígitos, o primeiro não podendo ser zero. A base é $D_{nz}D$;
   b. Ele pode ter dois formatos: com parênteses ou sem, ambos seguidos por um espaço opcional;
   c. Expressão para o formato com parênteses: $\( D_{nz} D \) (\epsilon \cup \text{ })$;
   d. Expressão para o formato sem parênteses: $D_{nz} D (\epsilon \cup \text{ })$;
   e. A expressão completa para o DDD é a união dos dois formatos:
   
   $$r_{ddd} = (\( D_{nz} D \) (\epsilon \cup \text{ })) \cup (D_{nz} D (\epsilon \cup \text{ }))$$

2. **Componente Número ($r_{num}$)**:
   a. O número pode ser de celular (9 dígitos começando com 9) ou fixo (8 dígitos começando com 2-8). Ambos podem ter um hífen opcional;
   b. Expressão para celular: $9 D^4 (\epsilon \cup -) D^4$;
   c. Expressão para fixo: $D_{fixo} D^3 (\epsilon \cup -) D^4$;
   d. A expressão completa para o número é a união dos dois tipos.
   
   $$r_{num} = (9 D^4 (\epsilon \cup -) D^4) \cup (D_{fixo} D^3 (\epsilon \cup -) D^4)$$

**Solução Letra b**:

A expressão regular final $r_{tel}$ é a concatenação do componente DDD com o componente Número.

1. **Expressão Final**:
   $$r_{tel} = r_{ddd} \cdot r_{num}$$

2. **Substituindo as definições da letra (a)**:

   $$r_{tel} = [(\( D_{nz} D \) (\epsilon \cup \text{ })) \cup (D_{nz} D (\epsilon \cup \text{ }))] \cdot [(9 D^4 (\epsilon \cup -) D^4) \cup (D_{fixo} D^3 (\epsilon \cup -) D^4)]$$

**Solução Letra c**:

Vamos demonstrar que a _string_ $w = (11) 99999-9999$ pertence a $L(r_{tel})$.

1. **Divisão da String**:
   Podemos dividir $w$ em duas partes, $w_{ddd}$ e $w_{num}$, onde:
   - $w_{ddd} = (11)\text{ }$ (inclui o espaço);
   - $w_{num} = 99999-9999$;

2. **Verificação do Componente DDD**:
   A substring $w_{ddd}$ deve pertencer a $L(r_{ddd})$. Ela corresponde ao primeiro termo da união em $r_{ddd}$:
   - $\( D_{nz} D \) (\epsilon \cup \text{ })$;
   - $\($ corresponde ao símbolo literal $($;
   - $1$ pertence a $L(D_{nz})$ pois $1 \in \{1,2,3,4,5,6,7,8,9\}$;
   - $1$ pertence a $L(D)$ pois $1 \in \{0,1,2,3,4,5,6,7,8,9\}$;
   - $\)$ corresponde ao símbolo literal $)$;
   - O espaço pertence a $L(\epsilon \cup \text{ })$;
   - Portanto, $w_{ddd} \in L(r_{ddd})$. Ok!

3. **Verificação do Componente Número**:
   A substring $w_{num}$ deve pertencer a $L(r_{num})$. Ela corresponde ao primeiro termo da união (celular) em $r_{num}$:
   - $9 D^4 (\epsilon \cup -) D^4$;
   - O primeiro $9$ corresponde ao símbolo literal $9$;
   - $9999$ pertence a $L(D^4) = L(D \cdot D \cdot D \cdot D)$;
   - $-$ pertence a $L(\epsilon \cup -)$;
   - $9999$ pertence a $L(D^4)$;
   - Portanto, $w_{num} \in L(r_{num})$. Ok!

4. **Conclusão**: como $w = w_{ddd} \cdot w_{num}$ e ambas as partes são geradas pelas respectivas subexpressões de $r_{tel}$, pela definição de concatenação de linguagens, temos que $w \in L(r_{tel})$.

### Exercício 4:

Seja $\Sigma = \{a, b\}$ e considere as seguintes linguagens:
- $L_1 = \{a^nb^m \mid n \geq m \geq 0\}$
- $L_2 = \{a^mb^n \mid n \geq m \geq 0\}$

a) Analise se $L_1$ e $L_2$ são linguagens regulares usando o Lema do Bombeamento.
b) Determine as linguagens resultantes das operações $L_1 \cap L_2$, $L_1 \cup L_2$, e $L_1 \cdot L_2$, e classifique cada uma quanto à regularidade.
c) Construa uma expressão regular para $L_3 = \{a^nb^n \mid n \geq 0\} \cup \{a^mb^m \mid m \geq 0\}$ ou prove que não existe.

**Solução Letra a**:

1. **Análise de $L_1 = \{a^nb^m \mid n \geq m \geq 0\}$**

   **Caracterização da linguagem**: $L_1$ contém _strings_ onde o número de $a$'s é maior ou igual ao número de $b$'s. Exemplos: $\{\epsilon, a, aa, ab, aaa, aab, aaab, \ldots\}$.

   **Aplicação do Lema do Bombeamento**:

   **Passo 1 - Hipótese**: Assumimos por contradição que $L_1$ é regular.

   **Passo 2 - Constante de bombeamento**: Se $L_1$ é regular, então existe uma constante $p > 0$ tal que qualquer _string_ $w \in L_1$ com $|w| \geq p$ pode ser dividida como $w = xyz$ satisfazendo:
   - $|y| > 0$;
   - $|xy| \leq p$;
   - $xy^iz \in L_1$ para todo $i \geq 0$.

   **Passo 3 - Escolha da string**: Escolhemos $w = a^pb^p \in L_1$ (válida pois $p \geq p \geq 0$).

   **Passo 4 - Análise da divisão**: Como $|xy| \leq p$ e $w$ inicia com $p$ símbolos $a$ seguidos de $p$ símbolos $b$, a substring $xy$ está inteiramente contida no bloco inicial de $a$'s. Portanto, $y = a^k$ para algum $k$ com $1 \leq k \leq p$.

   **Passo 5 - Teste do bombeamento**: Consideramos $i = 2$:
   $$xy^2z = a^{p+k}b^p$$

   **Passo 6 - Verificação da condição**: Para que $xy^2z \in L_1$, devemos ter:
   $$\text{número de } a\text{'s} \geq \text{número de } b\text{'s}$$
   $$p + k \geq p$$
   $$k \geq 0$$

   Como $k \geq 1$ (pois $|y| > 0$), a condição $k \geq 0$ é sempre satisfeita.

   **Passo 7 - Teste com $i = 0$**: Consideramos $i = 0$:
   $$xy^0z = xz = a^{p-k}b^p$$

   Para que $xz \in L_1$, devemos ter:
   $$p - k \geq p$$
   $$-k \geq 0$$
   $$k \leq 0$$

   **Passo 8 - Contradição**: Temos $k \geq 1$ (de $|y| > 0$) e $k \leq 0$ (da condição de bombeamento), o que é uma contradição.

   **Conclusão**: $L_1$ não é regular.

2. **Análise de $L_2 = \{a^mb^n \mid n \geq m \geq 0\}$**

   **Caracterização da linguagem**:
   $L_2$ contém _strings_ onde o número de $b$'s é maior ou igual ao número de $a$'s. Exemplos: $\{\epsilon, b, a, bb, ab, bbb, abb, abbb, \ldots\}$.

   **Aplicação do Lema do Bombeamento**:

   **Passos 1-4**: Idênticos à análise de $L_1$, escolhendo $w = a^pb^p \in L_2$.

   **Passo 5 - Teste do bombeamento com $i = 2$**:
   $$xy^2z = a^{p+k}b^p$$

   **Passo 6 - Verificação da condição**: Para que $xy^2z \in L_2$, devemos ter:
   $$\text{número de } b\text{'s} \geq \text{número de } a\text{'s}$$
   $$p \geq p + k$$
   $$0 \geq k$$
   $$k \leq 0$$

   **Passo 7 - Contradição**: Temos $k \geq 1$ (de $|y| > 0$) e $k \leq 0$ (da condição), o que é uma contradição.

   **Conclusão**: $L_2$ não é regular.

**Solução Letra b**:

1. **Análise de $L_1 \cap L_2$**

   **Determinação da interseção**:
   $$L_1 \cap L_2 = \{a^nb^m \mid n \geq m \geq 0\} \cap \{a^mb^n \mid n \geq m \geq 0\}$$

   Para uma _string_ $a^rb^s$ pertencer à interseção, deve satisfazer simultaneamente:
   - $r \geq s$ (condição de $L_1$)
   - $s \geq r$ (condição de $L_2$)

   Isso implica $r = s$, portanto:
   $$L_1 \cap L_2 = \{a^nb^n \mid n \geq 0\}$$

   **Análise de regularidade**:
   Esta é a linguagem clássica de balanceamento, que não é regular. Pode ser provada usando o Lema do Bombeamento com a _string_ $a^pb^p$.

2. **Análise de $L_1 \cup L_2$**

   **Determinação da união**:
   $$L_1 \cup L_2 = \{a^nb^m \mid n \geq m \geq 0\} \cup \{a^mb^n \mid n \geq m \geq 0\}$$

   **Análise de regularidade**:
   Como $L_1 \subseteq L_1 \cup L_2$ e $L_1$ não é regular, se $L_1 \cup L_2$ fosse regular, então pela propriedade de fechamento das linguagens regulares sob interseção com linguagens regulares, poderíamos construir $L_1$ como uma interseção envolvendo $L_1 \cup L_2$. Isso criaria uma contradição.

   **Conclusão**: $L_1 \cup L_2$ não é regular.

3. **Análise de $L_1 \cdot L_2$**

   **Caracterização da concatenação**:
   $$L_1 \cdot L_2 = \{uv \mid u \in L_1 \text{ e } v \in L_2\}$$

   **Análise de regularidade**:
   A concatenação de duas linguagens não-regulares não é necessariamente não-regular. No entanto, neste caso específico, podemos mostrar que $L_1 \cdot L_2$ contém como subset a linguagem $\{a^na^nb^nb^n \mid n \geq 0\} = \{a^{2n}b^{2n} \mid n \geq 0\}$, que é uma variação da linguagem de balanceamento e não é regular.

   **Conclusão**: $L_1 \cdot L_2$ não é regular.

**Solução Letra c**:

1. **Análise de $L_3 = \{a^nb^n \mid n \geq 0\} \cup \{a^mb^m \mid m \geq 0\}$**

   **Simplificação da linguagem**:
   $$L_3 = \{a^nb^n \mid n \geq 0\} \cup \{a^mb^m \mid m \geq 0\} = \{a^kb^k \mid k \geq 0\}$$

Ambos os conjuntos na união representam a mesma linguagem (apenas com variáveis diferentes).

**Análise de regularidade**:
A linguagem $L_3 = \{a^kb^k \mid k \geq 0\}$ é a linguagem clássica de _strings_ balanceadas, que sabemos não ser regular.

**Aplicação do Lema do Bombeamento para $L_3$**:

Assumindo que $L_3$ é regular, seja $p$ a constante de bombeamento. Escolhemos $w = a^pb^p \in L_3$.

Para qualquer divisão $w = xyz$ com $|xy| \leq p$ e $|y| > 0$, temos $y = a^k$ com $k \geq 1$.

Para $i = 2$: $xy^2z = a^{p+k}b^p$. Como $p + k \neq p$, esta _string_ não pertence a $L_3$.

Isso contradiz o Lema do Bombeamento.

**Conclusão**: $L_3$ não é regular, portanto **não existe** expressão regular para $L_3$.

### Exercício 5

Seja $\Sigma$ o alfabeto ASCII estendido. Defina os seguintes conjuntos de símbolos:
a. $L = (a \cup b \cup c \cup \ldots \cup z \cup A \cup B \cup C \cup \ldots \cup Z)$ (letras);
b. $D = (0 \cup 1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)$ (dígitos);
c. $D_{nz} = (1 \cup 2 \cup 3 \cup 4 \cup 5 \cup 6 \cup 7 \cup 8 \cup 9)$ (dígitos não-zero);
d. $S = (+ \cup - \cup * \cup / \cup = \cup < \cup > \cup !)$ (símbolos de operadores).

Projete um analisador léxico para uma linguagem que suporte identificadores, números (inteiros, decimais, científicos), operadores aritméticos e relacionais, e comentários.

a) Construa expressões regulares sistemáticas para cada categoria de token.
b) Analise os conflitos de ambiguidade entre as categorias.
c) Estabeleça uma hierarquia de precedência para resolver os conflitos.

**Solução Letra a**:

#### 1. Categoria: Identificadores ($r_{id}$)

**Especificação**: Identificadores começam com letra ou underscore, seguidos de letras, dígitos ou underscores.

**Construção sistemática**:
1. Símbolos iniciais válidos: $S_{ini} = L \cup \{\_\}$;
2. Símbolos de continuação: $S_{cont} = L \cup D \cup \{\_\}$;
3. Expressão para identificadores:

$$r_{id} = S_{ini} \cdot S_{cont}^*$$

**Expandindo as definições**:
$$r_{id} = (L \cup \{\_\}) \cdot (L \cup D \cup \{\_\})^*$$

#### 2. Categoria: Números ($r_{num}$)

**Subcategoria 2.1 - Números Inteiros ($r_{int}$)**:
1. Zero isolado: $0$;
2. Números positivos: $D_{nz} \cdot D^*$;
3. Números com sinal: $(+ \cup - \cup \epsilon) \cdot (0 \cup (D_{nz} \cdot D^*))$.

$$r_{int} = (+ \cup - \cup \epsilon) \cdot (0 \cup (D_{nz} \cdot D^*))$$

**Subcategoria 2.2 - Números Decimais ($r_{dec}$)**:
- Parte inteira obrigatória, ponto, parte fracionária obrigatória:

$$r_{dec} = r_{int} \cdot \{.\} \cdot D \cdot D^*$$

**Subcategoria 2.3 - Notação Científica ($r_{sci}$)**:
- Base (inteiro ou decimal), indicador científico, expoente:

$$r_{sci} = (r_{int} \cup r_{dec}) \cdot (e \cup E) \cdot (+ \cup - \cup \epsilon) \cdot D \cdot D^*$$

**Expressão completa para números**:
$$r_{num} = r_{sci} \cup r_{dec} \cup r_{int}$$

#### 3. Categoria: Operadores ($r_{op}$)

**Subcategoria 3.1 - Operadores Simples ($r_{op\_simples}$)**:
$$r_{op\_simples} = + \cup - \cup * \cup / \cup = \cup < \cup >$$

**Subcategoria 3.2 - Operadores Compostos ($r_{op\_comp}$)**:

1. Incremento/Decremento: $(+ \cdot +) \cup (- \cdot -)$;
2. Igualdade/Desigualdade: $(= \cdot =) \cup (! \cdot =)$;
3. Relacionais compostos: $(< \cdot =) \cup (> \cdot =)$.

$$r_{op\_comp} = (+ \cdot +) \cup (- \cdot -) \cup (= \cdot =) \cup (! \cdot =) \cup (< \cdot =) \cup (> \cdot =)$$

**Expressão completa para operadores**:
$$r_{op} = r_{op\_comp} \cup r_{op\_simples}$$

#### 4. Categoria: Comentários ($r_{com}$)

**Subcategoria 4.1 - Comentários de Linha ($r_{com\_linha}$)**:
1. Sequência `//` seguida de qualquer caractere até quebra de linha:

$$r_{com\_linha} = / \cdot / \cdot \Sigma_{texto}^* \cdot \text{EOL}$$

onde $\Sigma_{texto}$ representa todos os caracteres exceto quebra de linha.

**Subcategoria 4.2 - Comentários de Bloco ($r_{com\_bloco}$)**:
1. Sequência `/*` seguida de qualquer texto até `*/`:

$$r_{com\_bloco} = / \cdot * \cdot \Sigma_{qualquer}^* \cdot * \cdot /$$

onde $\Sigma_{qualquer}$ representa qualquer caractere, mas com restrição de não formar `*/` prematuramente.

**Expressão completa para comentários**:
$$r_{com} = r_{com\_linha} \cup r_{com\_bloco}$$

**Solução Letra b**:

#### Análise de Conflitos de Ambiguidade

1. **Conflito 1 - Identificadores vs Palavras-chave**: palavras reservadas como `if`, `while`, `for` são sintaticamente válidas como identificadores.

   - **Exemplo**: A _string_ `if` satisfaz $r_{id} = (L \cup \{\_\}) \cdot (L \cup D \cup \{\_\})^*$
   - **Impacto**: O analisador não pode distinguir entre palavra-chave e identificador apenas pela forma

2. **Conflito 2 - Operadores Compostos vs Sequência de Operadores Simples**: sequências como `++` podem ser interpretadas como operador composto ou dois operadores `+`.

   **Exemplo**: A _string_ `++` satisfaz tanto $r_{op\_comp}$ quanto $r_{op\_simples} \cdot r_{op\_simples}$
   **Implicação**: Ambiguidade na tokenização que afeta a análise sintática

3. **Conflito 3 - Números Decimais vs Operador Ponto**: se existir operador ponto (`.`), pode conflitar com números decimais.

  **Exemplo**: `1.5` pode ser interpretado como número decimal ou `1` seguido de `.` seguido de `5`
  **Contexto**: Especialmente problemático em linguagens com notação de acesso a membros

4. **Conflito 4 - Comentários vs Operadores de Divisão**: o símbolo `/` inicia tanto comentários quanto operação de divisão

  **Exemplo**: A sequência `/` pode ser início de `//`, `/*` ou operador de divisão
  **Complexidade**: Requer lookahead para decidir a interpretação

5. **Conflito 5 - Sinais vs Operadores vs Números com Sinal**: os símbolos `+` e `-` podem ser operadores binários, unários, ou parte de números.

  **Exemplo**: `-5` pode ser número negativo ou operador `-` seguido de número `5`
  **Dependência**: Resolução depende do contexto sintático

**Solução Letra c**:

#### Hierarquia de Precedência para Resolução de Conflitos

1. **Nível 1 (Maior Precedência): Comentários**

- **Regra**: Reconhecer `//` e `/*` antes de qualquer outra análise
- **Justificativa**: Comentários alteram fundamentalmente o processamento (podem "comentar" outros tokens)
- **Implementação**: Scanner deve verificar comentários primeiro em cada posição

2. **Nível 2: Palavras-chave Reservadas**

- **Regra**: Lista finita de palavras reservadas tem precedência sobre $r_{id}$
- **Método**: Lookup table de palavras-chave após reconhecer padrão de identificador
- **Algoritmo**: 
  1. Aplicar $r_{id}$ para reconhecer padrão
  2. Consultar tabela de palavras reservadas
  3. Se encontrada, classificar como palavra-chave; senão, como identificador

3. **Nível 3: Números (Regra do Maior Match)**

- **Regra**: Sempre consumir a maior sequência válida como número
- **Ordem de tentativa**: $r_{sci} \succ r_{dec} \succ r_{int}$
- **Exemplo**: `1.5e-3` deve ser reconhecido como um token científico, não como três tokens separados

4. **Nível 4: Operadores Compostos (Regra do Maior Match)**

- **Regra**: Operadores compostos têm precedência sobre sequências de operadores simples
- **Exemplo**: `++` é reconhecido como incremento, não como dois operadores `+`
- **Implementação**: Verificar padrões compostos antes dos simples

5. **Nível 5: Operadores Simples**

- **Regra**: Reconhecer operadores individuais
- **Resolução de ambiguidade**: Dependente do contexto sintático (análise posterior)

**Algoritmo de Tokenização**:

A seguir a esforçada leitora pode ver um pseudocódigo de um dos possíveis algoritmos de _tokenização_ que implementa a hierarquia de precedência conforme definido neste exercício:

```pseudocode
Para cada posição no texto fonte:
   1. Ignorar espaços em branco
   2. Se match(r_com): retornar TOKEN_COMENTARIO
   3. Se match(r_num): retornar TOKEN_NUMERO
   4. Se match(r_id):
      4.1. Se é palavra_reservada: retornar TOKEN_PALAVRA_CHAVE
      4.2. Senão: retornar TOKEN_IDENTIFICADOR
   5. Se match(r_op_comp): retornar TOKEN_OPERADOR_COMPOSTO
   6. Se match(r_op_simples): retornar TOKEN_OPERADOR_SIMPLES
   7. Senão: erro léxico
```

**Considerações Especiais**:

1. **Lookahead Necessário**:

   - Comentários: Verificar `/` seguido de `/` ou `*`;
   - Operadores: Verificar `+` seguido de `+`, `=` seguido de `=`, etc.;
   - Números científicos: Verificar `e`/`E` em contexto numérico.

2. **Tratamento de Contexto**:

   - Sinais unários vs binários: Resolver na fase de análise sintática;
   - Números negativos: Tratar como operador unário aplicado a número positivo.

#### Em C++ 23

O código a seguir contém uma implementação do analisador léxico definido neste problema em C++23, usando as características desta linguagem para simplificar a implementação:

```cpp
#include <iostream>
#include <string>
#include <string_view>
#include <vector>
#include <unordered_set>
#include <expected>
#include <print>
#include <ranges>
#include <algorithm>
#include <concepts>
#include <optional>

// Definição dos tipos de token seguindo nossa hierarquia
enum class TokenType {
    COMENTARIO,
    PALAVRA_CHAVE, 
    NUMERO,
    IDENTIFICADOR,
    OPERADOR_COMPOSTO,
    OPERADOR_SIMPLES,
    UNKNOWN,
    END_OF_INPUT
};

// Estrutura do token
struct Token {
    TokenType type;
    std::string value;
    
    void print() const {
        std::println("Token: {} | Valor: '{}'", to_string(type), value);
    }
};

// Conversão de TokenType para string
std::string to_string(TokenType type) {
    switch (type) {
        case TokenType::COMENTARIO: return "COMENTARIO";
        case TokenType::PALAVRA_CHAVE: return "PALAVRA_CHAVE";
        case TokenType::NUMERO: return "NUMERO";
        case TokenType::IDENTIFICADOR: return "IDENTIFICADOR";
        case TokenType::OPERADOR_COMPOSTO: return "OPERADOR_COMPOSTO";
        case TokenType::OPERADOR_SIMPLES: return "OPERADOR_SIMPLES";
        case TokenType::UNKNOWN: return "UNKNOWN";
        case TokenType::END_OF_INPUT: return "END_OF_INPUT";
    }
    return "INVALID";
}

// Conceitos para classificação de caracteres (conjuntos L, D, etc.)
template<typename T>
concept Character = std::same_as<T, char>;

class CharacterClassifier {
public:
    // Conjunto L = (a ∪ b ∪ ... ∪ z ∪ A ∪ B ∪ ... ∪ Z)
    static constexpr bool isLetter(char c) {
        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
    }
    
    // Conjunto D = (0 ∪ 1 ∪ 2 ∪ ... ∪ 9)
    static constexpr bool isDigit(char c) {
        return c >= '0' && c <= '9';
    }
    
    // Conjunto D_nz = (1 ∪ 2 ∪ ... ∪ 9)
    static constexpr bool isNonZeroDigit(char c) {
        return c >= '1' && c <= '9';
    }
    
    // Conjunto S_ini = L ∪ {_}
    static constexpr bool isIdentifierStart(char c) {
        return isLetter(c) || c == '_';
    }
    
    // Conjunto S_cont = L ∪ D ∪ {_}
    static constexpr bool isIdentifierContinuation(char c) {
        return isLetter(c) || isDigit(c) || c == '_';
    }
    
    static constexpr bool isWhitespace(char c) {
        return c == ' ' || c == '\t' || c == '\n' || c == '\r';
    }
    
    static constexpr bool isOperatorSymbol(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/' || 
               c == '=' || c == '<' || c == '>' || c == '!';
    }
};

class LexicalAnalyzer {
private:
    std::string_view input;
    size_t position = 0;
    
    // Palavras-chave reservadas (Nível 2 da hierarquia)
    std::unordered_set<std::string> keywords = {
        "if", "else", "while", "for", "int", "float", "double",
        "char", "void", "return", "break", "continue", "true", "false"
    };
    
public:
    explicit LexicalAnalyzer(std::string_view text) : input(text) {}
    
    // Método principal de tokenização seguindo nossa hierarquia
    std::expected<Token, std::string> nextToken() {
        skipWhitespace();
        
        if (position >= input.length()) {
            return Token{TokenType::END_OF_INPUT, ""};
        }
        
        // Nível 1: Comentários (maior precedência)
        if (auto comment = tryParseComment()) {
            return *comment;
        }
        
        // Nível 3: Números (regra do maior match)
        if (auto number = tryParseNumber()) {
            return *number;
        }
        
        // Nível 2: Identificadores (depois verificamos se é palavra-chave)
        if (auto identifier = tryParseIdentifier()) {
            return *identifier;
        }
        
        // Nível 4: Operadores compostos (regra do maior match)
        if (auto compoundOp = tryParseCompoundOperator()) {
            return *compoundOp;
        }
        
        // Nível 5: Operadores simples
        if (auto simpleOp = tryParseSimpleOperator()) {
            return *simpleOp;
        }
        
        // Erro léxico
        return std::unexpected(std::format("Caractere inválido '{}' na posição {}", 
                                         input[position], position));
    }
    
private:
    void skipWhitespace() {
        while (position < input.length() && CharacterClassifier::isWhitespace(input[position])) {
            position++;
        }
    }
    
    char peek(size_t offset = 0) const {
        size_t pos = position + offset;
        return pos < input.length() ? input[pos] : '\0';
    }
    
    // Nível 1: r_com = r_com_linha ∪ r_com_bloco
    std::optional<Token> tryParseComment() {
        if (peek() != '/') return std::nullopt;
        
        // r_com_linha = / · / · Σ_texto* · EOL
        if (peek(1) == '/') {
            size_t start = position;
            position += 2; // Consome "//"
            
            // Consome até o final da linha
            while (position < input.length() && input[position] != '\n') {
                position++;
            }
            if (position < input.length()) position++; // Consome '\n'
            
            return Token{TokenType::COMENTARIO, 
                        std::string(input.substr(start, position - start))};
        }
        
        // r_com_bloco = / · * · Σ_qualquer* · * · /
        if (peek(1) == '*') {
            size_t start = position;
            position += 2; // Consome "/*"
            
            // Procura por "*/"
            while (position < input.length() - 1) {
                if (input[position] == '*' && input[position + 1] == '/') {
                    position += 2; // Consome "*/"
                    return Token{TokenType::COMENTARIO,
                                std::string(input.substr(start, position - start))};
                }
                position++;
            }
            
            // Comentário não fechado - erro
            return std::nullopt;
        }
        
        return std::nullopt;
    }
    
    // Nível 3: r_num = r_sci ∪ r_dec ∪ r_int
    std::optional<Token> tryParseNumber() {
        if (!CharacterClassifier::isDigit(peek()) && 
            peek() != '+' && peek() != '-') {
            return std::nullopt;
        }
        
        size_t start = position;
        
        // Consome sinal opcional
        if (peek() == '+' || peek() == '-') {
            position++;
        }
        
        // r_int = (+ ∪ - ∪ ε) · (0 ∪ (D_nz · D*))
        if (!parseIntegerPart()) {
            position = start;
            return std::nullopt;
        }
        
        // Tenta parte decimal: r_dec = r_int · {.} · D · D*
        bool hasDecimal = false;
        if (peek() == '.') {
            size_t dotPos = position;
            position++; // Consome '.'
            
            if (CharacterClassifier::isDigit(peek())) {
                hasDecimal = true;
                // Consome dígitos após o ponto
                while (CharacterClassifier::isDigit(peek())) {
                    position++;
                }
            } else {
                // Não é número decimal, volta atrás
                position = dotPos;
            }
        }
        
        // Tenta notação científica: r_sci = (r_int ∪ r_dec) · (e ∪ E) · (+ ∪ - ∪ ε) · D · D*
        if (peek() == 'e' || peek() == 'E') {
            size_t expPos = position;
            position++; // Consome 'e' ou 'E'
            
            // Sinal opcional no expoente
            if (peek() == '+' || peek() == '-') {
                position++;
            }
            
            // Deve ter pelo menos um dígito no expoente
            if (CharacterClassifier::isDigit(peek())) {
                while (CharacterClassifier::isDigit(peek())) {
                    position++;
                }
            } else {
                // Notação científica inválida
                position = expPos;
            }
        }
        
        return Token{TokenType::NUMERO, 
                    std::string(input.substr(start, position - start))};
    }
    
    bool parseIntegerPart() {
        if (peek() == '0') {
            position++;
            return true;
        }
        
        if (CharacterClassifier::isNonZeroDigit(peek())) {
            position++;
            while (CharacterClassifier::isDigit(peek())) {
                position++;
            }
            return true;
        }
        
        return false;
    }
    
    // Nível 2: r_id = (L ∪ {_}) · (L ∪ D ∪ {_})*
    std::optional<Token> tryParseIdentifier() {
        if (!CharacterClassifier::isIdentifierStart(peek())) {
            return std::nullopt;
        }
        
        size_t start = position;
        position++; // Consome primeiro caractere
        
        // Consome caracteres de continuação
        while (CharacterClassifier::isIdentifierContinuation(peek())) {
            position++;
        }
        
        std::string value(input.substr(start, position - start));
        
        // Verifica se é palavra-chave (Nível 2 da hierarquia)
        TokenType type = keywords.contains(value) ? 
                        TokenType::PALAVRA_CHAVE : TokenType::IDENTIFICADOR;
        
        return Token{type, value};
    }
    
    // Nível 4: r_op_comp = (+ · +) ∪ (- · -) ∪ (= · =) ∪ (! · =) ∪ (< · =) ∪ (> · =)
    std::optional<Token> tryParseCompoundOperator() {
        char first = peek();
        char second = peek(1);
        
        if ((first == '+' && second == '+') ||
            (first == '-' && second == '-') ||
            (first == '=' && second == '=') ||
            (first == '!' && second == '=') ||
            (first == '<' && second == '=') ||
            (first == '>' && second == '=')) {
            
            std::string value{first, second};
            position += 2;
            return Token{TokenType::OPERADOR_COMPOSTO, value};
        }
        
        return std::nullopt;
    }
    
    // Nível 5: r_op_simples = + ∪ - ∪ * ∪ / ∪ = ∪ < ∪ >
    std::optional<Token> tryParseSimpleOperator() {
        char c = peek();
        
        if (CharacterClassifier::isOperatorSymbol(c)) {
            position++;
            return Token{TokenType::OPERADOR_SIMPLES, std::string(1, c)};
        }
        
        return std::nullopt;
    }
};

// Função para processar uma linha de entrada
void processLine(std::string_view line) {
    std::println("\n=== Analisando: '{}' ===", line);
    
    LexicalAnalyzer analyzer(line);
    
    while (true) {
        auto result = analyzer.nextToken();
        
        if (!result) {
            std::println("ERRO: {}", result.error());
            break;
        }
        
        Token token = *result;
        
        if (token.type == TokenType::END_OF_INPUT) {
            std::println("=== Fim da análise ===");
            break;
        }
        
        token.print();
    }
}

int main() {
    std::println("=== Analisador Léxico C++23 ===");
    std::println("Digite expressões linha por linha (Ctrl+C para sair):");
    std::println();
    
    std::string line;
    while (std::getline(std::cin, line)) {
        if (!line.empty()) {
            processLine(line);
        }
        std::println("\nDigite a próxima expressão:");
    }
    
    return 0;
}
```
Para usar: 

```shell
Digite: int x = 42;
```

Neste caso a saída deve ser:

```shell
Token: PALAVRA_CHAVE | Valor: 'int'
Token: IDENTIFICADOR | Valor: 'x'
Token: OPERADOR_SIMPLES | Valor: '='
Token: NUMERO | Valor: '42'
```

## Exercício 6: Classes de Equivalência

Considere a linguagem $L = \{w \in \{0,1\}^* \mid w \text{ contém um número par de } 0\text{'s e um número ímpar de } 1\text{'s}\}$.

a) Determine quantas classes de equivalência existem na relação de Myhill-Nerode para $L$ (ver @sec-myhill-nerode).
b) Construa o autômato finito correspondente.

**Solução Letra a**

1. **Classes de equivalência**: precisamos rastrear paridades de 0's e 1's:

a. $q_{00}$: par de 0's, par de 1's;
b. $q_{01}$: par de 0's, ímpar de 1's ← **estado de aceitação**;
c. $q_{10}$: ímpar de 0's, par de 1's;
d. $q_{11}$: ímpar de 0's, ímpar de 1's.

**Total: 4 classes de equivalência**

**Solução Letra b: Autômato Finito**:

Estados: {q00, q01, q10, q11}
Estado inicial: q00
Estado final: {q01}

| Estado | 0 | 1 |
|--------|---|---|
| →q00   | q10 | q01 |
| *q01   | q11 | q00 |
| q10    | q00 | q11 |
| q11    | q01 | q10 |

Legenda: `→` Estado inicial; `*` Estado final.

### Exercício 7: Lema do Bombeamento 

Considere a linguagem $L = \{0^i1^j0^k \mid i, j, k \geq 1 \text{ e } i + k = j\}$.

a) Prove que $L$ não é regular usando o Lema do Bombeamento.
b) Identifique qual propriedade específica de $L$ viola a capacidade dos autômatos finitos.
c) Construa uma linguagem regular $L'$ que seja o "mais próxima possível" de $L$.

**Solução letra a**:

1. **Prova usando Lema do Bombeamento**:

Assumimos que $L$ é regular. Seja $p$ a constante do bombeamento.

Escolhemos $w = 0^p1^{2p}0^p \in L$ (pois $p + p = 2p$).

Como $|w| = 4p \geq p$, podemos dividir $w = xyz$ onde:
- $|y| > 0$
- $|xy| \leq p$  
- $xy^iz \in L$ para todo $i \geq 0$

Como $|xy| \leq p$ e $w$ começa com $p$ zeros, temos $y = 0^m$ para algum $1 \leq m \leq p$.

Para $i = 2$: $w' = xy^2z = 0^{p+m}1^{2p}0^p$

Na _string_ $w'$:
- Número de 0's iniciais: $p + m$
- Número de 1's: $2p$  
- Número de 0's finais: $p$

A condição $i + k = j$ requer: $(p + m) + p = 2p$, ou seja, $2p + m = 2p$, logo $m = 0$.

Mas isso contradiz $|y| > 0$, que implica $m \geq 1$.

Portanto, $L$ não é regular.

**Solução Letra b**:

A linguagem $L$ requer uma **relação aritmética** entre partes não-adjacentes da _string_ ($i + k = j$). Um autômato finito não pode "lembrar" o valor de $i$ para comparar com $k$ após processar toda a sequência de 1's.

**Solução Letra c**:

$$L' = 0^+1^+0^+$$

Esta linguagem captura a estrutura (0's, depois 1's, depois 0's) sem a restrição aritmética.

